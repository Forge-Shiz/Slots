<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHANNEL 3 — Do Not Adjust Your Set</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --crt-green: #33ff33;
            --crt-amber: #ffaa00;
            --static-dark: #0a0a0a;
            --scan-opacity: 0.08;
            --vhs-blue: #0066cc;
            --dread-red: #990000;
            --cold-blue: #4488aa;

            /* TV screen coordinates within the 2896x2896 image */
            --tv-width: 2896;
            --tv-height: 2896;
            --screen-left: 644;
            --screen-top: 991;
            --screen-width: 1296;
            --screen-height: 951;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'VT323', monospace;
            overflow: hidden;
            color: #ccc;
        }

        /* Main game container */
        #game-container {
            position: relative;
            width: 100vmin;
            height: 100vmin;
            max-width: 900px;
            max-height: 900px;
        }

        /* TV Background/Bezel layer */
        #tv-bezel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('assets/bck.webp');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            z-index: 100;
            pointer-events: none;
        }

        /* Screen area container - positioned to match transparent area */
        #screen-area {
            position: absolute;
            /* Percentages based on coordinates within 2896x2896 image */
            left: 22.23%;
            top: 34.22%;
            width: 44.75%;
            height: 32.84%;
            z-index: 10;
            overflow: hidden;
            border-radius: 2%;
        }

        /* Dark static background behind symbols */
        #static-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--static-dark);
            z-index: 1;
        }

        /* Animated static noise */
        #static-noise {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            opacity: 0.15;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            animation: staticShift 0.1s steps(5) infinite;
        }

        @keyframes staticShift {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-2%, 1%); }
            50% { transform: translate(1%, -2%); }
            75% { transform: translate(-1%, 2%); }
            100% { transform: translate(2%, -1%); }
        }

        /* Symbol grid */
        #symbol-grid {
            position: absolute;
            top: 3%;
            left: 2%;
            width: 96%;
            height: 94%;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            z-index: 10;
        }

        .symbol-cell {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .symbol-cell img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            transition: transform 0.1s;
            image-rendering: auto;
        }

        /* Frozen/sticky symbol effect */
        .symbol-cell.frozen {
            animation: vhsPause 0.15s steps(2) infinite;
        }

        .symbol-cell.frozen::before {
            content: '▮▮';
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 0.6em;
            color: rgba(255, 255, 255, 0.5);
            z-index: 20;
            text-shadow: 1px 0 #ff0000, -1px 0 #00ffff;
        }

        .symbol-cell.frozen img {
            filter: brightness(0.85) saturate(0.9);
        }

        @keyframes vhsPause {
            0% { transform: translateX(0); }
            50% { transform: translateX(-1px); }
            100% { transform: translateX(1px); }
        }

        /* RGB split effect for frozen symbols */
        .symbol-cell.frozen img {
            animation: rgbSplit 0.2s steps(3) infinite;
        }

        @keyframes rgbSplit {
            0% {
                filter: brightness(0.85);
                text-shadow: none;
            }
            33% {
                filter: brightness(0.85) drop-shadow(-2px 0 #ff0000);
            }
            66% {
                filter: brightness(0.85) drop-shadow(2px 0 #00ffff);
            }
        }

        /* Spinning symbol effect */
        .symbol-cell.spinning img {
            animation: channelSurf 0.08s steps(1) infinite;
        }

        @keyframes channelSurf {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.95); }
            100% { opacity: 1; transform: scale(1); }
        }

        /* Scan lines overlay */
        #scan-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 2px,
                rgba(0, 0, 0, var(--scan-opacity)) 2px,
                rgba(0, 0, 0, var(--scan-opacity)) 4px
            );
            z-index: 50;
            pointer-events: none;
        }

        /* CRT flicker effect */
        #crt-flicker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 51;
            pointer-events: none;
            animation: crtFlicker 8s ease-in-out infinite;
        }

        @keyframes crtFlicker {
            0%, 96%, 100% { opacity: 0; }
            96.5% { opacity: 0.03; }
            97% { opacity: 0; }
            97.5% { opacity: 0.05; }
            98% { opacity: 0; }
        }

        /* VHS tracking line */
        #tracking-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 8px;
            background: linear-gradient(
                180deg,
                transparent 0%,
                rgba(255, 255, 255, 0.1) 30%,
                rgba(255, 255, 255, 0.3) 50%,
                rgba(255, 255, 255, 0.1) 70%,
                transparent 100%
            );
            z-index: 52;
            pointer-events: none;
            opacity: 0;
            top: -20px;
        }

        .tracking-active #tracking-line {
            animation: trackingRoll 2s linear forwards;
        }

        @keyframes trackingRoll {
            0% { top: -20px; opacity: 0.8; }
            10% { opacity: 0.8; }
            100% { top: 110%; opacity: 0.3; }
        }

        /* CRT curvature effect */
        #screen-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 70%,
                rgba(0, 0, 0, 0.3) 100%
            );
            z-index: 60;
            pointer-events: none;
        }

        /* UI Controls - Broadcast overlay style */
        #ui-container {
            position: absolute;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #controls-row {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .ui-button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #aaa;
            font-family: 'VT323', monospace;
            font-size: 1.1em;
            padding: 8px 20px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .ui-button:hover {
            color: #fff;
            border-color: rgba(255, 255, 255, 0.6);
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .ui-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .ui-button.active {
            color: var(--crt-amber);
            border-color: var(--crt-amber);
        }

        #spin-btn {
            font-size: 1.4em;
            padding: 12px 40px;
            border-width: 2px;
        }

        #bet-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #bet-selector label {
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #bet-select {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #aaa;
            font-family: 'VT323', monospace;
            font-size: 1em;
            padding: 5px 10px;
            cursor: pointer;
        }

        #bet-select option {
            background: #111;
            color: #aaa;
        }

        /* Info displays - channel watermark style */
        #info-display {
            position: absolute;
            top: 8%;
            right: 8%;
            z-index: 200;
            text-align: right;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #balance-display, #win-display {
            margin-bottom: 5px;
        }

        #win-display {
            color: rgba(255, 255, 255, 0);
            transition: color 0.3s;
        }

        #win-display.show {
            color: rgba(255, 255, 255, 0.8);
        }

        /* Channel indicator */
        #channel-indicator {
            position: absolute;
            top: 8%;
            left: 8%;
            z-index: 200;
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.5);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #channel-indicator::before {
            content: 'CH';
            font-size: 0.7em;
            margin-right: 5px;
            opacity: 0.7;
        }

        /* Free spins broadcast counter */
        #broadcast-counter {
            position: absolute;
            top: 8%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            font-family: 'VT323', monospace;
            font-size: 1.1em;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #broadcast-counter.show {
            opacity: 1;
        }

        /* Multiplier display */
        #multiplier-display {
            position: absolute;
            bottom: 25%;
            right: 8%;
            z-index: 200;
            font-family: 'VT323', monospace;
            font-size: 1.5em;
            color: var(--crt-amber);
            text-shadow: 0 0 10px var(--crt-amber), 2px 2px 4px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #multiplier-display.show {
            opacity: 1;
        }

        /* PLEASE STAND BY overlay */
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: #000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #overlay-screen.show {
            opacity: 1;
            pointer-events: all;
        }

        #overlay-text {
            font-family: 'VT323', monospace;
            font-size: 2.5em;
            color: #fff;
            text-align: center;
            letter-spacing: 8px;
            text-shadow:
                0 0 20px rgba(255, 255, 255, 0.8),
                0 0 40px rgba(255, 255, 255, 0.4),
                0 0 60px rgba(255, 255, 255, 0.2);
            animation: overlayFlicker 0.1s steps(2) infinite;
        }

        @keyframes overlayFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.95; }
        }

        #overlay-subtext {
            font-family: 'Share Tech Mono', monospace;
            font-size: 1em;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 20px;
            letter-spacing: 3px;
        }

        /* Free spins mode - cold filter */
        .free-spins-mode #screen-area {
            filter: hue-rotate(-20deg) saturate(0.8) brightness(0.95);
        }

        .free-spins-mode #scan-lines {
            --scan-opacity: 0.15;
        }

        .free-spins-mode #static-noise {
            opacity: 0.25;
        }

        /* Win presentation styles */
        .win-small #screen-area {
            animation: staticBurst 0.2s ease-out;
        }

        .win-medium #screen-area {
            animation: mediumDistort 0.4s ease-out;
        }

        .win-big #screen-area {
            animation: bigDistort 0.6s ease-out;
        }

        @keyframes staticBurst {
            0% { filter: brightness(1.2) contrast(1.1); }
            100% { filter: brightness(1) contrast(1); }
        }

        @keyframes mediumDistort {
            0% { transform: translateX(0); filter: hue-rotate(0deg); }
            25% { transform: translateX(-3px); filter: hue-rotate(10deg); }
            50% { transform: translateX(3px); filter: hue-rotate(-10deg); }
            75% { transform: translateX(-1px); filter: hue-rotate(5deg); }
            100% { transform: translateX(0); filter: hue-rotate(0deg); }
        }

        @keyframes bigDistort {
            0% { transform: scale(1); filter: brightness(1) saturate(1); }
            20% { transform: scale(1.02); filter: brightness(1.3) saturate(1.5) hue-rotate(20deg); }
            40% { transform: scale(0.98); filter: brightness(0.8) saturate(0.5) hue-rotate(-20deg); }
            60% { transform: scale(1.01); filter: brightness(1.2) saturate(1.3); }
            80% { transform: scale(0.99); filter: brightness(0.9) saturate(0.8); }
            100% { transform: scale(1); filter: brightness(1) saturate(1); }
        }

        /* Mega win - full static */
        #mega-win-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 250;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #mega-win-overlay.show {
            opacity: 1;
        }

        #mega-win-amount {
            font-family: 'VT323', monospace;
            font-size: 4em;
            color: #fff;
            letter-spacing: 5px;
        }

        /* Degradation levels during respins */
        .degradation-1 #scan-lines { --scan-opacity: 0.10; }
        .degradation-2 #scan-lines { --scan-opacity: 0.12; }
        .degradation-3 #scan-lines { --scan-opacity: 0.15; }
        .degradation-4 #scan-lines { --scan-opacity: 0.18; }
        .degradation-5 #scan-lines { --scan-opacity: 0.22; }

        .degradation-1 #static-noise { opacity: 0.18; }
        .degradation-2 #static-noise { opacity: 0.22; }
        .degradation-3 #static-noise { opacity: 0.28; }
        .degradation-4 #static-noise { opacity: 0.35; }
        .degradation-5 #static-noise { opacity: 0.45; }

        .degradation-3 #screen-area,
        .degradation-4 #screen-area,
        .degradation-5 #screen-area {
            filter: hue-rotate(-10deg) saturate(0.9);
        }

        /* Wild sticky glow during free spins */
        .symbol-cell.sticky-wild img {
            filter: brightness(1.2) drop-shadow(0 0 8px var(--cold-blue));
            animation: wildPulse 1s ease-in-out infinite;
        }

        @keyframes wildPulse {
            0%, 100% { filter: brightness(1.2) drop-shadow(0 0 8px var(--cold-blue)); }
            50% { filter: brightness(1.4) drop-shadow(0 0 15px var(--cold-blue)); }
        }

        /* Logo in corner */
        #logo {
            position: absolute;
            bottom: 20%;
            left: 8%;
            width: 80px;
            opacity: 0.4;
            z-index: 200;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            #ui-container {
                bottom: 3%;
            }

            .ui-button {
                font-size: 0.9em;
                padding: 6px 12px;
            }

            #spin-btn {
                font-size: 1.1em;
                padding: 10px 25px;
            }

            #info-display, #channel-indicator {
                font-size: 0.75em;
            }

            #overlay-text {
                font-size: 1.8em;
                letter-spacing: 4px;
            }
        }

        /* Scatter win highlight */
        .symbol-cell.scatter-win {
            animation: scatterPulse 0.5s ease-out;
        }

        @keyframes scatterPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); filter: brightness(1.5); }
            100% { transform: scale(1); }
        }

        /* New winning symbols flash */
        .symbol-cell.new-win {
            animation: newWinFlash 0.3s ease-out;
        }

        @keyframes newWinFlash {
            0% { filter: brightness(2) saturate(0); }
            100% { filter: brightness(1) saturate(1); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- TV Bezel (foreground) -->
        <div id="tv-bezel"></div>

        <!-- Screen area (behind bezel) -->
        <div id="screen-area">
            <div id="static-bg"></div>
            <div id="static-noise"></div>
            <div id="symbol-grid"></div>
            <div id="scan-lines"></div>
            <div id="crt-flicker"></div>
            <div id="tracking-line"></div>
        </div>

        <!-- Overlays -->
        <div id="overlay-screen">
            <div id="overlay-text">PLEASE STAND BY</div>
            <div id="overlay-subtext"></div>
        </div>

        <div id="mega-win-overlay">
            <div id="mega-win-amount"></div>
        </div>

        <!-- UI Elements -->
        <div id="channel-indicator">3</div>

        <div id="info-display">
            <div id="balance-display">CREDIT $1000.00</div>
            <div id="win-display">WIN $0.00</div>
        </div>

        <div id="broadcast-counter"></div>
        <div id="multiplier-display"></div>

        <img id="logo" src="assets/logo.webp" alt="">

        <div id="ui-container">
            <div id="controls-row">
                <div id="bet-selector">
                    <label>BET</label>
                    <select id="bet-select">
                        <option value="0.20">$0.20</option>
                        <option value="0.40">$0.40</option>
                        <option value="1.00" selected>$1.00</option>
                        <option value="2.00">$2.00</option>
                        <option value="5.00">$5.00</option>
                        <option value="10.00">$10.00</option>
                    </select>
                </div>
                <button id="spin-btn" class="ui-button">TRANSMIT</button>
                <button id="auto-btn" class="ui-button">AUTO</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // CHANNEL 3 - Analog Horror Slot Game
        // ========================================

        // AUDIO HOOKS (to be implemented later)
        // - playAmbientHum(): CRT ambient hum loop
        // - playTapeHiss(): VHS tape hiss
        // - playStaticBurst(): Static burst on wins
        // - playEBSTone(): Detuned EBS tone for free spins
        // - playRespinPitch(level): Increasing pitch during chains
        // - playSilence(): Cut all audio for mega wins

        // Game Configuration
        const CONFIG = {
            cols: 6,
            rows: 5,
            symbols: {
                h1: { id: 'h1', name: 'The Puppet', file: 'sym_h1_puppet.webp', weight: 8 },
                h2: { id: 'h2', name: 'The Host', file: 'sym_h2_host.webp', weight: 10 },
                h3: { id: 'h3', name: 'The Signal', file: 'sym_h3_signal.webp', weight: 12 },
                h4: { id: 'h4', name: 'The Test Pattern', file: 'sym_h4_testpattern.webp', weight: 14 },
                l1: { id: 'l1', name: 'VHS Tape', file: 'sym_l1_vhs.webp', weight: 18 },
                l2: { id: 'l2', name: 'Rotary Phone', file: 'sym_l2_phone.webp', weight: 20 },
                l3: { id: 'l3', name: 'TV Dinner', file: 'sym_l3_tvdinner.webp', weight: 22 },
                l4: { id: 'l4', name: 'Rabbit Ears', file: 'sym_l4_antenna.webp', weight: 24 },
                wild: { id: 'wild', name: 'Static', file: 'sym_wild_static.webp', weight: 5, isWild: true },
                scatter: { id: 'scatter', name: 'Emergency Broadcast', file: 'sym_scatter_ebs.webp', weight: 6, isScatter: true }
            },
            // Placeholder paytable - scatter pays based on count
            paytable: {
                h1: { 8: 5, 9: 8, 10: 12, 11: 18, 12: 25, 13: 35, 14: 50, 15: 75, 16: 100, 17: 150, 18: 200 },
                h2: { 8: 4, 9: 6, 10: 10, 11: 15, 12: 20, 13: 28, 14: 40, 15: 60, 16: 80, 17: 120, 18: 160 },
                h3: { 8: 3, 9: 5, 10: 8, 11: 12, 12: 16, 13: 22, 14: 32, 15: 48, 16: 64, 17: 96, 18: 128 },
                h4: { 8: 2.5, 9: 4, 10: 6, 11: 10, 12: 14, 13: 18, 14: 26, 15: 40, 16: 54, 17: 80, 18: 108 },
                l1: { 8: 2, 9: 3, 10: 5, 11: 8, 12: 11, 13: 15, 14: 22, 15: 32, 16: 44, 17: 64, 18: 88 },
                l2: { 8: 1.5, 9: 2.5, 10: 4, 11: 6, 12: 9, 13: 12, 14: 18, 15: 26, 16: 36, 17: 52, 18: 72 },
                l3: { 8: 1, 9: 2, 10: 3, 11: 5, 12: 7, 13: 10, 14: 14, 15: 20, 16: 28, 17: 40, 18: 56 },
                l4: { 8: 0.8, 9: 1.5, 10: 2.5, 11: 4, 12: 6, 13: 8, 14: 12, 15: 16, 16: 22, 17: 32, 18: 44 }
            },
            freeSpinsTrigger: { 3: 8, 4: 12, 5: 16, 6: 20 }
        };

        // Game State
        let state = {
            balance: 1000.00,
            bet: 1.00,
            grid: [],
            spinning: false,
            autoPlay: false,
            freeSpins: {
                active: false,
                remaining: 0,
                total: 0,
                stickyWilds: [], // Positions of sticky wilds
                multiplier: 1
            },
            respinChain: 0,
            totalWin: 0
        };

        // DOM Elements
        const elements = {
            grid: document.getElementById('symbol-grid'),
            spinBtn: document.getElementById('spin-btn'),
            autoBtn: document.getElementById('auto-btn'),
            betSelect: document.getElementById('bet-select'),
            balanceDisplay: document.getElementById('balance-display'),
            winDisplay: document.getElementById('win-display'),
            overlay: document.getElementById('overlay-screen'),
            overlayText: document.getElementById('overlay-text'),
            overlaySubtext: document.getElementById('overlay-subtext'),
            megaWinOverlay: document.getElementById('mega-win-overlay'),
            megaWinAmount: document.getElementById('mega-win-amount'),
            broadcastCounter: document.getElementById('broadcast-counter'),
            multiplierDisplay: document.getElementById('multiplier-display'),
            gameContainer: document.getElementById('game-container'),
            screenArea: document.getElementById('screen-area')
        };

        // Utility Functions
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getRandomSymbol(excludeScatter = false) {
            const symbolKeys = Object.keys(CONFIG.symbols);
            const filtered = excludeScatter
                ? symbolKeys.filter(k => k !== 'scatter')
                : symbolKeys;

            // Weighted random selection
            let totalWeight = 0;
            const weights = filtered.map(k => {
                totalWeight += CONFIG.symbols[k].weight;
                return { key: k, weight: CONFIG.symbols[k].weight };
            });

            let random = Math.random() * totalWeight;
            for (const item of weights) {
                random -= item.weight;
                if (random <= 0) return item.key;
            }
            return weights[weights.length - 1].key;
        }

        function getSymbolAtPosition(col, row) {
            return state.grid[row * CONFIG.cols + col];
        }

        function setSymbolAtPosition(col, row, symbolId) {
            state.grid[row * CONFIG.cols + col] = symbolId;
        }

        // Initialize Grid
        function initGrid() {
            elements.grid.innerHTML = '';
            state.grid = [];

            for (let row = 0; row < CONFIG.rows; row++) {
                for (let col = 0; col < CONFIG.cols; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'symbol-cell';
                    cell.dataset.col = col;
                    cell.dataset.row = row;
                    cell.dataset.index = row * CONFIG.cols + col;

                    const img = document.createElement('img');
                    const symbolId = getRandomSymbol();
                    state.grid.push(symbolId);
                    img.src = `assets/${CONFIG.symbols[symbolId].file}`;
                    img.alt = CONFIG.symbols[symbolId].name;

                    cell.appendChild(img);
                    elements.grid.appendChild(cell);
                }
            }
        }

        // Update Display
        function updateBalance() {
            elements.balanceDisplay.textContent = `CREDIT $${state.balance.toFixed(2)}`;
        }

        function showWin(amount) {
            elements.winDisplay.textContent = `WIN $${amount.toFixed(2)}`;
            elements.winDisplay.classList.add('show');
        }

        function hideWin() {
            elements.winDisplay.classList.remove('show');
        }

        // Random Tracking Line
        function triggerTrackingLine() {
            if (Math.random() < 0.1) { // 10% chance
                elements.screenArea.classList.add('tracking-active');
                setTimeout(() => {
                    elements.screenArea.classList.remove('tracking-active');
                }, 2500);
            }
        }

        // Set Degradation Level
        function setDegradation(level) {
            elements.gameContainer.className = '';
            if (state.freeSpins.active) {
                elements.gameContainer.classList.add('free-spins-mode');
            }
            if (level > 0) {
                elements.gameContainer.classList.add(`degradation-${Math.min(level, 5)}`);
            }
        }

        // Spin Animation
        async function spinSymbols(positions = null) {
            const cells = elements.grid.querySelectorAll('.symbol-cell');
            const spinDuration = 800;
            const symbolChangeInterval = 60;

            // Determine which positions to spin
            const positionsToSpin = positions || Array.from({ length: CONFIG.cols * CONFIG.rows }, (_, i) => i);

            // Start spinning animation
            positionsToSpin.forEach(index => {
                cells[index].classList.add('spinning');
                cells[index].classList.remove('frozen', 'new-win');
            });

            // Rapidly change symbols during spin
            const startTime = Date.now();
            while (Date.now() - startTime < spinDuration) {
                positionsToSpin.forEach(index => {
                    const img = cells[index].querySelector('img');
                    const randomSymbol = getRandomSymbol();
                    img.src = `assets/${CONFIG.symbols[randomSymbol].file}`;
                });
                await sleep(symbolChangeInterval);
            }

            // Final symbols
            positionsToSpin.forEach(index => {
                const symbolId = getRandomSymbol();
                state.grid[index] = symbolId;
                const img = cells[index].querySelector('img');
                img.src = `assets/${CONFIG.symbols[symbolId].file}`;
                cells[index].classList.remove('spinning');
            });

            // Restore sticky wilds in free spins
            if (state.freeSpins.active) {
                state.freeSpins.stickyWilds.forEach(pos => {
                    state.grid[pos] = 'wild';
                    const img = cells[pos].querySelector('img');
                    img.src = `assets/${CONFIG.symbols.wild.file}`;
                    cells[pos].classList.add('sticky-wild');
                });
            }

            triggerTrackingLine();
        }

        // Calculate Wins (Scatter Pays)
        function calculateWins() {
            const wins = [];
            const symbolCounts = {};
            const symbolPositions = {};

            // Count symbols and track positions
            state.grid.forEach((symbolId, index) => {
                if (!symbolCounts[symbolId]) {
                    symbolCounts[symbolId] = 0;
                    symbolPositions[symbolId] = [];
                }
                symbolCounts[symbolId]++;
                symbolPositions[symbolId].push(index);
            });

            // Wild substitution - add wilds to each non-scatter symbol count
            const wildCount = symbolCounts['wild'] || 0;
            const wildPositions = symbolPositions['wild'] || [];

            // Check each symbol type for wins
            Object.keys(CONFIG.paytable).forEach(symbolId => {
                const baseCount = symbolCounts[symbolId] || 0;
                const totalCount = baseCount + wildCount;

                if (totalCount >= 8) {
                    const payMultiplier = CONFIG.paytable[symbolId][Math.min(totalCount, 18)] || 0;
                    if (payMultiplier > 0) {
                        wins.push({
                            symbol: symbolId,
                            count: totalCount,
                            positions: [...(symbolPositions[symbolId] || []), ...wildPositions],
                            multiplier: payMultiplier
                        });
                    }
                }
            });

            return wins;
        }

        // Check for Scatter Trigger
        function checkScatterTrigger() {
            let scatterCount = 0;
            const scatterPositions = [];

            state.grid.forEach((symbolId, index) => {
                if (symbolId === 'scatter') {
                    scatterCount++;
                    scatterPositions.push(index);
                }
            });

            if (scatterCount >= 3) {
                return {
                    count: scatterCount,
                    positions: scatterPositions,
                    freeSpins: CONFIG.freeSpinsTrigger[Math.min(scatterCount, 6)]
                };
            }
            return null;
        }

        // Freeze Winning Symbols
        function freezeWinningSymbols(positions) {
            const cells = elements.grid.querySelectorAll('.symbol-cell');
            positions.forEach(pos => {
                cells[pos].classList.add('frozen');
            });
        }

        // Get Non-Frozen Positions
        function getNonFrozenPositions() {
            const cells = elements.grid.querySelectorAll('.symbol-cell');
            const positions = [];
            cells.forEach((cell, index) => {
                if (!cell.classList.contains('frozen') && !cell.classList.contains('sticky-wild')) {
                    positions.push(index);
                }
            });
            return positions;
        }

        // Clear All Frozen States
        function clearFrozenStates() {
            const cells = elements.grid.querySelectorAll('.symbol-cell');
            cells.forEach(cell => {
                cell.classList.remove('frozen', 'new-win', 'scatter-win');
                if (!state.freeSpins.active) {
                    cell.classList.remove('sticky-wild');
                }
            });
        }

        // Win Presentation
        async function presentWin(totalWin, betMultiplier) {
            // AUDIO HOOK: playStaticBurst()

            if (betMultiplier >= 50) {
                // Mega win - silence and black screen
                // AUDIO HOOK: playSilence()
                elements.megaWinAmount.textContent = `$${totalWin.toFixed(2)}`;
                elements.megaWinOverlay.classList.add('show');
                await sleep(3000);
                elements.megaWinOverlay.classList.remove('show');
            } else if (betMultiplier >= 20) {
                // Big win
                elements.gameContainer.classList.add('win-big');
                showWin(totalWin);
                await sleep(1500);
                elements.gameContainer.classList.remove('win-big');
            } else if (betMultiplier >= 5) {
                // Medium win
                elements.gameContainer.classList.add('win-medium');
                showWin(totalWin);
                await sleep(1000);
                elements.gameContainer.classList.remove('win-medium');
            } else {
                // Small win
                elements.gameContainer.classList.add('win-small');
                showWin(totalWin);
                await sleep(600);
                elements.gameContainer.classList.remove('win-small');
            }
        }

        // Free Spins Trigger Animation
        async function triggerFreeSpins(scatterData) {
            // AUDIO HOOK: playEBSTone()

            // Highlight scatters
            const cells = elements.grid.querySelectorAll('.symbol-cell');
            scatterData.positions.forEach(pos => {
                cells[pos].classList.add('scatter-win');
            });

            await sleep(1000);

            // Show PLEASE STAND BY
            elements.overlayText.textContent = 'PLEASE STAND BY';
            elements.overlaySubtext.textContent = `${scatterData.freeSpins} FREE TRANSMISSIONS`;
            elements.overlay.classList.add('show');

            await sleep(2500);

            elements.overlay.classList.remove('show');

            // Initialize free spins state
            state.freeSpins.active = true;
            state.freeSpins.remaining = scatterData.freeSpins;
            state.freeSpins.total = scatterData.freeSpins;
            state.freeSpins.stickyWilds = [];
            state.freeSpins.multiplier = 1;

            elements.gameContainer.classList.add('free-spins-mode');
            updateBroadcastCounter();
        }

        // End Free Spins
        async function endFreeSpins() {
            elements.overlayText.textContent = 'NORMAL SERVICE WILL RESUME';
            elements.overlaySubtext.textContent = '';
            elements.overlay.classList.add('show');

            await sleep(2500);

            elements.overlay.classList.remove('show');

            state.freeSpins.active = false;
            state.freeSpins.stickyWilds = [];
            state.freeSpins.multiplier = 1;

            elements.gameContainer.classList.remove('free-spins-mode');
            elements.broadcastCounter.classList.remove('show');
            elements.multiplierDisplay.classList.remove('show');

            // Clear sticky wild states
            const cells = elements.grid.querySelectorAll('.symbol-cell');
            cells.forEach(cell => cell.classList.remove('sticky-wild'));
        }

        // Update Broadcast Counter
        function updateBroadcastCounter() {
            const current = state.freeSpins.total - state.freeSpins.remaining + 1;
            elements.broadcastCounter.textContent = `BROADCAST ${current} OF ${state.freeSpins.total}`;
            elements.broadcastCounter.classList.add('show');
        }

        // Update Multiplier Display
        function updateMultiplierDisplay() {
            if (state.freeSpins.active && state.freeSpins.multiplier > 1) {
                elements.multiplierDisplay.textContent = `${state.freeSpins.multiplier}X`;
                elements.multiplierDisplay.classList.add('show');
            } else {
                elements.multiplierDisplay.classList.remove('show');
            }
        }

        // Main Spin Function
        async function spin() {
            if (state.spinning) return;

            // Check balance (skip in free spins)
            if (!state.freeSpins.active) {
                if (state.balance < state.bet) {
                    // Not enough balance
                    return;
                }
                state.balance -= state.bet;
                updateBalance();
            }

            state.spinning = true;
            state.totalWin = 0;
            state.respinChain = 0;
            elements.spinBtn.disabled = true;
            hideWin();
            clearFrozenStates();
            setDegradation(0);

            // Update broadcast counter for free spins
            if (state.freeSpins.active) {
                updateBroadcastCounter();
                state.freeSpins.multiplier = 1;
                updateMultiplierDisplay();
            }

            // Initial spin
            await spinSymbols();

            // Check for scatter trigger (only in base game)
            if (!state.freeSpins.active) {
                const scatterData = checkScatterTrigger();
                if (scatterData) {
                    await triggerFreeSpins(scatterData);
                }
            }

            // Check for wilds to make sticky in free spins
            if (state.freeSpins.active) {
                state.grid.forEach((symbolId, index) => {
                    if (symbolId === 'wild' && !state.freeSpins.stickyWilds.includes(index)) {
                        state.freeSpins.stickyWilds.push(index);
                        const cells = elements.grid.querySelectorAll('.symbol-cell');
                        cells[index].classList.add('sticky-wild');
                    }
                });
            }

            // Calculate wins and handle respins
            let wins = calculateWins();
            let allWinningPositions = new Set();

            while (wins.length > 0) {
                state.respinChain++;
                setDegradation(state.respinChain);

                // AUDIO HOOK: playRespinPitch(state.respinChain)

                // Collect all winning positions
                const newPositions = new Set();
                wins.forEach(win => {
                    win.positions.forEach(pos => {
                        if (!allWinningPositions.has(pos)) {
                            newPositions.add(pos);
                        }
                        allWinningPositions.add(pos);
                    });

                    // Calculate win amount
                    let winAmount = win.multiplier * state.bet;
                    if (state.freeSpins.active) {
                        winAmount *= state.freeSpins.multiplier;
                    }
                    state.totalWin += winAmount;
                });

                // Flash new winning positions
                const cells = elements.grid.querySelectorAll('.symbol-cell');
                newPositions.forEach(pos => {
                    cells[pos].classList.add('new-win');
                });

                await sleep(400);

                // Freeze winning symbols
                freezeWinningSymbols(Array.from(allWinningPositions));

                // Get non-frozen positions for respin
                const respinPositions = getNonFrozenPositions();

                if (respinPositions.length === 0) {
                    // Full screen win!
                    break;
                }

                // Increase multiplier during free spins
                if (state.freeSpins.active) {
                    state.freeSpins.multiplier++;
                    updateMultiplierDisplay();
                }

                await sleep(600);

                // Respin non-winning positions
                await spinSymbols(respinPositions);

                // Check for new wilds in free spins
                if (state.freeSpins.active) {
                    respinPositions.forEach(index => {
                        if (state.grid[index] === 'wild' && !state.freeSpins.stickyWilds.includes(index)) {
                            state.freeSpins.stickyWilds.push(index);
                            cells[index].classList.add('sticky-wild');
                        }
                    });
                }

                // Check for new wins
                wins = calculateWins();

                // Filter to only include wins that have new contributing symbols
                wins = wins.filter(win => {
                    return win.positions.some(pos => !allWinningPositions.has(pos) || respinPositions.includes(pos));
                });
            }

            // Present total win
            if (state.totalWin > 0) {
                const betMultiplier = state.totalWin / state.bet;
                state.balance += state.totalWin;
                updateBalance();
                await presentWin(state.totalWin, betMultiplier);
            }

            // Clear states after win presentation
            await sleep(300);
            clearFrozenStates();
            setDegradation(0);

            // Handle free spins
            if (state.freeSpins.active) {
                state.freeSpins.remaining--;

                // Re-apply sticky wild visuals
                const cells = elements.grid.querySelectorAll('.symbol-cell');
                state.freeSpins.stickyWilds.forEach(pos => {
                    cells[pos].classList.add('sticky-wild');
                });

                if (state.freeSpins.remaining <= 0) {
                    await endFreeSpins();
                }
            }

            state.spinning = false;
            elements.spinBtn.disabled = false;

            // Auto-play
            if (state.autoPlay && !state.freeSpins.active && state.balance >= state.bet) {
                setTimeout(() => spin(), 1000);
            } else if (state.freeSpins.active && state.freeSpins.remaining > 0) {
                setTimeout(() => spin(), 800);
            }
        }

        // Event Listeners
        elements.spinBtn.addEventListener('click', spin);

        elements.autoBtn.addEventListener('click', () => {
            state.autoPlay = !state.autoPlay;
            elements.autoBtn.classList.toggle('active', state.autoPlay);
            if (state.autoPlay && !state.spinning) {
                spin();
            }
        });

        elements.betSelect.addEventListener('change', (e) => {
            state.bet = parseFloat(e.target.value);
        });

        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !state.spinning) {
                e.preventDefault();
                spin();
            }
        });

        // Initialize
        initGrid();
        updateBalance();

        // Random ambient effects
        setInterval(() => {
            if (Math.random() < 0.05) {
                triggerTrackingLine();
            }
        }, 5000);

        console.log('CHANNEL 3 initialized. Do not adjust your set.');
        console.log('Press SPACE or click TRANSMIT to spin.');
    </script>
</body>
</html>
