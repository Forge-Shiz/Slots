<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CHANNEL 3 — Do Not Adjust Your Set</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --crt-green: #33ff33;
            --crt-amber: #ffaa00;
            --static-dark: #080808;
            --scan-opacity: 0.06;
            --vhs-blue: #0066cc;
            --dread-red: #990000;
            --cold-blue: #4488aa;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            background: #000;
            min-height: 100vh;
            height: 100%;
            font-family: 'VT323', monospace;
            overflow: hidden;
            color: #ccc;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Main game container */
        #game-container {
            position: relative;
            width: 95vw;
            height: 95vw;
            max-width: 98vh;
            max-height: 98vh;
        }

        /* TV Bezel - contains both the image AND the screen area as children */
        #tv-bezel {
            position: absolute;
            top: 50%;
            left: 50%;
            /* Scale larger to zoom in - TV fills viewport, edges bleed off */
            width: 130%;
            height: 130%;
            transform: translate(-50%, -50%);
            background-image: url('assets/bck.webp');
            background-size: 100% 100%;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* Screen area - positioned INSIDE tv-bezel using image coordinates */
        #screen-area {
            position: absolute;
            /* Expanded to fill more of the TV screen area */
            top: 34%;
            left: 22%;
            width: 45%;
            height: 33%;
            border-radius: 0.5%;
        }

        /* Dark static background */
        #static-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--static-dark);
            z-index: 1;
        }

        /* Animated static noise */
        #static-noise {
            position: absolute;
            top: -10%;
            left: -10%;
            width: 120%;
            height: 120%;
            z-index: 2;
            opacity: 0.12;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            animation: staticShift 0.08s steps(4) infinite;
        }

        @keyframes staticShift {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-3%, 2%); }
            50% { transform: translate(2%, -3%); }
            75% { transform: translate(-2%, 3%); }
            100% { transform: translate(3%, -2%); }
        }

        /* Symbol grid - constrained to fit within screen area */
        #symbol-grid {
            position: relative;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 2px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.3); /* Subtle grid lines show through 2px gaps */
        }

        .symbol-cell {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background: var(--static-dark);
            min-width: 0;
            min-height: 0;
        }

        .symbol-cell img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: auto;
        }

        /* ===========================================
           WINNING SYMBOL GLOW - Flickering teal/cyan
           =========================================== */
        .symbol-cell.winning {
            animation: winningGlow 0.3s ease-in-out infinite alternate;
        }

        @keyframes winningGlow {
            0% {
                box-shadow: 0 0 8px 2px rgba(0, 255, 255, 0.4),
                            inset 0 0 4px rgba(0, 255, 255, 0.2);
            }
            100% {
                box-shadow: 0 0 12px 4px rgba(0, 255, 255, 0.8),
                            inset 0 0 6px rgba(0, 255, 255, 0.4);
            }
        }

        /* ===========================================
           FROZEN SYMBOL EFFECT - VHS PAUSE + steady glow
           =========================================== */
        .symbol-cell.frozen {
            animation: vhsJitter 0.12s steps(3) infinite, frozenGlow 1s ease-in-out infinite alternate;
            box-shadow: 0 0 10px 3px rgba(100, 180, 255, 0.6),
                        inset 0 0 5px rgba(100, 180, 255, 0.3);
        }

        @keyframes frozenGlow {
            0% {
                box-shadow: 0 0 8px 2px rgba(100, 180, 255, 0.5),
                            inset 0 0 4px rgba(100, 180, 255, 0.25);
            }
            100% {
                box-shadow: 0 0 12px 4px rgba(100, 180, 255, 0.7),
                            inset 0 0 6px rgba(100, 180, 255, 0.35);
            }
        }

        .symbol-cell.frozen::before {
            content: '▮▮';
            position: absolute;
            top: 2px;
            right: 3px;
            font-size: 0.5em;
            color: rgba(255, 255, 255, 0.6);
            z-index: 25;
            text-shadow: 1px 0 #ff0000, -1px 0 #00ffff;
            font-family: 'VT323', monospace;
        }

        .symbol-cell.frozen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 2px,
                rgba(0, 0, 0, 0.12) 2px,
                rgba(0, 0, 0, 0.12) 4px
            );
            z-index: 20;
            pointer-events: none;
        }

        .symbol-cell.frozen img {
            filter: brightness(0.85) saturate(0.9) contrast(1.1);
            animation: rgbSplit 0.2s steps(3) infinite;
        }

        @keyframes vhsJitter {
            0% { transform: translateX(0); }
            33% { transform: translateX(-2px); }
            66% { transform: translateX(2px); }
            100% { transform: translateX(0); }
        }

        @keyframes rgbSplit {
            0% {
                filter: brightness(0.85) saturate(0.9) contrast(1.1);
            }
            33% {
                filter: brightness(0.85) saturate(0.9) contrast(1.1)
                       drop-shadow(-3px 0 rgba(255, 0, 0, 0.6))
                       drop-shadow(3px 0 rgba(0, 255, 255, 0.6));
            }
            66% {
                filter: brightness(0.8) saturate(0.85) contrast(1.1)
                       drop-shadow(2px 0 rgba(255, 0, 0, 0.4))
                       drop-shadow(-2px 0 rgba(0, 255, 255, 0.4));
            }
            100% {
                filter: brightness(0.85) saturate(0.9) contrast(1.1);
            }
        }

        /* ===========================================
           SPINNING/CHANNEL SURFING EFFECT
           =========================================== */
        .symbol-cell.spinning img {
            animation: channelSurf 0.06s steps(1) infinite;
            filter: brightness(1.1) contrast(0.9);
        }

        @keyframes channelSurf {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        /* Scan lines overlay */
        #scan-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 2px,
                rgba(0, 0, 0, var(--scan-opacity)) 2px,
                rgba(0, 0, 0, var(--scan-opacity)) 4px
            );
            z-index: 50;
            pointer-events: none;
        }

        /* CRT flicker effect */
        #crt-flicker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.02);
            z-index: 51;
            pointer-events: none;
            opacity: 0;
            animation: crtFlicker 6s ease-in-out infinite;
        }

        @keyframes crtFlicker {
            0%, 94%, 100% { opacity: 0; }
            95% { opacity: 1; }
            96% { opacity: 0; }
            97% { opacity: 0.5; }
            98% { opacity: 0; }
        }

        /* VHS tracking line */
        #tracking-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 10px;
            background: linear-gradient(
                180deg,
                transparent 0%,
                rgba(255, 255, 255, 0.08) 20%,
                rgba(255, 255, 255, 0.2) 50%,
                rgba(255, 255, 255, 0.08) 80%,
                transparent 100%
            );
            z-index: 52;
            pointer-events: none;
            opacity: 0;
            top: -20px;
        }

        #screen-area.tracking-active #tracking-line {
            animation: trackingRoll 2.5s linear forwards;
        }

        @keyframes trackingRoll {
            0% { top: -20px; opacity: 0.7; }
            100% { top: 110%; opacity: 0.2; }
        }

        /* CRT curvature/vignette effect */
        #screen-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 65%,
                rgba(0, 0, 0, 0.35) 100%
            );
            z-index: 60;
            pointer-events: none;
            border-radius: inherit;
        }

        /* ===========================================
           UI CONTROLS - Positioned on game-container
           =========================================== */
        #ui-container {
            position: absolute;
            bottom: 3%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        #controls-row {
            display: flex;
            gap: 12px;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 10px 20px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ui-button {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.25);
            color: #aaa;
            font-family: 'VT323', monospace;
            font-size: 1.2em;
            padding: 8px 18px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.15s;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
        }

        .ui-button:hover {
            color: #fff;
            border-color: rgba(255, 255, 255, 0.5);
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.4);
            background: rgba(0, 0, 0, 0.7);
        }

        .ui-button:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .ui-button.active {
            color: var(--crt-amber);
            border-color: var(--crt-amber);
            text-shadow: 0 0 10px var(--crt-amber);
        }

        #spin-btn {
            font-size: 1.5em;
            padding: 10px 35px;
            border-width: 2px;
        }

        #bet-selector {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #bet-selector label {
            color: #666;
            font-size: 1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #bet-select {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.25);
            color: #aaa;
            font-family: 'VT323', monospace;
            font-size: 1.1em;
            padding: 6px 10px;
            cursor: pointer;
        }

        #bet-select option {
            background: #111;
            color: #aaa;
        }

        /* Info displays - channel watermark style */
        #info-display {
            position: absolute;
            top: 4%;
            right: 4%;
            z-index: 200;
            text-align: right;
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.75);
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.95), 0 0 10px rgba(0,0,0,0.5);
        }

        #balance-display, #win-display {
            margin-bottom: 4px;
        }

        #win-display {
            color: rgba(255, 255, 255, 0);
            transition: color 0.3s;
        }

        #win-display.show {
            color: rgba(255, 255, 255, 0.95);
        }

        /* Channel indicator */
        #channel-indicator {
            position: absolute;
            top: 4%;
            left: 4%;
            z-index: 200;
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.5em;
            color: rgba(255, 255, 255, 0.65);
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.95);
        }

        #channel-indicator::before {
            content: 'CH';
            font-size: 0.6em;
            margin-right: 4px;
            opacity: 0.7;
        }

        /* Free spins broadcast counter */
        #broadcast-counter {
            position: absolute;
            top: 4%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            font-family: 'VT323', monospace;
            font-size: 1.4em;
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.95);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #broadcast-counter.show {
            opacity: 1;
        }

        /* Multiplier display */
        #multiplier-display {
            position: absolute;
            bottom: 16%;
            right: 4%;
            z-index: 200;
            font-family: 'VT323', monospace;
            font-size: 2.2em;
            color: var(--crt-amber);
            text-shadow: 0 0 15px var(--crt-amber), 2px 2px 6px rgba(0, 0, 0, 0.95);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #multiplier-display.show {
            opacity: 1;
        }

        /* Respin indicator */
        #respin-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            font-family: 'VT323', monospace;
            font-size: 2em;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 25px rgba(255, 255, 255, 0.6), 3px 3px 8px rgba(0, 0, 0, 0.95);
            opacity: 0;
            transition: opacity 0.2s;
            letter-spacing: 6px;
        }

        #respin-indicator.show {
            opacity: 1;
        }

        /* PLEASE STAND BY overlay */
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 300;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: #000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #overlay-screen.show {
            opacity: 1;
            pointer-events: all;
        }

        #overlay-text {
            font-family: 'VT323', monospace;
            font-size: 3em;
            color: #fff;
            text-align: center;
            letter-spacing: 6px;
            text-shadow:
                0 0 20px rgba(255, 255, 255, 0.8),
                0 0 40px rgba(255, 255, 255, 0.4),
                0 0 60px rgba(255, 255, 255, 0.2);
            animation: overlayFlicker 0.1s steps(2) infinite;
        }

        @keyframes overlayFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.92; }
        }

        #overlay-subtext {
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 20px;
            letter-spacing: 3px;
        }

        /* Free spins mode - cold filter */
        .free-spins-mode #screen-area {
            filter: hue-rotate(-15deg) saturate(0.85) brightness(0.92);
        }

        .free-spins-mode #scan-lines {
            --scan-opacity: 0.12;
        }

        .free-spins-mode #static-noise {
            opacity: 0.2;
        }

        /* Win presentation styles */
        .win-small #screen-area {
            animation: staticBurst 0.25s ease-out;
        }

        .win-medium #screen-area {
            animation: mediumDistort 0.5s ease-out;
        }

        .win-big #screen-area {
            animation: bigDistort 0.7s ease-out;
        }

        @keyframes staticBurst {
            0% { filter: brightness(1.3) contrast(1.15); }
            100% { filter: brightness(1) contrast(1); }
        }

        @keyframes mediumDistort {
            0% { transform: translateX(0); filter: hue-rotate(0deg); }
            20% { transform: translateX(-4px); filter: hue-rotate(15deg); }
            40% { transform: translateX(4px); filter: hue-rotate(-15deg); }
            60% { transform: translateX(-2px); filter: hue-rotate(8deg); }
            80% { transform: translateX(2px); filter: hue-rotate(-5deg); }
            100% { transform: translateX(0); filter: hue-rotate(0deg); }
        }

        @keyframes bigDistort {
            0% { transform: scale(1); filter: brightness(1) saturate(1); }
            15% { transform: scale(1.03); filter: brightness(1.4) saturate(1.6) hue-rotate(25deg); }
            30% { transform: scale(0.97); filter: brightness(0.7) saturate(0.4) hue-rotate(-25deg); }
            50% { transform: scale(1.02); filter: brightness(1.3) saturate(1.4); }
            70% { transform: scale(0.98); filter: brightness(0.85) saturate(0.7); }
            100% { transform: scale(1); filter: brightness(1) saturate(1); }
        }

        /* Mega win - full static */
        #mega-win-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 250;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        #mega-win-overlay.show {
            opacity: 1;
        }

        #mega-win-amount {
            font-family: 'VT323', monospace;
            font-size: 5em;
            color: #fff;
            letter-spacing: 6px;
        }

        /* Degradation levels during respins */
        .degradation-1 { --scan-opacity: 0.08; }
        .degradation-2 { --scan-opacity: 0.11; }
        .degradation-3 { --scan-opacity: 0.14; }
        .degradation-4 { --scan-opacity: 0.18; }
        .degradation-5 { --scan-opacity: 0.23; }

        .degradation-1 #static-noise { opacity: 0.15; }
        .degradation-2 #static-noise { opacity: 0.20; }
        .degradation-3 #static-noise { opacity: 0.28; }
        .degradation-4 #static-noise { opacity: 0.38; }
        .degradation-5 #static-noise { opacity: 0.50; }

        .degradation-3 #screen-area,
        .degradation-4 #screen-area,
        .degradation-5 #screen-area {
            filter: hue-rotate(-12deg) saturate(0.88);
        }

        /* Wild sticky glow during free spins */
        .symbol-cell.sticky-wild img {
            filter: brightness(1.25) drop-shadow(0 0 10px var(--cold-blue));
            animation: wildPulse 1.2s ease-in-out infinite;
        }

        @keyframes wildPulse {
            0%, 100% { filter: brightness(1.25) drop-shadow(0 0 10px var(--cold-blue)); }
            50% { filter: brightness(1.45) drop-shadow(0 0 18px var(--cold-blue)); }
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            #game-container {
                width: 100vw;
                height: 100vw;
                max-width: 100vh;
                max-height: 100vh;
            }

            #tv-bezel {
                width: 145%;
                height: 145%;
            }

            #ui-container {
                bottom: 1%;
            }

            .ui-button {
                font-size: 1em;
                padding: 6px 12px;
            }

            #spin-btn {
                font-size: 1.2em;
                padding: 8px 20px;
            }

            #info-display, #channel-indicator {
                font-size: 1em;
            }

            #overlay-text {
                font-size: 2em;
                letter-spacing: 3px;
            }

            #controls-row {
                padding: 8px 12px;
                gap: 8px;
            }
        }

        /* New winning symbols highlight */
        .symbol-cell.new-win img {
            animation: newWinPop 0.4s ease-out;
        }

        @keyframes newWinPop {
            0% { filter: brightness(2.5) saturate(0); transform: scale(1.1); }
            100% { filter: brightness(1) saturate(1); transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- TV Bezel contains the screen area - they scale together -->
        <div id="tv-bezel">
            <div id="screen-area">
                <div id="static-bg"></div>
                <div id="static-noise"></div>
                <div id="symbol-grid"></div>
                <div id="scan-lines"></div>
                <div id="crt-flicker"></div>
                <div id="tracking-line"></div>
            </div>
        </div>

        <!-- Overlays - positioned on game-container -->
        <div id="overlay-screen">
            <div id="overlay-text">PLEASE STAND BY</div>
            <div id="overlay-subtext"></div>
        </div>

        <div id="mega-win-overlay">
            <div id="mega-win-amount"></div>
        </div>

        <!-- UI Elements - positioned on game-container -->
        <div id="channel-indicator">3</div>

        <div id="info-display">
            <div id="balance-display">CREDIT $1000.00</div>
            <div id="win-display">WIN $0.00</div>
        </div>

        <div id="broadcast-counter"></div>
        <div id="multiplier-display"></div>
        <div id="respin-indicator">RESPIN</div>

        <div id="ui-container">
            <div id="controls-row">
                <div id="bet-selector">
                    <label>BET</label>
                    <select id="bet-select">
                        <option value="0.20">$0.20</option>
                        <option value="0.40">$0.40</option>
                        <option value="1.00" selected>$1.00</option>
                        <option value="2.00">$2.00</option>
                        <option value="5.00">$5.00</option>
                        <option value="10.00">$10.00</option>
                    </select>
                </div>
                <button id="spin-btn" class="ui-button">TRANSMIT</button>
                <button id="auto-btn" class="ui-button">AUTO</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // CHANNEL 3 - Analog Horror Slot Game
        // STICKY WIN RESPINS MECHANIC
        // ========================================

        // AUDIO HOOKS (to be implemented later)
        // - playAmbientHum(): CRT ambient hum loop
        // - playTapeHiss(): VHS tape hiss
        // - playStaticBurst(): Static burst on wins
        // - playEBSTone(): Detuned EBS tone for free spins
        // - playRespinPitch(level): Increasing pitch during chains
        // - playSilence(): Cut all audio for mega wins

        const CONFIG = {
            cols: 6,
            rows: 5,
            symbols: {
                h1: { id: 'h1', name: 'The Puppet', file: 'sym_h1_puppet.webp', weight: 8 },
                h2: { id: 'h2', name: 'The Host', file: 'sym_h2_host.webp', weight: 10 },
                h3: { id: 'h3', name: 'The Signal', file: 'sym_h3_signal.webp', weight: 12 },
                h4: { id: 'h4', name: 'The Test Pattern', file: 'sym_h4_testpattern.webp', weight: 14 },
                l1: { id: 'l1', name: 'VHS Tape', file: 'sym_l1_vhs.webp', weight: 18 },
                l2: { id: 'l2', name: 'Rotary Phone', file: 'sym_l2_phone.webp', weight: 20 },
                l3: { id: 'l3', name: 'TV Dinner', file: 'sym_l3_tvdinner.webp', weight: 22 },
                l4: { id: 'l4', name: 'Rabbit Ears', file: 'sym_l4_antenna.webp', weight: 24 },
                wild: { id: 'wild', name: 'Static', file: 'sym_wild_static.webp', weight: 5, isWild: true },
                scatter: { id: 'scatter', name: 'Emergency Broadcast', file: 'sym_scatter_ebs.webp', weight: 6, isScatter: true }
            },
            paytable: {
                h1: { 8: 5, 9: 8, 10: 12, 11: 18, 12: 25, 13: 35, 14: 50, 15: 75, 16: 100, 17: 150, 18: 200 },
                h2: { 8: 4, 9: 6, 10: 10, 11: 15, 12: 20, 13: 28, 14: 40, 15: 60, 16: 80, 17: 120, 18: 160 },
                h3: { 8: 3, 9: 5, 10: 8, 11: 12, 12: 16, 13: 22, 14: 32, 15: 48, 16: 64, 17: 96, 18: 128 },
                h4: { 8: 2.5, 9: 4, 10: 6, 11: 10, 12: 14, 13: 18, 14: 26, 15: 40, 16: 54, 17: 80, 18: 108 },
                l1: { 8: 2, 9: 3, 10: 5, 11: 8, 12: 11, 13: 15, 14: 22, 15: 32, 16: 44, 17: 64, 18: 88 },
                l2: { 8: 1.5, 9: 2.5, 10: 4, 11: 6, 12: 9, 13: 12, 14: 18, 15: 26, 16: 36, 17: 52, 18: 72 },
                l3: { 8: 1, 9: 2, 10: 3, 11: 5, 12: 7, 13: 10, 14: 14, 15: 20, 16: 28, 17: 40, 18: 56 },
                l4: { 8: 0.8, 9: 1.5, 10: 2.5, 11: 4, 12: 6, 13: 8, 14: 12, 15: 16, 16: 22, 17: 32, 18: 44 }
            },
            freeSpinsTrigger: { 3: 8, 4: 12, 5: 16, 6: 20 }
        };

        let state = {
            balance: 1000.00,
            bet: 1.00,
            grid: [],
            spinning: false,
            autoPlay: false,
            freeSpins: {
                active: false,
                remaining: 0,
                total: 0,
                stickyWilds: [],
                multiplier: 1
            },
            frozenPositions: new Set(),
            respinCount: 0,
            totalWin: 0
        };

        const elements = {
            grid: document.getElementById('symbol-grid'),
            spinBtn: document.getElementById('spin-btn'),
            autoBtn: document.getElementById('auto-btn'),
            betSelect: document.getElementById('bet-select'),
            balanceDisplay: document.getElementById('balance-display'),
            winDisplay: document.getElementById('win-display'),
            overlay: document.getElementById('overlay-screen'),
            overlayText: document.getElementById('overlay-text'),
            overlaySubtext: document.getElementById('overlay-subtext'),
            megaWinOverlay: document.getElementById('mega-win-overlay'),
            megaWinAmount: document.getElementById('mega-win-amount'),
            broadcastCounter: document.getElementById('broadcast-counter'),
            multiplierDisplay: document.getElementById('multiplier-display'),
            respinIndicator: document.getElementById('respin-indicator'),
            gameContainer: document.getElementById('game-container'),
            screenArea: document.getElementById('screen-area')
        };

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getRandomSymbol() {
            const symbolKeys = Object.keys(CONFIG.symbols);
            let totalWeight = 0;
            const weights = symbolKeys.map(k => {
                totalWeight += CONFIG.symbols[k].weight;
                return { key: k, weight: CONFIG.symbols[k].weight };
            });

            let random = Math.random() * totalWeight;
            for (const item of weights) {
                random -= item.weight;
                if (random <= 0) return item.key;
            }
            return weights[weights.length - 1].key;
        }

        function initGrid() {
            elements.grid.innerHTML = '';
            state.grid = [];

            for (let i = 0; i < CONFIG.rows * CONFIG.cols; i++) {
                const cell = document.createElement('div');
                cell.className = 'symbol-cell';
                cell.dataset.index = i;

                const img = document.createElement('img');
                const symbolId = getRandomSymbol();
                state.grid.push(symbolId);
                img.src = `assets/${CONFIG.symbols[symbolId].file}`;
                img.alt = CONFIG.symbols[symbolId].name;

                cell.appendChild(img);
                elements.grid.appendChild(cell);
            }
        }

        function updateBalance() {
            elements.balanceDisplay.textContent = `CREDIT $${state.balance.toFixed(2)}`;
        }

        function showWin(amount) {
            elements.winDisplay.textContent = `WIN $${amount.toFixed(2)}`;
            elements.winDisplay.classList.add('show');
        }

        function hideWin() {
            elements.winDisplay.classList.remove('show');
        }

        function showRespinIndicator() {
            elements.respinIndicator.classList.add('show');
        }

        function hideRespinIndicator() {
            elements.respinIndicator.classList.remove('show');
        }

        function triggerTrackingLine() {
            if (Math.random() < 0.15) {
                elements.screenArea.classList.add('tracking-active');
                setTimeout(() => {
                    elements.screenArea.classList.remove('tracking-active');
                }, 2800);
            }
        }

        function setDegradation(level) {
            for (let i = 1; i <= 5; i++) {
                elements.gameContainer.classList.remove(`degradation-${i}`);
            }
            if (state.freeSpins.active) {
                elements.gameContainer.classList.add('free-spins-mode');
            }
            if (level > 0) {
                elements.gameContainer.classList.add(`degradation-${Math.min(level, 5)}`);
            }
        }

        async function spinPositions(positions) {
            const cells = elements.grid.children;
            const spinDuration = 700;
            const cycleInterval = 50;

            positions.forEach(index => {
                cells[index].classList.add('spinning');
                cells[index].classList.remove('frozen', 'new-win', 'winning');
            });

            const startTime = Date.now();
            while (Date.now() - startTime < spinDuration) {
                positions.forEach(index => {
                    const img = cells[index].querySelector('img');
                    const randomSymbol = getRandomSymbol();
                    img.src = `assets/${CONFIG.symbols[randomSymbol].file}`;
                });
                await sleep(cycleInterval);
            }

            positions.forEach(index => {
                const finalSymbol = getRandomSymbol();
                state.grid[index] = finalSymbol;
                const img = cells[index].querySelector('img');
                img.src = `assets/${CONFIG.symbols[finalSymbol].file}`;
                cells[index].classList.remove('spinning');
            });

            if (state.freeSpins.active) {
                state.freeSpins.stickyWilds.forEach(pos => {
                    if (positions.includes(pos)) {
                        state.grid[pos] = 'wild';
                        const img = cells[pos].querySelector('img');
                        img.src = `assets/${CONFIG.symbols.wild.file}`;
                        cells[pos].classList.add('sticky-wild');
                    }
                });
            }

            triggerTrackingLine();
        }

        function calculateWins() {
            const wins = [];
            const symbolCounts = {};
            const symbolPositions = {};

            state.grid.forEach((symbolId, index) => {
                if (!symbolCounts[symbolId]) {
                    symbolCounts[symbolId] = 0;
                    symbolPositions[symbolId] = [];
                }
                symbolCounts[symbolId]++;
                symbolPositions[symbolId].push(index);
            });

            const wildCount = symbolCounts['wild'] || 0;
            const wildPositions = symbolPositions['wild'] || [];

            Object.keys(CONFIG.paytable).forEach(symbolId => {
                const baseCount = symbolCounts[symbolId] || 0;
                const totalCount = baseCount + wildCount;

                if (totalCount >= 8) {
                    const payMultiplier = CONFIG.paytable[symbolId][Math.min(totalCount, 18)] || 0;
                    if (payMultiplier > 0) {
                        const positions = [...(symbolPositions[symbolId] || []), ...wildPositions];
                        wins.push({
                            symbol: symbolId,
                            count: totalCount,
                            positions: positions,
                            multiplier: payMultiplier
                        });
                    }
                }
            });

            return wins;
        }

        function getWinningPositions(wins) {
            const positions = new Set();
            wins.forEach(win => {
                win.positions.forEach(pos => positions.add(pos));
            });
            return positions;
        }

        function checkScatterTrigger() {
            let count = 0;
            const positions = [];

            state.grid.forEach((symbolId, index) => {
                if (symbolId === 'scatter') {
                    count++;
                    positions.push(index);
                }
            });

            if (count >= 3) {
                return {
                    count,
                    positions,
                    freeSpins: CONFIG.freeSpinsTrigger[Math.min(count, 6)]
                };
            }
            return null;
        }

        function freezePositions(positions) {
            const cells = elements.grid.children;
            positions.forEach(pos => {
                cells[pos].classList.remove('winning'); // Remove flickering glow
                cells[pos].classList.add('frozen'); // Add steady frozen glow
                state.frozenPositions.add(pos);
            });
        }

        function highlightNewWins(positions) {
            const cells = elements.grid.children;
            positions.forEach(pos => {
                cells[pos].classList.add('new-win', 'winning');
            });
        }

        function highlightWinningSymbols(positions) {
            const cells = elements.grid.children;
            positions.forEach(pos => {
                cells[pos].classList.add('winning');
            });
        }

        function getNonFrozenPositions() {
            const positions = [];
            for (let i = 0; i < CONFIG.rows * CONFIG.cols; i++) {
                if (!state.frozenPositions.has(i)) {
                    if (state.freeSpins.active && state.freeSpins.stickyWilds.includes(i)) {
                        continue;
                    }
                    positions.push(i);
                }
            }
            return positions;
        }

        function clearAllStates() {
            const cells = elements.grid.children;
            for (let i = 0; i < cells.length; i++) {
                cells[i].classList.remove('frozen', 'new-win', 'spinning', 'winning');
                if (!state.freeSpins.active) {
                    cells[i].classList.remove('sticky-wild');
                }
            }
            state.frozenPositions.clear();
        }

        async function presentWin(totalWin, betMultiplier) {
            if (betMultiplier >= 50) {
                elements.megaWinAmount.textContent = `$${totalWin.toFixed(2)}`;
                elements.megaWinOverlay.classList.add('show');
                await sleep(3000);
                elements.megaWinOverlay.classList.remove('show');
            } else if (betMultiplier >= 20) {
                elements.gameContainer.classList.add('win-big');
                showWin(totalWin);
                await sleep(1500);
                elements.gameContainer.classList.remove('win-big');
            } else if (betMultiplier >= 5) {
                elements.gameContainer.classList.add('win-medium');
                showWin(totalWin);
                await sleep(1000);
                elements.gameContainer.classList.remove('win-medium');
            } else {
                elements.gameContainer.classList.add('win-small');
                showWin(totalWin);
                await sleep(600);
                elements.gameContainer.classList.remove('win-small');
            }
        }

        async function triggerFreeSpins(scatterData) {
            const cells = elements.grid.children;
            scatterData.positions.forEach(pos => {
                cells[pos].classList.add('new-win');
            });

            await sleep(1200);

            elements.overlayText.textContent = 'PLEASE STAND BY';
            elements.overlaySubtext.textContent = `${scatterData.freeSpins} FREE TRANSMISSIONS`;
            elements.overlay.classList.add('show');

            await sleep(2500);
            elements.overlay.classList.remove('show');

            state.freeSpins.active = true;
            state.freeSpins.remaining = scatterData.freeSpins;
            state.freeSpins.total = scatterData.freeSpins;
            state.freeSpins.stickyWilds = [];
            state.freeSpins.multiplier = 1;

            elements.gameContainer.classList.add('free-spins-mode');
            updateBroadcastCounter();
        }

        async function endFreeSpins() {
            elements.overlayText.textContent = 'NORMAL SERVICE WILL RESUME';
            elements.overlaySubtext.textContent = '';
            elements.overlay.classList.add('show');

            await sleep(2500);
            elements.overlay.classList.remove('show');

            state.freeSpins.active = false;
            state.freeSpins.stickyWilds = [];
            state.freeSpins.multiplier = 1;

            elements.gameContainer.classList.remove('free-spins-mode');
            elements.broadcastCounter.classList.remove('show');
            elements.multiplierDisplay.classList.remove('show');

            const cells = elements.grid.children;
            for (let i = 0; i < cells.length; i++) {
                cells[i].classList.remove('sticky-wild');
            }
        }

        function updateBroadcastCounter() {
            const current = state.freeSpins.total - state.freeSpins.remaining + 1;
            elements.broadcastCounter.textContent = `BROADCAST ${current} OF ${state.freeSpins.total}`;
            elements.broadcastCounter.classList.add('show');
        }

        function updateMultiplierDisplay() {
            if (state.freeSpins.active && state.freeSpins.multiplier > 1) {
                elements.multiplierDisplay.textContent = `${state.freeSpins.multiplier}X`;
                elements.multiplierDisplay.classList.add('show');
            } else {
                elements.multiplierDisplay.classList.remove('show');
            }
        }

        function checkForStickyWilds() {
            if (!state.freeSpins.active) return;

            const cells = elements.grid.children;
            state.grid.forEach((symbolId, index) => {
                if (symbolId === 'wild' && !state.freeSpins.stickyWilds.includes(index)) {
                    state.freeSpins.stickyWilds.push(index);
                    cells[index].classList.add('sticky-wild');
                }
            });
        }

        async function spin() {
            if (state.spinning) return;

            if (!state.freeSpins.active) {
                if (state.balance < state.bet) return;
                state.balance -= state.bet;
                updateBalance();
            }

            state.spinning = true;
            state.totalWin = 0;
            state.respinCount = 0;
            state.frozenPositions.clear();
            elements.spinBtn.disabled = true;
            hideWin();
            hideRespinIndicator();
            clearAllStates();
            setDegradation(0);

            if (state.freeSpins.active) {
                updateBroadcastCounter();
                state.freeSpins.multiplier = 1;
                updateMultiplierDisplay();
            }

            const allPositions = Array.from({ length: CONFIG.rows * CONFIG.cols }, (_, i) => i);
            await spinPositions(allPositions);

            if (!state.freeSpins.active) {
                const scatterData = checkScatterTrigger();
                if (scatterData) {
                    await triggerFreeSpins(scatterData);
                }
            }

            checkForStickyWilds();

            let wins = calculateWins();

            while (wins.length > 0) {
                state.respinCount++;
                setDegradation(state.respinCount);

                const winningPositions = getWinningPositions(wins);

                const newWinningPositions = [];
                winningPositions.forEach(pos => {
                    if (!state.frozenPositions.has(pos)) {
                        newWinningPositions.push(pos);
                    }
                });

                if (newWinningPositions.length === 0) {
                    break;
                }

                wins.forEach(win => {
                    let winAmount = win.multiplier * state.bet;
                    if (state.freeSpins.active) {
                        winAmount *= state.freeSpins.multiplier;
                    }
                    state.totalWin += winAmount;
                });

                highlightNewWins(newWinningPositions);
                await sleep(400);

                freezePositions(Array.from(winningPositions));

                const respinPositions = getNonFrozenPositions();

                if (respinPositions.length === 0) {
                    break;
                }

                if (state.freeSpins.active) {
                    state.freeSpins.multiplier++;
                    updateMultiplierDisplay();
                }

                await sleep(500);

                showRespinIndicator();
                await sleep(300);

                await spinPositions(respinPositions);

                hideRespinIndicator();

                checkForStickyWilds();

                wins = calculateWins();

                const newWinningCheck = getWinningPositions(wins);
                let hasNewWins = false;
                newWinningCheck.forEach(pos => {
                    if (!state.frozenPositions.has(pos)) {
                        hasNewWins = true;
                    }
                });

                if (!hasNewWins) {
                    wins = [];
                }
            }

            if (state.totalWin > 0) {
                const betMultiplier = state.totalWin / state.bet;
                state.balance += state.totalWin;
                updateBalance();
                await presentWin(state.totalWin, betMultiplier);
            }

            await sleep(300);
            clearAllStates();
            setDegradation(0);

            if (state.freeSpins.active) {
                const cells = elements.grid.children;
                state.freeSpins.stickyWilds.forEach(pos => {
                    cells[pos].classList.add('sticky-wild');
                });
            }

            if (state.freeSpins.active) {
                state.freeSpins.remaining--;
                if (state.freeSpins.remaining <= 0) {
                    await endFreeSpins();
                }
            }

            state.spinning = false;
            elements.spinBtn.disabled = false;

            if (state.autoPlay && !state.freeSpins.active && state.balance >= state.bet) {
                setTimeout(() => spin(), 1000);
            } else if (state.freeSpins.active && state.freeSpins.remaining > 0) {
                setTimeout(() => spin(), 700);
            }
        }

        elements.spinBtn.addEventListener('click', spin);

        elements.autoBtn.addEventListener('click', () => {
            state.autoPlay = !state.autoPlay;
            elements.autoBtn.classList.toggle('active', state.autoPlay);
            if (state.autoPlay && !state.spinning) {
                spin();
            }
        });

        elements.betSelect.addEventListener('change', (e) => {
            state.bet = parseFloat(e.target.value);
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !state.spinning) {
                e.preventDefault();
                spin();
            }
        });

        initGrid();
        updateBalance();

        setInterval(() => {
            if (Math.random() < 0.04 && !state.spinning) {
                triggerTrackingLine();
            }
        }, 6000);

        console.log('CHANNEL 3 initialized. Do not adjust your set.');
        console.log('Press SPACE or click TRANSMIT to spin.');
    </script>
</body>
</html>
