<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>3AM BODEGA</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a0f;font-family:'VT323',monospace}
#game-container{position:relative;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:url('assets/bg_main.webp') center/cover no-repeat}

/* INTRO VIDEO OVERLAY */
#intro-overlay{
  position:absolute;inset:0;
  background:#000;
  z-index:2000;
  display:flex;align-items:center;justify-content:center;
  overflow:hidden;
}
#intro-overlay.hidden{display:none}
#intro-video{
  width:100%;height:100%;
  object-fit:cover;
}

/* VHS Static/Noise Layer */
#intro-static{
  position:absolute;inset:0;
  background:url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="200" height="200" filter="url(%23n)"/></svg>');
  background-size:200px;
  opacity:0;
  pointer-events:none;
}

/* RGB Split / Chromatic Aberration Layer */
#intro-rgb{
  position:absolute;inset:0;
  opacity:0;
  pointer-events:none;
  background:linear-gradient(90deg,rgba(255,0,0,0.3) 0%,transparent 10%,transparent 90%,rgba(0,255,255,0.3) 100%);
}

/* Scan Lines Layer */
#intro-scanlines{
  position:absolute;inset:0;
  background:repeating-linear-gradient(
    0deg,
    transparent 0px,
    transparent 2px,
    rgba(0,0,0,0.4) 2px,
    rgba(0,0,0,0.4) 4px
  );
  opacity:0;
  pointer-events:none;
}

/* White Flash Layer */
#intro-flash{
  position:absolute;inset:0;
  background:#fff;
  opacity:0;
  pointer-events:none;
}

/* Active VHS Transition */
#intro-static.active{
  opacity:1;
  animation:vhs-static 1s steps(8) forwards;
}
#intro-rgb.active{
  animation:vhs-rgb 1s steps(6) forwards;
}
#intro-scanlines.active{
  animation:vhs-scanlines 1s steps(4) forwards;
}
#intro-flash.active{
  animation:vhs-flash 1s ease-out forwards;
}

@keyframes vhs-static{
  0%{opacity:0.9;transform:scale(1.02)}
  15%{opacity:1;transform:translateY(5px) scale(1.03)}
  30%{opacity:0.8;transform:translateY(-8px) scaleY(1.05)}
  45%{opacity:1;transform:translateX(3px)}
  60%{opacity:0.9;transform:translateX(-5px) translateY(3px)}
  75%{opacity:1;transform:scale(1.02) translateY(-2px)}
  90%{opacity:0.7;transform:scaleY(0.98)}
  100%{opacity:0}
}

@keyframes vhs-rgb{
  0%{opacity:0.8;transform:translateX(-5px)}
  20%{opacity:0.6;transform:translateX(8px)}
  40%{opacity:0.9;transform:translateX(-10px)}
  60%{opacity:0.5;transform:translateX(5px)}
  80%{opacity:0.7;transform:translateX(-3px)}
  100%{opacity:0}
}

@keyframes vhs-scanlines{
  0%{opacity:0.6;background-position:0 0}
  25%{opacity:0.8;background-position:0 10px}
  50%{opacity:0.5;background-position:0 -5px}
  75%{opacity:0.7;background-position:0 15px}
  100%{opacity:0;background-position:0 0}
}

@keyframes vhs-flash{
  0%{opacity:0}
  10%{opacity:0.8}
  20%{opacity:0.2}
  30%{opacity:0.6}
  50%{opacity:0.1}
  100%{opacity:0}
}

/* LOADING SCREEN */
#loading-screen{position:absolute;inset:0;background:#0a0a0f;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:1000;transition:opacity 0.5s}
#loading-screen.hidden{opacity:0;pointer-events:none}
#loading-screen img{width:clamp(200px,50vw,400px);margin-bottom:30px}
#loading-text{color:#00D4FF;font-size:clamp(14px,3vw,24px);font-family:'Press Start 2P',monospace;text-shadow:0 0 10px #00D4FF}
#loading-spinner{width:40px;height:40px;border:3px solid rgba(0,212,255,.3);border-top:3px solid #FF6B9D;border-radius:50%;animation:spin-loader .8s linear infinite;margin-top:20px}
@keyframes spin-loader{to{transform:rotate(360deg)}}

/* TOP BAR */
#top-bar{position:absolute;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:20px;background:rgba(10,10,15,.85);padding:10px 25px;border-radius:8px;border:1px solid #FF6B9D;box-shadow:0 0 20px rgba(255,107,157,.3)}
.stat{display:flex;flex-direction:column;align-items:center;color:#F4F4F0}
.stat-label{font-size:clamp(10px,2vw,12px);color:#00D4FF;text-transform:uppercase;letter-spacing:1px}
.stat-value{font-size:clamp(16px,3.5vw,24px);font-family:'Press Start 2P',monospace;color:#FF6B9D;text-shadow:0 0 10px rgba(255,107,157,.5)}

/* SLOT FRAME - Neon Glow Border */
#slot-area{position:relative;width:clamp(320px,90vw,900px);height:clamp(280px,50vh,450px)}
#reels-window{
  position:absolute;inset:0;overflow:hidden;border-radius:12px;
  background:rgba(10,10,15,.45);
  backdrop-filter:blur(6px) saturate(1.3);
  -webkit-backdrop-filter:blur(6px) saturate(1.3);
  border:4px solid #FF6B9D;
  box-shadow:
    0 0 10px #FF6B9D,
    0 0 20px #FF6B9D,
    0 0 40px rgba(255,107,157,.5),
    0 0 80px rgba(255,107,157,.3),
    inset 0 0 20px rgba(0,212,255,.1);
  animation:neon-flicker 4s ease-in-out infinite;
}
#reels-window::before{
  content:'';position:absolute;inset:-4px;border-radius:16px;padding:4px;
  background:linear-gradient(45deg,#FF6B9D,#00D4FF,#FF6B9D,#00D4FF);
  background-size:400% 400%;
  animation:neon-shift 8s linear infinite;
  -webkit-mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);
  mask:linear-gradient(#fff 0 0) content-box,linear-gradient(#fff 0 0);
  -webkit-mask-composite:xor;mask-composite:exclude;
  pointer-events:none;z-index:20;
}
#reels-window::after{
  content:'';position:absolute;inset:0;border-radius:8px;
  box-shadow:inset 0 0 30px rgba(0,212,255,.2),inset 0 0 60px rgba(255,107,157,.1);
  pointer-events:none;z-index:1;
}
@keyframes neon-flicker{
  0%,100%{box-shadow:0 0 10px #FF6B9D,0 0 20px #FF6B9D,0 0 40px rgba(255,107,157,.5),0 0 80px rgba(255,107,157,.3)}
  50%{box-shadow:0 0 5px #00D4FF,0 0 15px #00D4FF,0 0 30px rgba(0,212,255,.5),0 0 60px rgba(0,212,255,.3)}
}
@keyframes neon-shift{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
#reels-container{display:flex;width:100%;height:100%;gap:4px;padding:4px;position:relative;z-index:5}
.reel-col{flex:1;position:relative;overflow:hidden;border-radius:4px;background:rgba(0,0,0,0.1)}
.reel-strip{display:flex;flex-direction:column;position:absolute;width:100%;left:0;top:0}
.sym-cell{
  width:100%;
  background-size:75% 75%;
  background-repeat:no-repeat;
  background-position:center;
  background-color:rgba(0,212,255,.03);
  border-radius:4px;
  border:1px solid rgba(0,212,255,.06);
  flex-shrink:0;
  box-sizing:border-box;
}
.sym-cell.winner{
  animation:pulse-win .4s ease-in-out infinite alternate;
  box-shadow:inset 0 0 15px rgba(255,107,157,0.5),0 0 10px #FF6B9D,0 0 20px rgba(0,212,255,0.3);
  border-color:#FF6B9D !important;
  z-index:10;
}
@keyframes pulse-win{
  from{transform:scale(1);filter:brightness(1.1)}
  to{transform:scale(1.05);filter:brightness(1.4) drop-shadow(0 0 8px #FF6B9D) drop-shadow(0 0 15px #00D4FF)}
}

/* SCATTER WIN - Gold glow, no connecting line */
.sym-cell.scatter-win{
  animation:scatter-win-pulse .5s ease-in-out infinite alternate;
  box-shadow:inset 0 0 15px rgba(255,215,0,0.5),0 0 15px rgba(255,215,0,0.7),0 0 25px rgba(255,215,0,0.4);
  border-color:#FFD700 !important;
}
@keyframes scatter-win-pulse{
  from{transform:scale(1);filter:brightness(1.2) drop-shadow(0 0 8px rgba(255,215,0,0.6))}
  to{transform:scale(1.08);filter:brightness(1.5) drop-shadow(0 0 15px rgba(255,215,0,0.8))}
}

/* EXPANDING WILD - Cat fills entire reel during win animation */
.reel-col.expanding-wild{
  position:relative;
}
.reel-col .expanding-wild-overlay{
  position:absolute;
  inset:0;
  z-index:50;
  display:flex;
  flex-direction:column;
  pointer-events:none;
  opacity:0;
  transform:scaleY(0);
  transform-origin:center;
  transition:none;
}
.reel-col .expanding-wild-overlay.active{
  opacity:1;
  transform:scaleY(1);
  animation:wild-expand 0.4s ease-out forwards, wild-reel-pulse 0.5s ease-in-out 0.4s infinite alternate;
}
.reel-col .expanding-wild-overlay .wild-cell{
  flex:1;
  background:url('assets/sym_wild_cat.webp') center/70% 70% no-repeat;
  background-color:rgba(0,20,40,0.85);
  border:2px solid #00D4FF;
  box-shadow:inset 0 0 20px rgba(0,212,255,0.5),0 0 15px rgba(0,212,255,0.6);
  position:relative;
}
.reel-col .expanding-wild-overlay .wild-cell::after{
  content:'WILD';
  position:absolute;
  bottom:5px;
  left:50%;
  transform:translateX(-50%);
  font-size:10px;
  font-family:'Press Start 2P',monospace;
  color:#00D4FF;
  text-shadow:0 0 4px #00D4FF,0 0 8px #00D4FF,0 1px 2px rgba(0,0,0,0.9);
}
@keyframes wild-expand{
  0%{transform:scaleY(0);opacity:0}
  50%{transform:scaleY(1.1);opacity:1}
  100%{transform:scaleY(1);opacity:1}
}
@keyframes wild-reel-pulse{
  from{filter:brightness(1.1) drop-shadow(0 0 10px rgba(0,212,255,0.6))}
  to{filter:brightness(1.3) drop-shadow(0 0 20px rgba(0,212,255,0.8)) drop-shadow(0 0 30px rgba(0,212,255,0.4))}
}

/* WILD SYMBOL (CAT) - Cyan glow with WILD badge */
.sym-cell.wild{
  animation:wild-pulse 2s ease-in-out infinite;
  position:relative;
}
.sym-cell.wild::before{
  content:'WILD';
  position:absolute;
  bottom:4px;
  left:50%;
  transform:translateX(-50%);
  font-size:10px;
  font-family:'Press Start 2P',monospace;
  color:#00D4FF;
  text-shadow:0 0 4px #00D4FF,0 0 8px #00D4FF,0 1px 2px rgba(0,0,0,0.8);
  z-index:5;
  pointer-events:none;
  animation:wild-text-pulse 2s ease-in-out infinite;
}
@keyframes wild-pulse{
  0%,100%{filter:brightness(1.05) drop-shadow(0 0 4px rgba(0,212,255,0.4))}
  50%{filter:brightness(1.2) drop-shadow(0 0 8px rgba(0,212,255,0.6)) drop-shadow(0 0 12px rgba(0,212,255,0.3))}
}
@keyframes wild-text-pulse{
  0%,100%{opacity:0.9;transform:translateX(-50%) scale(1)}
  50%{opacity:1;transform:translateX(-50%) scale(1.05)}
}

/* BONUS SYMBOL (KEY) - Special animated glow! */
.sym-cell.bonus{
  animation:bonus-glow 2s ease-in-out infinite;
  position:relative;
}
.sym-cell.bonus::after{
  content:'';
  position:absolute;
  inset:-2px;
  border-radius:6px;
  background:linear-gradient(45deg,rgba(255,215,0,0.3),rgba(255,107,157,0.3),rgba(0,212,255,0.3),rgba(255,215,0,0.3));
  background-size:300% 300%;
  animation:bonus-shimmer 3s linear infinite;
  pointer-events:none;
  z-index:-1;
}
@keyframes bonus-glow{
  0%,100%{
    transform:scale(1);
    filter:brightness(1.15) drop-shadow(0 0 6px rgba(255,215,0,0.6));
  }
  50%{
    transform:scale(1.05);
    filter:brightness(1.35) drop-shadow(0 0 12px rgba(255,215,0,0.8)) drop-shadow(0 0 18px rgba(255,107,157,0.5));
  }
}
@keyframes bonus-shimmer{
  0%{background-position:0% 50%}
  50%{background-position:100% 50%}
  100%{background-position:0% 50%}
}

/* HIGH PAY (DRAGON/CLERK) SYMBOL - Jackpot symbol! */
.sym-cell.high-pay{
  animation:highpay-glow 3s ease-in-out infinite;
}
@keyframes highpay-glow{
  0%,100%{filter:brightness(1.05) drop-shadow(0 0 3px rgba(255,107,157,0.3))}
  50%{filter:brightness(1.2) drop-shadow(0 0 8px rgba(255,107,157,0.5))}
}

/* === SPINNING STATE === */
/* VHS scanline overlay */
.reel-col.spinning::before{
  content:'';position:absolute;inset:0;z-index:10;pointer-events:none;
  background:repeating-linear-gradient(0deg,transparent 0px,transparent 2px,rgba(0,0,0,0.15) 2px,rgba(0,0,0,0.15) 4px);
}
/* VHS color fringing on symbols */
.reel-col.spinning .sym-cell{
  filter:blur(1px) brightness(1.1);
}
/* Fast downward scroll animation */
.reel-col.spinning .reel-strip{
  animation:reel-spin 0.08s linear infinite;
}
@keyframes reel-spin{
  0%{transform:translateY(0)}
  100%{transform:translateY(var(--cell-height))}
}

/* === STOPPING STATE === */
.reel-col.stopping .reel-strip{
  animation:none;
  transition:transform 0.1s ease-out;
  transform:translateY(0);
}
.reel-col.stopping .sym-cell{
  filter:none;
  animation:land-bounce 0.15s ease-out;
}
@keyframes land-bounce{
  0%{transform:translateY(-5px);filter:brightness(1.3) drop-shadow(-2px 0 0 #FF6B9D) drop-shadow(2px 0 0 #00D4FF)}
  50%{transform:translateY(2px)}
  100%{transform:translateY(0);filter:none}
}

/* === STATIC STATE (default) === */
.reel-col .reel-strip{
  transform:translateY(0);
}
.reel-col .sym-cell{
  filter:none;
  animation:none;
}

/* CONTROLS */
#controls{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;align-items:center;gap:15px;background:rgba(10,10,15,.85);padding:15px 25px;border-radius:12px;border:1px solid #00D4FF;box-shadow:0 0 20px rgba(0,212,255,.3)}
.ctrl-btn{background:linear-gradient(135deg,#1a1a2e 0%,#0a0a0f 100%);border:2px solid #00D4FF;color:#F4F4F0;padding:8px 16px;border-radius:6px;font-family:'VT323',monospace;font-size:clamp(14px,2.5vw,18px);cursor:pointer;transition:all .2s}
.ctrl-btn:hover{background:#00D4FF;color:#0a0a0f;box-shadow:0 0 15px rgba(0,212,255,.5)}
.ctrl-btn:disabled{opacity:.4;cursor:default}
#spin-btn{width:clamp(70px,15vw,100px);height:clamp(70px,15vw,100px);border-radius:50%;background:radial-gradient(circle at 40% 35%,#FF6B9D,#c4507a 70%,#8a3654);border:3px solid #00D4FF;color:#F4F4F0;font-size:clamp(12px,2.5vw,16px);font-family:'Press Start 2P',monospace;cursor:pointer;box-shadow:0 4px 20px rgba(255,107,157,.4);transition:transform .1s,box-shadow .1s}
#spin-btn:hover{box-shadow:0 4px 30px rgba(255,107,157,.6)}
#spin-btn:active{transform:scale(.95)}
#spin-btn:disabled{opacity:.5;cursor:default;transform:none}
#bet-display{display:flex;flex-direction:column;align-items:center}
#bet-display span{font-size:clamp(10px,2vw,12px);color:#00D4FF}
#bet-display strong{font-size:clamp(16px,2.5vw,20px);color:#FF6B9D;font-family:'Press Start 2P',monospace}

/* WIN DISPLAY - Small popup near reels */
#win-display{
  position:absolute;
  top:45%;left:50%;
  transform:translate(-50%,-50%);
  font-size:clamp(20px,4vw,28px);
  font-family:'Press Start 2P',monospace;
  color:#FF6B9D;
  text-shadow:0 0 8px #FF6B9D,0 0 16px #FF6B9D;
  opacity:0;
  pointer-events:none;
  z-index:50;
  background:rgba(10,10,15,0.8);
  padding:8px 16px;
  border-radius:8px;
  border:2px solid #FF6B9D;
}
#win-display.show{animation:win-pop 1.2s ease-out forwards}
@keyframes win-pop{
  0%{opacity:0;transform:translate(-50%,-50%) scale(0.7)}
  15%{opacity:1;transform:translate(-50%,-50%) scale(1.1)}
  30%{transform:translate(-50%,-50%) scale(1)}
  80%{opacity:1}
  100%{opacity:0;transform:translate(-50%,-50%) scale(1)}
}

/* WIN LINES SVG OVERLAY - Bad Neon Tube Effect */
#win-lines{
  position:absolute;
  inset:4px;
  pointer-events:none;
  z-index:15;
  overflow:visible;
}
#win-lines line{
  stroke-width:6;
  stroke-linecap:round;
  stroke-opacity:0.5;
  opacity:0;
  filter:
    blur(2px)
    drop-shadow(0 0 4px currentColor)
    drop-shadow(0 0 8px currentColor)
    drop-shadow(0 0 16px currentColor);
  animation:line-draw 0.3s ease-out forwards, neon-flicker-bad 0.1s ease-in-out 0.3s infinite;
}
/* Inner bright core of the neon */
#win-lines line.neon-core{
  stroke-width:2;
  stroke-opacity:0.9;
  opacity:0;
  filter:blur(0.5px) drop-shadow(0 0 2px white);
  animation:line-draw-core 0.3s ease-out forwards, neon-core-flicker 0.08s ease-in-out 0.3s infinite;
}
@keyframes line-draw{
  from{opacity:0;stroke-dasharray:1000;stroke-dashoffset:1000}
  to{opacity:1;stroke-dasharray:1000;stroke-dashoffset:0}
}
@keyframes line-draw-core{
  from{opacity:0;stroke-dasharray:1000;stroke-dashoffset:1000}
  to{opacity:1;stroke-dasharray:1000;stroke-dashoffset:0}
}
/* Bad neon flicker - irregular, unstable */
@keyframes neon-flicker-bad{
  0%{opacity:1;filter:blur(2px) drop-shadow(0 0 4px currentColor) drop-shadow(0 0 8px currentColor) drop-shadow(0 0 16px currentColor)}
  10%{opacity:0.4;filter:blur(3px) drop-shadow(0 0 2px currentColor)}
  20%{opacity:0.9;filter:blur(2px) drop-shadow(0 0 6px currentColor) drop-shadow(0 0 12px currentColor)}
  30%{opacity:1;filter:blur(2px) drop-shadow(0 0 4px currentColor) drop-shadow(0 0 8px currentColor) drop-shadow(0 0 16px currentColor)}
  50%{opacity:0.6;filter:blur(2.5px) drop-shadow(0 0 3px currentColor)}
  55%{opacity:0.3;filter:blur(4px) drop-shadow(0 0 2px currentColor)}
  60%{opacity:0.95;filter:blur(2px) drop-shadow(0 0 5px currentColor) drop-shadow(0 0 10px currentColor)}
  80%{opacity:1;filter:blur(2px) drop-shadow(0 0 4px currentColor) drop-shadow(0 0 8px currentColor) drop-shadow(0 0 16px currentColor)}
  85%{opacity:0.5;filter:blur(3px) drop-shadow(0 0 3px currentColor)}
  100%{opacity:1;filter:blur(2px) drop-shadow(0 0 4px currentColor) drop-shadow(0 0 8px currentColor) drop-shadow(0 0 16px currentColor)}
}
@keyframes neon-core-flicker{
  0%,30%,60%,100%{opacity:1}
  10%,55%,85%{opacity:0.3}
  20%,50%,80%{opacity:0.8}
}

/* BONUS SCREEN - Atmospheric & Mysterious */
#bonus-screen{
  position:absolute;inset:0;
  background:url('assets/bg_bonus1.webp') center/cover no-repeat;
  display:none;flex-direction:column;align-items:center;justify-content:center;
  z-index:100;
  overflow:hidden;
}
#bonus-screen.active{display:flex}

/* Scanline VHS overlay */
#bonus-screen::before{
  content:'';position:absolute;inset:0;
  background:repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0,0,0,0.15) 2px,
    rgba(0,0,0,0.15) 4px
  );
  pointer-events:none;z-index:10;
  animation:scanline-scroll 10s linear infinite;
}
@keyframes scanline-scroll{from{background-position:0 0}to{background-position:0 100px}}

/* Fog/mist drifting effect */
#bonus-screen::after{
  content:'';position:absolute;inset:0;
  background:radial-gradient(ellipse at 30% 80%, rgba(0,212,255,0.08) 0%, transparent 50%),
             radial-gradient(ellipse at 70% 20%, rgba(255,107,157,0.06) 0%, transparent 40%),
             radial-gradient(ellipse at 50% 50%, rgba(0,0,0,0.3) 0%, transparent 70%);
  pointer-events:none;z-index:5;
  animation:fog-drift 15s ease-in-out infinite alternate;
}
@keyframes fog-drift{
  0%{opacity:0.8;transform:translateX(-5%) scale(1.05)}
  100%{opacity:1;transform:translateX(5%) scale(1)}
}

/* Flickering fluorescent light effect */
#bonus-screen{animation:flicker-light 8s ease-in-out infinite}
@keyframes flicker-light{
  0%,100%{filter:brightness(1)}
  5%{filter:brightness(0.95)}
  10%{filter:brightness(1.02)}
  15%{filter:brightness(0.98)}
  50%{filter:brightness(1)}
  52%{filter:brightness(0.9)}
  54%{filter:brightness(1.05)}
  56%{filter:brightness(0.95)}
}

/* Level 2 - Creepier atmosphere */
#bonus-screen.level2{
  background-image:url('assets/bg_bonus2.webp');
  animation:flicker-light 8s ease-in-out infinite, level2-pulse 4s ease-in-out infinite;
}
@keyframes level2-pulse{
  0%,100%{box-shadow:inset 0 0 100px rgba(255,0,50,0.1)}
  50%{box-shadow:inset 0 0 150px rgba(255,0,50,0.2)}
}

#bonus-title{
  font-size:clamp(22px,5.5vw,42px);
  font-family:'Press Start 2P',monospace;
  color:#00D4FF;
  text-shadow:0 0 20px #00D4FF,0 0 40px rgba(0,212,255,0.5);
  margin-bottom:15px;
  z-index:20;
  animation:title-glow 3s ease-in-out infinite alternate;
}
@keyframes title-glow{
  from{text-shadow:0 0 20px #00D4FF,0 0 40px rgba(0,212,255,0.5)}
  to{text-shadow:0 0 30px #FF6B9D,0 0 50px rgba(255,107,157,0.5)}
}
#bonus-screen.level2 #bonus-title{color:#FF6B9D;text-shadow:0 0 20px #FF6B9D,0 0 40px rgba(255,0,50,0.5)}

#bonus-subtitle{
  font-size:clamp(12px,2.5vw,18px);
  color:#F4F4F0;
  margin-bottom:25px;
  z-index:20;
  opacity:0.9;
  font-style:italic;
}

/* ========== SCRATCH TICKET (Level 1) ========== */
#scratch-ticket{
  position:relative;
  max-height:80vh;
  width:auto;
  z-index:20;
  margin:10px 0;
  display:inline-block; /* Shrink to fit image */
}
#scratch-ticket img{
  max-height:80vh;
  width:auto;
  display:block;
  filter:drop-shadow(0 10px 30px rgba(0,0,0,0.5));
  position:relative; /* Ensure it's the positioning reference */
}
#scratch-cells{
  position:absolute;
  top:0;left:0;
  /* Size will be set by JS to match image exactly */
  pointer-events:none;
}
.scratch-cell{
  position:absolute;
  cursor:pointer;
  overflow:hidden;
  pointer-events:auto;
  /* Size and position set via JS based on scale ratio */
}
/* Grey scratch-off overlay */
.scratch-cell::before{
  content:'';
  position:absolute;inset:0;
  background:linear-gradient(135deg,#9a9a9a 0%,#c0c0c0 25%,#8a8a8a 50%,#b5b5b5 75%,#9a9a9a 100%);
  border-radius:var(--cell-radius, 15px);
  transition:transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1),opacity 0.4s;
  z-index:2;
  box-shadow:inset 0 2px 4px rgba(255,255,255,0.3),inset 0 -2px 4px rgba(0,0,0,0.2);
}
.scratch-cell:hover::before{
  background:linear-gradient(135deg,#b0b0b0 0%,#d0d0d0 25%,#a0a0a0 50%,#c5c5c5 75%,#b0b0b0 100%);
  transform:scale(1.02);
}
/* Prize underneath */
.scratch-cell .prize-content{
  position:absolute;inset:0;
  display:flex;align-items:center;justify-content:center;
  flex-direction:column;
  background:rgba(0,20,40,0.9);
  z-index:1;
}
.scratch-cell .prize-amount{
  font-size:clamp(10px,2.5vw,16px);
  font-family:'Press Start 2P',monospace;
  color:#00D4FF;
  text-shadow:0 0 8px #00D4FF;
}
.scratch-cell .prize-content.key-prize{
  background:linear-gradient(135deg,rgba(50,40,0,0.95),rgba(80,60,0,0.95));
}
.scratch-cell .prize-content.key-prize .prize-amount{
  color:#FFD700;
  text-shadow:0 0 10px #FFD700,0 0 20px rgba(255,215,0,0.5);
}
/* Scratched state */
.scratch-cell.scratched::before{
  transform:scale(0) rotate(15deg);
  opacity:0;
}
.scratch-cell.scratched{
  cursor:default;
  animation:cell-reveal 0.5s ease-out;
}
@keyframes cell-reveal{
  0%{transform:scale(1)}
  30%{transform:scale(1.1)}
  100%{transform:scale(1)}
}
/* Scratch particles */
.scratch-particle{
  width:8px;height:8px;
  background:linear-gradient(135deg,#c0c0c0,#808080);
  border-radius:2px;
  pointer-events:none;
  z-index:100;
}
/* Hide ticket in level 2 */
#bonus-screen.level2 #scratch-ticket{display:none}

/* Pick Grid - Only shows in Level 2 (Back Room) */
#pick-grid{
  display:none;
  grid-template-columns:repeat(3,1fr);
  gap:25px;
  max-width:85%;
  padding:20px;
  z-index:20;
}

.pick-item{
  width:clamp(105px,24vw,140px);
  height:clamp(105px,24vw,140px);
  background-size:60% 60%;
  background-repeat:no-repeat;
  background-position:center;
  background-color:rgba(0,10,25,0.92);
  border:3px solid rgba(0,212,255,0.4);
  border-radius:16px;
  cursor:pointer;
  position:relative;
  transition:transform .3s cubic-bezier(0.34, 1.56, 0.64, 1),filter .3s,border-color .3s,box-shadow .3s;
  filter:brightness(0.9);
  box-shadow:0 0 15px rgba(0,212,255,0.2),0 8px 25px rgba(0,0,0,0.6),inset 0 0 30px rgba(0,0,0,0.7);
  animation:item-float 4s ease-in-out infinite, item-mystery-glow 3s ease-in-out infinite alternate;
}
/* Stagger float animations */
.pick-item:nth-child(1){animation-delay:0s,0s}
.pick-item:nth-child(2){animation-delay:0.3s,0.5s}
.pick-item:nth-child(3){animation-delay:0.6s,1s}
.pick-item:nth-child(4){animation-delay:0.9s,0.3s}
.pick-item:nth-child(5){animation-delay:1.2s,0.8s}
.pick-item:nth-child(6){animation-delay:0.2s,1.2s}
.pick-item:nth-child(7){animation-delay:0.5s,0.2s}
.pick-item:nth-child(8){animation-delay:0.8s,0.7s}
.pick-item:nth-child(9){animation-delay:1.1s,1.1s}
.pick-item:nth-child(10){animation-delay:0.4s,0.4s}
.pick-item:nth-child(11){animation-delay:0.7s,0.9s}
.pick-item:nth-child(12){animation-delay:1.0s,0.6s}

@keyframes item-float{
  0%,100%{transform:translateY(0)}
  50%{transform:translateY(-6px)}
}
@keyframes item-mystery-glow{
  0%{box-shadow:0 0 15px rgba(0,212,255,0.2),0 8px 25px rgba(0,0,0,0.6),inset 0 0 30px rgba(0,0,0,0.7)}
  100%{box-shadow:0 0 25px rgba(0,212,255,0.35),0 8px 25px rgba(0,0,0,0.6),inset 0 0 20px rgba(0,212,255,0.1)}
}

/* Hover - lift up with bright glow */
.pick-item:hover{
  transform:translateY(-12px) scale(1.08);
  filter:brightness(1.25);
  border-color:#00D4FF;
  box-shadow:0 0 30px rgba(0,212,255,0.6),0 0 50px rgba(255,107,157,0.3),0 15px 40px rgba(0,0,0,0.7),inset 0 0 20px rgba(0,212,255,0.15);
  animation:none;
}

/* Revealed state */
.pick-item.revealed{
  cursor:default;
  animation:reveal-burst .7s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  border-color:#FF6B9D;
  filter:brightness(1.1);
}
.pick-item.revealed:hover{transform:none;filter:brightness(1.1);box-shadow:0 0 20px rgba(255,107,157,0.4)}

/* Key reveal - DRAMATIC golden glow */
.pick-item.revealed.key-reveal{
  border-color:#FFD700 !important;
  box-shadow:0 0 40px rgba(255,215,0,0.7),0 0 70px rgba(255,215,0,0.5),0 0 100px rgba(255,215,0,0.3) !important;
  animation:reveal-burst .7s cubic-bezier(0.34, 1.56, 0.64, 1), key-dramatic-glow 0.8s ease-in-out .7s infinite alternate;
}
@keyframes key-dramatic-glow{
  from{box-shadow:0 0 40px rgba(255,215,0,0.7),0 0 70px rgba(255,215,0,0.5),0 0 100px rgba(255,215,0,0.3);transform:scale(1)}
  to{box-shadow:0 0 60px rgba(255,215,0,0.9),0 0 100px rgba(255,215,0,0.6),0 0 140px rgba(255,215,0,0.4);transform:scale(1.05)}
}

/* Prize reveal - cyan glow with particles */
.pick-item.revealed.prize-reveal{
  border-color:#00D4FF;
  box-shadow:0 0 25px rgba(0,212,255,0.6),0 0 40px rgba(0,212,255,0.3);
}

/* Prize label pop-up */
.pick-item .prize-label{
  position:absolute;
  bottom:8px;
  left:50%;
  transform:translateX(-50%);
  font-size:clamp(11px,2.2vw,15px);
  font-family:'Press Start 2P',monospace;
  color:#00D4FF;
  text-shadow:0 0 8px #00D4FF,0 0 15px rgba(0,212,255,0.5),0 2px 4px rgba(0,0,0,0.9);
  white-space:nowrap;
  opacity:0;
  animation:prize-pop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s forwards;
}
@keyframes prize-pop{
  0%{opacity:0;transform:translateX(-50%) translateY(20px) scale(0.5)}
  60%{transform:translateX(-50%) translateY(-5px) scale(1.1)}
  100%{opacity:1;transform:translateX(-50%) translateY(0) scale(1)}
}

@keyframes reveal-burst{
  0%{transform:scale(1) rotate(0deg)}
  25%{transform:scale(1.2) rotate(-3deg)}
  50%{transform:scale(0.9) rotate(2deg)}
  75%{transform:scale(1.05) rotate(-1deg)}
  100%{transform:scale(1) rotate(0deg)}
}

/* ========== LEVEL 2 - SHELF CRATE LAYOUT ========== */
#bonus-screen.level2 #pick-grid{display:none}
#bonus-screen.level2 #crate-shelf{display:block}

#crate-shelf{
  display:none;
  position:relative;
  max-width:70%;
  max-height:55vh;
  z-index:20;
  margin-top:8vh; /* Position slightly lower in scene */
}
#crate-shelf #shelf-bg{
  max-width:100%;
  max-height:55vh;
  width:auto;
  height:auto;
  display:block;
  /* Drop shadow to ground it in the scene */
  filter:drop-shadow(0 8px 20px rgba(0,0,0,0.6)) drop-shadow(0 20px 40px rgba(0,0,0,0.4));
}
#crate-container{
  position:absolute;
  top:0;left:0;
  pointer-events:none;
}
.crate{
  position:absolute;
  cursor:pointer;
  pointer-events:auto;
  background:url('assets/crate.webp') center/contain no-repeat;
  transition:transform 0.2s ease-out, filter 0.2s;
  filter:brightness(0.95);
}
.crate:hover{
  transform:scale(1.05);
  filter:brightness(1.15) drop-shadow(0 0 15px rgba(255,107,157,0.5));
}
.crate.shaking{
  animation:crate-shake 0.4s ease-in-out;
}
@keyframes crate-shake{
  0%,100%{transform:translateX(0) rotate(0deg)}
  20%{transform:translateX(-4px) rotate(-2deg)}
  40%{transform:translateX(4px) rotate(2deg)}
  60%{transform:translateX(-3px) rotate(-1deg)}
  80%{transform:translateX(3px) rotate(1deg)}
}
.crate.opened{
  cursor:default;
  animation:crate-open 0.5s ease-out forwards;
  pointer-events:none;
}
@keyframes crate-open{
  0%{transform:scale(1);opacity:1}
  30%{transform:scale(1.1) translateY(-10px);opacity:1}
  100%{transform:scale(0.8) translateY(-30px);opacity:0.3}
}
/* Prize floating up from crate */
.crate-prize{
  position:absolute;
  font-size:clamp(14px,3vw,22px);
  font-family:'Press Start 2P',monospace;
  color:#00D4FF;
  text-shadow:0 0 10px #00D4FF,0 0 20px #00D4FF,0 2px 4px rgba(0,0,0,0.9);
  white-space:nowrap;
  pointer-events:none;
  opacity:0;
  animation:prize-float-up 1.5s ease-out forwards;
}
.crate-prize.end-prize{
  color:#FF6B9D;
  text-shadow:0 0 10px #FF6B9D,0 0 20px #FF6B9D,0 2px 4px rgba(0,0,0,0.9);
}
@keyframes prize-float-up{
  0%{opacity:0;transform:translateY(0) scale(0.5)}
  20%{opacity:1;transform:translateY(-20px) scale(1.1)}
  80%{opacity:1;transform:translateY(-60px) scale(1)}
  100%{opacity:0;transform:translateY(-80px) scale(0.9)}
}

#bonus-win{font-size:clamp(20px,5vw,36px);font-family:'Press Start 2P',monospace;color:#FF6B9D;margin-top:20px;z-index:20;text-shadow:0 0 10px rgba(255,107,157,0.5)}
#bonus-info{font-size:clamp(12px,2.5vw,16px);color:#F4F4F0;margin-top:10px;z-index:20;opacity:0.8}
#collect-btn{margin-top:25px;padding:15px 40px;font-size:clamp(16px,3vw,24px);display:none;z-index:20}

/* BIG WIN OVERLAY */
#bigwin-overlay{
  position:absolute;inset:0;
  background:rgba(0,0,0,0);
  display:none;align-items:center;justify-content:center;flex-direction:column;
  z-index:200;
  gap:15px;
}
#bigwin-overlay.active{display:flex;animation:bigwin-bg-fade 0.5s ease-out forwards}
@keyframes bigwin-bg-fade{from{background:rgba(0,0,0,0)}to{background:rgba(0,0,0,0.92)}}

/* REGULAR BIG WIN - Show frame.webp (2x BIGGER) */
#bigwin-frame{
  width:clamp(400px,90vw,800px);
  height:clamp(220px,50vw,400px);
  background:url('assets/frame.webp') center/contain no-repeat;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  transform:scale(0);
  opacity:0;
  filter:drop-shadow(0 0 40px #FF6B9D) drop-shadow(0 0 80px rgba(0,212,255,0.7));
  gap:15px;
  padding:30px;
}
#bigwin-overlay.active:not(.mega) #bigwin-frame{
  animation:frame-zoom 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.3s forwards, frame-glow 1.5s ease-in-out 1.2s infinite;
}
#bigwin-overlay.mega #bigwin-frame{display:none}

/* MEGA WIN - Show bigwin1.webp (2x BIGGER, text already in image) */
#bigwin-image{
  display:none;
  width:clamp(400px,92vw,850px);
  height:auto;
  object-fit:contain;
  transform:scale(0);
  opacity:0;
  filter:drop-shadow(0 0 50px rgba(255,215,0,0.8)) drop-shadow(0 0 80px rgba(255,107,157,0.6));
}
#bigwin-overlay.mega #bigwin-image{
  display:block;
  animation:bigwin-img-zoom 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) 0.2s forwards, bigwin-img-pulse 1.5s ease-in-out 1.2s infinite;
}

@keyframes frame-zoom{
  0%{transform:scale(0.2);opacity:0}
  70%{transform:scale(1.08);opacity:1}
  100%{transform:scale(1);opacity:1}
}
@keyframes frame-glow{
  0%,100%{filter:drop-shadow(0 0 40px #FF6B9D) drop-shadow(0 0 80px rgba(255,107,157,0.6))}
  50%{filter:drop-shadow(0 0 50px #00D4FF) drop-shadow(0 0 100px rgba(0,212,255,0.7)) drop-shadow(0 0 120px rgba(255,215,0,0.5))}
}
@keyframes bigwin-img-zoom{
  0%{transform:scale(0) rotate(-5deg);opacity:0}
  70%{transform:scale(1.12) rotate(2deg);opacity:1}
  85%{transform:scale(0.96) rotate(-1deg)}
  100%{transform:scale(1) rotate(0deg);opacity:1}
}
@keyframes bigwin-img-pulse{
  0%,100%{transform:scale(1);filter:drop-shadow(0 0 50px rgba(255,215,0,0.8)) drop-shadow(0 0 80px rgba(255,107,157,0.6))}
  50%{transform:scale(1.04);filter:drop-shadow(0 0 80px rgba(255,215,0,1)) drop-shadow(0 0 120px rgba(255,107,157,0.8)) drop-shadow(0 0 150px rgba(0,212,255,0.5))}
}

/* Title - inside frame for BIG WIN */
#bigwin-title{
  font-size:clamp(26px,6vw,48px);
  font-family:'Press Start 2P',monospace;
  color:#FFD700;
  text-shadow:0 0 15px #FFD700,0 0 30px #FF6B9D,0 0 45px #FFD700,0 3px 6px rgba(0,0,0,0.9);
  opacity:0;
  letter-spacing:4px;
}
#bigwin-overlay.active:not(.mega) #bigwin-title{animation:bigwin-title-show 0.4s ease-out 0.6s forwards}
#bigwin-overlay.mega #bigwin-title{display:none}
@keyframes bigwin-title-show{from{opacity:0;transform:scale(0.5)}to{opacity:1;transform:scale(1)}}

/* Amount - inside frame for BIG WIN */
#bigwin-amount{
  font-size:clamp(40px,10vw,80px);
  font-family:'Press Start 2P',monospace;
  color:#00D4FF;
  text-shadow:0 0 15px #00D4FF,0 0 30px #00D4FF,0 0 50px #00D4FF,0 3px 6px rgba(0,0,0,0.9);
  opacity:0;
  letter-spacing:3px;
}
#bigwin-overlay.active:not(.mega) #bigwin-amount{animation:bigwin-amt-show 0.5s ease-out 1s forwards}
#bigwin-overlay.mega #bigwin-amount{display:none}
@keyframes bigwin-amt-show{
  from{opacity:0;transform:scale(0.3)}
  to{opacity:1;transform:scale(1)}
}

/* MEGA WIN - Text overlaid on bigwin1.webp image */
#bigwin-mega-text{
  display:none;
  flex-direction:column;
  align-items:center;
  gap:15px;
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  z-index:10;
}
#bigwin-overlay.mega #bigwin-mega-text{display:flex}
#bigwin-mega-title{
  font-size:clamp(32px,8vw,64px);
  font-family:'Press Start 2P',monospace;
  color:#FFD700;
  text-shadow:
    0 0 20px #FFD700,
    0 0 40px #FFD700,
    0 0 60px rgba(255,215,0,0.8),
    0 0 80px rgba(255,107,157,0.6),
    0 4px 8px rgba(0,0,0,0.9);
  opacity:0;
  letter-spacing:6px;
  white-space:nowrap;
}
#bigwin-overlay.mega.active #bigwin-mega-title{
  animation:mega-title-show 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.5s forwards;
}
@keyframes mega-title-show{
  0%{opacity:0;transform:scale(0.3) rotate(-5deg)}
  70%{transform:scale(1.1) rotate(2deg)}
  100%{opacity:1;transform:scale(1) rotate(0deg)}
}
#bigwin-mega-amount{
  font-size:clamp(44px,12vw,90px);
  font-family:'Press Start 2P',monospace;
  color:#00D4FF;
  text-shadow:0 0 20px #00D4FF,0 0 40px #00D4FF,0 0 60px rgba(0,212,255,0.7),0 4px 8px rgba(0,0,0,0.9);
  opacity:0;
  letter-spacing:4px;
}
#bigwin-overlay.mega.active #bigwin-mega-amount{animation:mega-amt-show 0.5s ease-out 1.1s forwards}
@keyframes mega-amt-show{
  from{opacity:0;transform:scale(0.3)}
  to{opacity:1;transform:scale(1)}
}

/* SOUND TOGGLE */
#sound-toggle{position:absolute;top:10px;right:10px;background:rgba(10,10,15,.8);border:1px solid #00D4FF;color:#00D4FF;width:40px;height:40px;border-radius:50%;cursor:pointer;font-size:20px;z-index:50}
#sound-toggle:hover{background:#00D4FF;color:#0a0a0f}

/* Message popup */
#message{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(10,10,15,.95);border:2px solid #FF6B9D;padding:30px 50px;border-radius:12px;color:#F4F4F0;font-size:clamp(16px,3vw,24px);text-align:center;z-index:300;display:none;box-shadow:0 0 40px rgba(255,107,157,.5)}
#message.show{display:block;animation:msg-in .3s ease-out}
@keyframes msg-in{from{opacity:0;transform:translate(-50%,-50%) scale(.8)}to{opacity:1;transform:translate(-50%,-50%) scale(1)}}

/* BONUS TRIGGER OVERLAY */
#bonus-trigger-overlay{
  position:absolute;inset:0;
  background:rgba(0,0,0,0.85);
  display:none;align-items:center;justify-content:center;
  flex-direction:column;
  z-index:250;
}
#bonus-trigger-overlay.active{display:flex}
#bonus-trigger-overlay img{
  max-width:80%;max-height:70%;
  object-fit:contain;
  transform:scale(0);
  animation:trigger-zoom 0.6s ease-out forwards;
  filter:drop-shadow(0 0 30px rgba(255,215,0,0.6));
}
@keyframes trigger-zoom{
  0%{transform:scale(0.3) rotate(-5deg);opacity:0}
  50%{transform:scale(1.1) rotate(2deg)}
  100%{transform:scale(1) rotate(0deg);opacity:1}
}

/* BACKROOM TRIGGER OVERLAY */
#backroom-trigger-overlay{
  position:absolute;inset:0;
  background:rgba(0,0,0,0.9);
  display:none;align-items:center;justify-content:center;
  flex-direction:column;
  z-index:150;
}
#backroom-trigger-overlay.active{display:flex}
#backroom-trigger-overlay img{
  max-width:80%;max-height:70%;
  object-fit:contain;
  transform:scale(0);
  animation:backroom-reveal 0.8s ease-out forwards;
  filter:drop-shadow(0 0 20px rgba(0,212,255,0.5));
}
@keyframes backroom-reveal{
  0%{transform:scale(0.5);opacity:0;filter:blur(10px) drop-shadow(0 0 20px rgba(0,212,255,0.5))}
  60%{transform:scale(1.05);filter:blur(0) drop-shadow(0 0 30px rgba(0,212,255,0.8))}
  100%{transform:scale(1);opacity:1;filter:blur(0) drop-shadow(0 0 20px rgba(0,212,255,0.5))}
}

/* Loading spinner for trigger overlays */
.trigger-loading{
  display:flex;
  align-items:center;
  gap:12px;
  color:#F4F4F0;
  font-family:'VT323',monospace;
  font-size:18px;
  margin-top:30px;
  opacity:0;
  animation:fade-in-loading 0.5s ease-out 2.5s forwards;
}
.trigger-loading .spinner{
  width:20px;height:20px;
  border:2px solid rgba(255,255,255,0.3);
  border-top:2px solid #00D4FF;
  border-radius:50%;
  animation:spin-loader 0.8s linear infinite;
}
@keyframes fade-in-loading{
  from{opacity:0}
  to{opacity:1}
}

/* ========== MOBILE RESPONSIVE (Portrait) ========== */
@media (max-width: 768px) and (orientation: portrait) {
  /* Reduce space above reels */
  #top-bar{
    top:5px;
    padding:6px 15px;
    gap:12px;
  }
  .stat-label{font-size:9px}
  .stat-value{font-size:14px}

  /* Slot area - fixed aspect ratio prevents vertical stretching */
  #slot-area{
    width:95vw;
    max-width:500px;
    height:auto !important;
    aspect-ratio:5/3;
  }

  /* Reels window follows slot area */
  #reels-window{
    position:relative;
    width:100%;
    height:100%;
    border-width:3px;
  }

  /* Controls - more compact */
  #controls{
    bottom:10px;
    padding:10px 15px;
    gap:10px;
  }
  .ctrl-btn{
    padding:6px 12px;
    font-size:14px;
  }
  #spin-btn{
    width:60px;
    height:60px;
    font-size:11px;
  }
  #bet-display span{font-size:9px}
  #bet-display strong{font-size:14px}

  /* Win display smaller */
  #win-display{
    font-size:18px;
    padding:6px 12px;
  }

  /* Sound toggle */
  #sound-toggle{
    width:35px;
    height:35px;
    font-size:16px;
  }

  /* Symbol sizing - prevent stretching */
  .sym-cell{
    background-size:70% 70%;
  }
}

/* Even smaller phones */
@media (max-width: 400px) and (orientation: portrait) {
  #slot-area{
    width:98vw;
  }
  #top-bar{
    padding:5px 10px;
    gap:8px;
  }
  .stat-value{font-size:12px}
  #controls{
    padding:8px 12px;
    gap:8px;
  }
  #spin-btn{
    width:55px;
    height:55px;
    font-size:10px;
  }
  .ctrl-btn{
    padding:5px 10px;
    font-size:12px;
  }
}
</style>
</head>
<body>
<div id="game-container">
  <!-- Intro Video Overlay - plays once on first visit -->
  <div id="intro-overlay">
    <video id="intro-video" playsinline>
      <source src="assets/intro.mp4" type="video/mp4">
    </video>
    <div id="intro-static"></div>
    <div id="intro-rgb"></div>
    <div id="intro-scanlines"></div>
    <div id="intro-flash"></div>
  </div>

  <!-- Loading Screen -->
  <div id="loading-screen">
    <img src="assets/logo.webp" alt="3AM BODEGA">
    <div id="loading-text">ENTERING...</div>
    <div id="loading-spinner"></div>
  </div>

  <!-- Top Stats Bar -->
  <div id="top-bar">
    <div class="stat"><span class="stat-label">Balance</span><span class="stat-value" id="balance">$0.00</span></div>
    <div class="stat"><span class="stat-label">Win</span><span class="stat-value" id="win">$0.00</span></div>
  </div>

  <!-- Slot Area -->
  <div id="slot-area">
    <div id="reels-window">
      <div id="reels-container"></div>
      <svg id="win-lines"></svg>
    </div>
  </div>

  <!-- Win Display -->
  <div id="win-display"></div>

  <!-- Controls -->
  <div id="controls">
    <button class="ctrl-btn" id="bet-down">âˆ’</button>
    <div id="bet-display"><span>TOTAL BET</span><strong id="bet-val">$0.21</strong></div>
    <button class="ctrl-btn" id="bet-up">+</button>
    <button id="spin-btn">SPIN</button>
    <button class="ctrl-btn" id="auto-btn">AUTO</button>
  </div>

  <!-- Sound Toggle -->
  <button id="sound-toggle">ðŸ”Š</button>

  <!-- Bonus Screen -->
  <div id="bonus-screen">
    <div id="bonus-title">BEHIND THE COUNTER</div>
    <div id="bonus-subtitle">Scratch 3 spots to reveal prizes...</div>

    <!-- Level 1: Scratch Ticket -->
    <div id="scratch-ticket">
      <img src="assets/ticket_revealed.webp" alt="Scratch Ticket" id="ticket-base">
      <div id="scratch-cells">
        <!-- 12 cells: 3 cols x 4 rows - positioned over grey areas -->
      </div>
    </div>

    <!-- Level 2: Back Room - Shelf with Crates -->
    <div id="pick-grid"></div>
    <div id="crate-shelf">
      <img src="assets/shelf.webp" alt="Storage Shelf" id="shelf-bg">
      <div id="crate-container"></div>
    </div>

    <div id="bonus-win">$0.00</div>
    <div id="bonus-info">Scratches remaining: 3</div>
    <button class="ctrl-btn" id="collect-btn">COLLECT</button>
  </div>

  <!-- Big Win Overlay -->
  <div id="bigwin-overlay">
    <!-- For MEGA WIN: shows bigwin1.webp -->
    <img id="bigwin-image" src="assets/bigwin1.webp" alt="MEGA WIN!">
    <!-- For MEGA WIN: text shown below image -->
    <div id="bigwin-mega-text">
      <div id="bigwin-mega-title">MEGA WIN!</div>
      <div id="bigwin-mega-amount">$0.00</div>
    </div>
    <!-- For regular BIG WIN: shows frame with text inside -->
    <div id="bigwin-frame">
      <div id="bigwin-title">BIG WIN!</div>
      <div id="bigwin-amount">$0.00</div>
    </div>
  </div>

  <!-- Message Popup -->
  <div id="message"></div>

  <!-- Bonus Trigger Overlay -->
  <div id="bonus-trigger-overlay">
    <img src="assets/bonus_trigger.webp" alt="Bonus Triggered!">
    <div class="trigger-loading"><div class="spinner"></div>Loading...</div>
  </div>

  <!-- Backroom Trigger Overlay -->
  <div id="backroom-trigger-overlay">
    <img src="assets/backroom_trigger.webp" alt="The Back Room...">
    <div class="trigger-loading"><div class="spinner"></div>Loading...</div>
  </div>
</div>

<script>
const API = '';
const TOKEN = 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzbG90b3BvbCIsImV4cCI6NDg2NzQ0NzYxNywibmJmIjoxNzA2NjQ3NjE3LCJ1aWQiOjN9.6g2Hig9ErG8IbvzkPppry5F8HJsMunZPwuQzmetGh4c';
const CID = 1, UID = 3;
const GAME_ALIAS = 'megajack/aztecgold';

// Symbol mapping - Aztec Gold symbols mapped to bodega theme
// Aztec Gold: 1-5=low, 6-8=mid, 9=dragon(high), 10=scatter, 11=wild, 12=bonus
const SYMBOLS = {
  1: 'sym_low_cigs.webp',       // Low pay (Tomat)
  2: 'sym_low_newspaper.webp',  // Low pay (Corn)
  3: 'sym_low_candy.webp',      // Low pay (Lama)
  4: 'sym_low_receipt.webp',    // Low pay (Frog)
  5: 'sym_mid_energy.webp',     // Low pay (Jaguar)
  6: 'sym_mid_coffee.webp',     // Medium pay (Condor)
  7: 'sym_mid_ramen.webp',      // Medium pay (Queen)
  8: 'sym_mid_hotdog.webp',     // Medium pay (King)
  9: 'sym_high_clerk.webp',     // HIGH PAY - Dragon equivalent (10,000x!)
  10: 'sym_high_lotto.webp',    // SCATTER - gives scatter pays (lotto ticket)
  11: 'sym_wild_cat.webp',      // WILD - substitutes on reels 2,3,4
  12: 'sym_scatter_key.webp',   // BONUS - triggers bonus on reels 3,4,5 (THE KEY!)
};

// Special symbol IDs for effects
const SYM_SCATTER = 10;  // Lotto ticket - scatter pays
const SYM_WILD = 11;     // Cat - wild substitute
const SYM_BONUS = 12;    // KEY - triggers bonus game on reels 3,4,5!
const SYM_DRAGON = 9;    // Clerk - highest payout

// Pick items for bonus
const PICK_ITEMS_L1 = ['pick_bag.webp','pick_can.webp','pick_vhs.webp','pick_box.webp','pick_envelope.webp','pick_pills.webp'];
const PICK_ITEMS_L2 = ['pick_box.webp','pick_crate.webp','pick_freezer.webp','pick_tv.webp','pick_newspapers.webp'];

let gid = null;
let balance = 0;
let totalBet = 0.21;
let currentScreen = null; // Store current screen for win validation
let betLevels = [0.21, 0.42, 1.05, 2.10, 4.20, 10.50, 21.00];
let betIdx = 0;
let spinning = false;
let autoSpin = false;
let soundEnabled = true;
let inBonus = false;
let bonusLevel = 1;
let bonusPicks = 3;
let bonusWin = 0;

// Audio
let ambientAudio = null;
let rainAudio = null;
let currentMusic = null;
let doorChimeAudio = null;
let scratchAudio = null;  // Preloaded for instant playback
let audioInitialized = false;

// Scratch ticket state
let scratchPrizes = [];
let scratchesUsed = 0;
const MAX_SCRATCHES = 3;

// DOM elements
let elReels, elBalance, elWin, elBet, elSpinBtn, elAutoBtn;
let elBonusScreen, elPickGrid, elBonusWin, elBonusInfo, elCollectBtn, elBonusTitle, elBonusSub;
let elBigwin, elBigwinAmt, elWinLines, elBonusTrigger, elBackroomTrigger;
let elMessage, elWinDisplay, elLoading;
const PAYLINES = 21;

// Aztec Gold 21 paylines from slotopol BetLinesCT5x3
// Source uses 1-indexed rows (1=top, 2=mid, 3=bot), converted to 0-indexed here
// Rows: 0=top, 1=middle, 2=bottom
const PAYLINE_PATTERNS = [
  [1,1,1,1,1], // Line 1:  {2,2,2,2,2} middle row
  [0,0,0,0,0], // Line 2:  {1,1,1,1,1} top row
  [2,2,2,2,2], // Line 3:  {3,3,3,3,3} bottom row
  [0,1,2,1,0], // Line 4:  {1,2,3,2,1} V shape
  [2,1,0,1,2], // Line 5:  {3,2,1,2,3} inverted V
  [0,0,1,2,2], // Line 6:  {1,1,2,3,3} descending
  [2,2,1,0,0], // Line 7:  {3,3,2,1,1} ascending
  [1,0,1,2,1], // Line 8:  {2,1,2,3,2} wave down-up
  [1,2,1,0,1], // Line 9:  {2,3,2,1,2} wave up-down
  [0,1,0,1,0], // Line 10: {1,2,1,2,1} zigzag top
  [2,1,2,1,2], // Line 11: {3,2,3,2,3} zigzag bottom
  [0,1,1,1,1], // Line 12: {1,2,2,2,2} top then mid
  [2,1,1,1,1], // Line 13: {3,2,2,2,2} bot then mid
  [1,1,0,0,0], // Line 14: {2,2,1,1,1} mid then top
  [1,1,2,2,2], // Line 15: {2,2,3,3,3} mid then bot
  [1,0,0,0,0], // Line 16: {2,1,1,1,1} start mid, go top
  [1,2,2,2,2], // Line 17: {2,3,3,3,3} start mid, go bot
  [0,0,0,0,1], // Line 18: {1,1,1,1,2} top then mid end
  [2,2,2,2,1], // Line 19: {3,3,3,3,2} bot then mid end
  [2,2,1,2,2], // Line 20: {3,3,2,3,3} dip in middle bot
  [0,0,1,0,0], // Line 21: {1,1,2,1,1} bump in middle top
];

document.addEventListener('DOMContentLoaded', init);

// ============ INTRO VIDEO HANDLING ============
async function handleIntroVideo() {
  const introOverlay = document.getElementById('intro-overlay');
  const introVideo = document.getElementById('intro-video');
  const introStatic = document.getElementById('intro-static');
  const introRgb = document.getElementById('intro-rgb');
  const introScanlines = document.getElementById('intro-scanlines');
  const introFlash = document.getElementById('intro-flash');

  // Check if intro already played this session
  if (sessionStorage.getItem('intro_played')) {
    introOverlay.classList.add('hidden');
    return;
  }

  // Show intro overlay
  introOverlay.classList.remove('hidden');

  // Activate all VHS glitch layers
  const activateVhsTransition = () => {
    introStatic.classList.add('active');
    introRgb.classList.add('active');
    introScanlines.classList.add('active');
    introFlash.classList.add('active');

    // After VHS transition (1s), hide intro and reveal game
    setTimeout(() => {
      introOverlay.classList.add('hidden');
      sessionStorage.setItem('intro_played', 'true');
    }, 1000);
  };

  return new Promise((resolve) => {
    // Try to play video
    introVideo.muted = true; // Start muted to allow autoplay
    introVideo.play().then(() => {
      // Play door chime sound when video starts
      const chime = new Audio('assets/door_chime.mp3');
      chime.volume = 0.5;
      chime.play().catch(() => {});

      // When video ends, show VHS static transition
      introVideo.addEventListener('ended', () => {
        activateVhsTransition();
        setTimeout(resolve, 1000);
      });

      // Fallback timeout in case video is long or doesn't end properly
      setTimeout(() => {
        if (!introOverlay.classList.contains('hidden')) {
          activateVhsTransition();
          setTimeout(resolve, 1000);
        }
      }, 15000); // 15 second max

    }).catch(() => {
      // Video failed to play - skip intro
      console.log('Intro video failed to play, skipping...');
      introOverlay.classList.add('hidden');
      sessionStorage.setItem('intro_played', 'true');
      resolve();
    });
  });
}

async function init() {
  console.log('Initializing 3AM Bodega...');

  // Handle intro video (plays once per session)
  await handleIntroVideo();

  elReels = document.getElementById('reels-container');
  elBalance = document.getElementById('balance');
  elWin = document.getElementById('win');
  elBet = document.getElementById('bet-val');
  elSpinBtn = document.getElementById('spin-btn');
  elAutoBtn = document.getElementById('auto-btn');
  elBonusScreen = document.getElementById('bonus-screen');
  elPickGrid = document.getElementById('pick-grid');
  elBonusWin = document.getElementById('bonus-win');
  elBonusInfo = document.getElementById('bonus-info');
  elCollectBtn = document.getElementById('collect-btn');
  elBonusTitle = document.getElementById('bonus-title');
  elBonusSub = document.getElementById('bonus-subtitle');
  elBigwin = document.getElementById('bigwin-overlay');
  elBigwinAmt = document.getElementById('bigwin-amount');
  elWinLines = document.getElementById('win-lines');
  elBonusTrigger = document.getElementById('bonus-trigger-overlay');
  elBackroomTrigger = document.getElementById('backroom-trigger-overlay');
  elMessage = document.getElementById('message');
  elWinDisplay = document.getElementById('win-display');
  elLoading = document.getElementById('loading-screen');

  buildReels();

  elSpinBtn.addEventListener('click', spin);
  elAutoBtn.addEventListener('click', toggleAuto);
  document.getElementById('bet-up').addEventListener('click', () => changeBet(1));
  document.getElementById('bet-down').addEventListener('click', () => changeBet(-1));
  document.getElementById('sound-toggle').addEventListener('click', toggleSound);
  elCollectBtn.addEventListener('click', collectBonus);
  document.addEventListener('click', initAudio, { once: true });

  // Preload trigger images so they appear instantly when bonus is triggered
  preloadImage('assets/bonus_trigger.webp');
  preloadImage('assets/backroom_trigger.webp');

  try {
    console.log('Joining game...');
    const res = await apiPost('/game/new', { cid: CID, uid: UID, alias: GAME_ALIAS });
    console.log('Join response:', res);
    
    if (res.gid) {
      gid = res.gid;
      balance = res.wallet || 10000;
      
      // Initialize bet display (use first bet level)
      elBet.textContent = formatBet(totalBet);
      
      if (res.game && res.game.scr) {
        displayScreen(res.game.scr);
      }
      
      updateUI();
      hideLoading();
      console.log('Game ready! GID:', gid);
    } else {
      showMessage('Failed to start game');
      console.error('No GID in response');
    }
  } catch (e) {
    console.error('Init error:', e);
    showMessage('Connection error: ' + e.message);
  }
}

function hideLoading() {
  elLoading.classList.add('hidden');
  setTimeout(() => elLoading.style.display = 'none', 500);
}

const REEL_SYMBOLS = 6; // Symbols per reel strip (3 visible + 3 for scrolling)

function buildReels() {
  elReels.innerHTML = '';
  for (let col = 0; col < 5; col++) {
    const reelCol = document.createElement('div');
    reelCol.className = 'reel-col';
    reelCol.dataset.col = col;

    const reelStrip = document.createElement('div');
    reelStrip.className = 'reel-strip';

    for (let row = 0; row < REEL_SYMBOLS; row++) {
      const cell = document.createElement('div');
      cell.className = 'sym-cell';
      const symId = Math.floor(Math.random() * 12) + 1;
      cell.style.backgroundImage = `url('assets/${SYMBOLS[symId]}')`;
      reelStrip.appendChild(cell);
    }

    // Add expanding wild overlay (for reel-wild animation)
    const wildOverlay = document.createElement('div');
    wildOverlay.className = 'expanding-wild-overlay';
    wildOverlay.innerHTML = '<div class="wild-cell"></div><div class="wild-cell"></div><div class="wild-cell"></div>';

    reelCol.appendChild(reelStrip);
    reelCol.appendChild(wildOverlay);
    elReels.appendChild(reelCol);
  }

  requestAnimationFrame(setupReelSizes);
}

function setupReelSizes() {
  const cols = elReels.querySelectorAll('.reel-col');
  cols.forEach(col => {
    const colHeight = col.offsetHeight;
    const cellHeight = Math.floor(colHeight / 3);

    // Set CSS variable for animation
    col.style.setProperty('--cell-height', `${cellHeight}px`);

    const cells = col.querySelectorAll('.sym-cell');
    cells.forEach(cell => {
      cell.style.height = `${cellHeight}px`;
    });
  });
}

window.addEventListener('resize', () => {
  if (!spinning) setupReelSizes();
});

function displayScreen(screen) {
  if (!screen) return;
  const cols = elReels.querySelectorAll('.reel-col');
  cols.forEach((col, c) => {
    const cells = col.querySelectorAll('.sym-cell');
    // Set visible symbols (first 3)
    for (let r = 0; r < 3 && r < cells.length; r++) {
      const symId = screen[c] ? screen[c][r] : 1;
      cells[r].style.backgroundImage = `url('assets/${SYMBOLS[symId] || SYMBOLS[1]}')`;
      // Apply special symbol classes
      applySymbolClass(cells[r], symId);
    }
  });
}

function applySymbolClass(cell, symId) {
  // Remove all special classes first
  cell.classList.remove('wild', 'bonus', 'high-pay');

  // Add appropriate class based on symbol type
  // KEY (12) = BONUS trigger - gets the special glow!
  // CAT (11) = WILD - subtle glow
  // CLERK (9) = HIGH PAY - subtle glow
  // LOTTO (10) = SCATTER - no special effect, just pays
  if (symId === SYM_WILD) {
    cell.classList.add('wild');
  } else if (symId === SYM_BONUS) {
    cell.classList.add('bonus');  // KEY gets the special glow!
  } else if (symId === SYM_DRAGON) {
    cell.classList.add('high-pay');
  }
}

async function spin() {
  if (spinning || inBonus) return;
  if (balance < totalBet) {
    showMessage('Not enough balance!');
    return;
  }

  // Calculate per-line bet for API (totalBet / 21 lines)
  const lineBet = totalBet / PAYLINES;

  spinning = true;
  elSpinBtn.disabled = true;
  elWin.textContent = '$0.00';
  clearWinHighlights();
  playDoorChime();

  const cols = elReels.querySelectorAll('.reel-col');

  // Reset all reels to clean state
  cols.forEach(col => {
    col.classList.remove('spinning', 'stopping');
  });

  // Randomize all symbols for spin illusion
  cols.forEach(col => {
    const cells = col.querySelectorAll('.sym-cell');
    cells.forEach(cell => {
      const symId = Math.floor(Math.random() * 12) + 1;
      cell.style.backgroundImage = `url('assets/${SYMBOLS[symId]}')`;
    });
  });

  // Start all reels spinning
  cols.forEach(col => col.classList.add('spinning'));

  try {
    const res = await apiPost('/slot/spin', { gid, bet: lineBet });

    // DEBUG: Log COMPLETE raw API response
    console.log('=== FULL API RESPONSE ===');
    console.log(JSON.stringify(res, null, 2));

    const screen = res.game ? res.game.scr : res.scr;
    currentScreen = screen; // Store for win validation

    // DEBUG: Log screen from API
    console.log('=== SCREEN FROM API ===');
    if (screen) {
      console.log('res.game.scr:', JSON.stringify(screen));
      console.log('Formatted:', screen.map((col, i) => `R${i+1}:[${col.join(',')}]`).join(' '));
    } else {
      console.log('WARNING: No screen data in response!');
    }

    // Stop reels one by one (left to right)
    for (let i = 0; i < cols.length; i++) {
      await delay(300 + i * 200); // 200ms delay between each reel

      const col = cols[i];
      const cells = col.querySelectorAll('.sym-cell');

      // Set final symbols before stopping
      if (screen && screen[i]) {
        for (let r = 0; r < 3 && r < cells.length; r++) {
          const symId = screen[i][r];
          cells[r].style.backgroundImage = `url('assets/${SYMBOLS[symId] || SYMBOLS[1]}')`;
          applySymbolClass(cells[r], symId);
          // Store the symbol ID on the cell for verification
          cells[r].dataset.symId = symId;
        }
      }

      // Transition from spinning to stopping
      col.classList.remove('spinning');
      col.classList.add('stopping');

      // Remove stopping class after animation completes
      setTimeout(() => col.classList.remove('stopping'), 200);
    }

    // Wait for final reel to settle
    await delay(250);

    // DEBUG: Verify what we ACTUALLY rendered matches API screen
    console.log('=== VERIFICATION: RENDERED vs API ===');
    const renderedScreen = [];
    cols.forEach((col, c) => {
      const cells = col.querySelectorAll('.sym-cell');
      const colSyms = [];
      for (let r = 0; r < 3; r++) {
        colSyms.push(parseInt(cells[r]?.dataset.symId) || '?');
      }
      renderedScreen.push(colSyms);
    });
    console.log('API screen:     ', JSON.stringify(screen));
    console.log('Rendered screen:', JSON.stringify(renderedScreen));

    const matches = JSON.stringify(screen) === JSON.stringify(renderedScreen);
    if (matches) {
      console.log('âœ“ MATCH: Rendered screen matches API screen');
    } else {
      console.log('âœ— MISMATCH: Rendered screen does NOT match API screen!');
      // Show differences
      for (let c = 0; c < 5; c++) {
        for (let r = 0; r < 3; r++) {
          const apiSym = screen[c]?.[r];
          const renderedSym = renderedScreen[c]?.[r];
          if (apiSym !== renderedSym) {
            console.log(`  [${c},${r}] API=${apiSym} but Rendered=${renderedSym}`);
          }
        }
      }
    }

    balance = res.wallet !== undefined ? res.wallet : balance;
    updateUI();

    const totalWin = res.game?.gain || 0;

    // Log wins from API with XY coordinates and validation
    if (res.wins && res.wins.length > 0) {
      console.log('=== WINS ANALYSIS ===');
      res.wins.forEach((w, i) => {
        const symName = SYMBOLS[w.sym] || `sym${w.sym}`;
        console.log(`Win ${i+1}: Line ${w.li || 'SCATTER'}, ${w.num}x Symbol ${w.sym} (${symName}), Pay $${w.pay.toFixed(2)}`);

        let validCount = 0;
        let reelWildPositions = [];

        if (w.xy && w.xy.length > 0) {
          console.log(`  XY positions:`);
          w.xy.forEach((coord, j) => {
            const col = coord[0] - 1;  // Convert to 0-indexed
            const row = coord[1] - 1;
            const actualSym = screen[col] ? screen[col][row] : null;
            const actualName = SYMBOLS[actualSym] || `sym${actualSym}`;

            const isMatch = actualSym === w.sym;
            const isWild = actualSym === SYM_WILD;
            const isValid = isMatch || isWild;

            if (isValid) {
              validCount++;
              const marker = isMatch ? 'âœ“ MATCH' : 'âœ“ WILD';
              console.log(`    [${coord[0]},${coord[1]}] â†’ [${col},${row}] = ${actualSym} (${actualName}) ${marker}`);
            } else {
              // Aztec Gold REEL WILD: Check if there's a wild ANYWHERE on this reel
              // Reels 2,3,4 (col 1,2,3) turn entirely wild if wild exists on any row
              const hasReelWild = col >= 1 && col <= 3 && screen[col] && screen[col].some(s => s === SYM_WILD);
              if (hasReelWild) {
                const wildRow = screen[col].findIndex(s => s === SYM_WILD);
                reelWildPositions.push({ coord, col, row, actualSym, actualName, wildRow });
                console.log(`    [${coord[0]},${coord[1]}] â†’ [${col},${row}] = ${actualSym} (${actualName}) âš¡ REEL WILD (wild at row ${wildRow})`);
              } else {
                console.log(`    [${coord[0]},${coord[1]}] â†’ [${col},${row}] = ${actualSym} (${actualName}) âš ï¸ No match or wild`);
              }
            }
          });

          if (reelWildPositions.length > 0) {
            console.log(`  â„¹ï¸ This win uses ${reelWildPositions.length} REEL WILD position(s) - Aztec Gold feature`);
          }
        } else {
          console.log(`  âš ï¸ No XY data in win object`);
        }
      });
    } else {
      console.log('No wins');
    }

    if (totalWin > 0) {
      // Show individual line wins first, then total
      if (res.wins && res.wins.length > 0) {
        // De-duplicate wins that cover the same positions
        const uniqueWins = deduplicateWins(res.wins);

        await showLineWins(uniqueWins);
        // After showing individual lines, highlight all wins together
        highlightWins(uniqueWins, true);  // drawLines=true for final display
      }
      showWin(totalWin);
      if (totalWin >= totalBet * 15) {
        await showBigWin(totalWin);
      }
    }

    // Check for bonus trigger
    // Count bonus symbols (key=12) on reels 3, 4, 5 (indices 2, 3, 4)
    let bonusCount = 0;
    if (screen) {
      for (let col = 2; col < 5; col++) {
        if (screen[col]) {
          for (let row = 0; row < 3; row++) {
            if (screen[col][row] === SYM_BONUS) bonusCount++;
          }
        }
      }
    }
    console.log('Bonus symbols (key) on reels 3-4-5:', bonusCount, '| API bonus flags - bn:', res.bn, 'bonus:', res.bonus, 'game.bn:', res.game?.bn);

    // Trigger bonus if API says so OR if we detect 3+ bonus symbols on reels 3-4-5
    if (res.bn || res.bonus || res.game?.bn || bonusCount >= 3) {
      console.log('BONUS TRIGGERED!');
      // Show bonus trigger overlay
      await showBonusTrigger();
      startBonus(res);
    }

    spinning = false;
    elSpinBtn.disabled = false;

    if (autoSpin && !inBonus) {
      setTimeout(spin, 1500);
    }

  } catch (e) {
    console.error('Spin error:', e);
    showMessage('Spin failed!');
    spinning = false;
    elSpinBtn.disabled = false;
    cols.forEach(col => col.classList.remove('spinning', 'stopping'));
  }
}

// Preload a single image and return promise when loaded
function preloadImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(url);
    img.onerror = () => resolve(url); // Resolve anyway to not block entirely
    img.src = url;
  });
}

// Preload audio file
function preloadAudio(url) {
  return new Promise((resolve) => {
    const audio = new Audio();
    audio.oncanplaythrough = () => resolve(url);
    audio.onerror = () => resolve(url);
    audio.src = url;
    audio.load();
  });
}

// ALL assets for Level 1 (Behind the Counter)
const BONUS_L1_ASSETS = [
  'assets/ticket.webp',
  'assets/ticket_revealed.webp',
  'assets/sym_scatter_key.webp',
  'assets/bg_bonus1.webp'
];

// ALL assets for Level 2 (Back Room)
const BONUS_L2_ASSETS = [
  'assets/shelf.webp',
  'assets/crate.webp',
  'assets/bg_bonus2.webp'
];

async function showBonusTrigger() {
  elBonusTrigger.classList.add('active');
  playSound('bonus_enter.mp3');

  // Preload ALL Level 1 assets - wait for ACTUAL load, not a timer
  const imagePromises = BONUS_L1_ASSETS.map(url => preloadImage(url));
  const audioPromise = preloadAudio('assets/pick_reveal.mp3');

  // Also ensure minimum 2 second display so player can read
  const minDisplayPromise = delay(2000);

  // Wait for ALL assets AND minimum display time
  await Promise.all([
    ...imagePromises,
    audioPromise,
    minDisplayPromise
  ]);

  elBonusTrigger.classList.remove('active');
}

async function showBackroomTrigger() {
  elBackroomTrigger.classList.add('active');
  playSound('bonus_enter.mp3');

  // Preload ALL Level 2 assets - wait for ACTUAL load, not a timer
  const imagePromises = BONUS_L2_ASSETS.map(url => preloadImage(url));
  const audioPromise = preloadAudio('assets/pick_reveal.mp3');

  // Also ensure minimum 2 second display so player can read
  const minDisplayPromise = delay(2000);

  // Wait for ALL assets AND minimum display time
  await Promise.all([
    ...imagePromises,
    audioPromise,
    minDisplayPromise
  ]);

  elBackroomTrigger.classList.remove('active');
}

// ============ SCRATCH TICKET FUNCTIONS ============

// Original image dimensions and cell coordinates
const TICKET_ORIG_WIDTH = 1104;
const TICKET_ORIG_HEIGHT = 1871;
const CELL_ORIG_WIDTH = 266;
const CELL_ORIG_HEIGHT = 177;
const CELL_BORDER_RADIUS = 15;

// Cell positions (x, y top-left corner) - 12 cells in 4 rows x 3 cols
// Calculated from center positions: topLeftX = centerX - 133, topLeftY = centerY - 88.5
const CELL_POSITIONS = [
  // Row 1: centers (200, 786), (555, 786), (888, 786)
  { x: 67, y: 697.5 },  { x: 422, y: 697.5 },  { x: 755, y: 697.5 },
  // Row 2: centers (200, 1036), (555, 1036), (888, 1036)
  { x: 67, y: 947.5 },  { x: 422, y: 947.5 },  { x: 755, y: 947.5 },
  // Row 3: centers (200, 1290), (555, 1290), (888, 1290)
  { x: 67, y: 1201.5 }, { x: 422, y: 1201.5 }, { x: 755, y: 1201.5 },
  // Row 4: centers (200, 1545), (555, 1545), (888, 1545)
  { x: 67, y: 1456.5 }, { x: 422, y: 1456.5 }, { x: 755, y: 1456.5 }
];

function setupScratchTicket() {
  const scratchCells = document.getElementById('scratch-cells');
  const ticketImg = document.getElementById('ticket-base');
  scratchCells.innerHTML = '';
  scratchesUsed = 0;

  // Wait for image to load to get actual dimensions
  const positionCells = () => {
    const displayedHeight = ticketImg.offsetHeight;
    const displayedWidth = ticketImg.offsetWidth;
    const scaleRatio = displayedHeight / TICKET_ORIG_HEIGHT;

    // Set scratch-cells container to match image size exactly
    scratchCells.style.width = displayedWidth + 'px';
    scratchCells.style.height = displayedHeight + 'px';

    // Calculate scaled cell dimensions
    const cellWidth = CELL_ORIG_WIDTH * scaleRatio;
    const cellHeight = CELL_ORIG_HEIGHT * scaleRatio;
    const borderRadius = CELL_BORDER_RADIUS * scaleRatio;

    // Position each cell
    CELL_POSITIONS.forEach((pos, idx) => {
      const cell = scratchCells.children[idx];
      if (cell) {
        const scaledX = pos.x * scaleRatio;
        const scaledY = pos.y * scaleRatio;

        cell.style.left = scaledX + 'px';
        cell.style.top = scaledY + 'px';
        cell.style.width = cellWidth + 'px';
        cell.style.height = cellHeight + 'px';
        cell.style.borderRadius = borderRadius + 'px';

        // Also update border-radius on ::before via CSS variable
        cell.style.setProperty('--cell-radius', borderRadius + 'px');

        // Update prize content border-radius
        const prizeContent = cell.querySelector('.prize-content');
        if (prizeContent) {
          prizeContent.style.borderRadius = borderRadius + 'px';
        }
      }
    });
  };

  // Generate 12 prizes (3 cols x 4 rows)
  scratchPrizes = [];
  const baseMults = [2, 3, 5, 8, 10, 15, 20, 25];

  for (let i = 0; i < 12; i++) {
    const roll = Math.random();
    if (roll < 0.08) {
      // ~8% chance for KEY to backroom
      scratchPrizes.push({ type: 'key', value: 0 });
    } else {
      // Prize multiplier
      const mult = baseMults[Math.floor(Math.random() * baseMults.length)];
      scratchPrizes.push({ type: 'prize', value: mult * totalBet });
    }
  }

  // Ensure at least one KEY exists
  if (!scratchPrizes.some(p => p.type === 'key')) {
    const randomIdx = Math.floor(Math.random() * 12);
    scratchPrizes[randomIdx] = { type: 'key', value: 0 };
  }

  // Shuffle prizes
  shuffleArray(scratchPrizes);

  // Create scratch cells
  scratchPrizes.forEach((prize, idx) => {
    const cell = document.createElement('div');
    cell.className = 'scratch-cell';
    cell.dataset.idx = idx;

    // Prize content underneath the scratch overlay
    const prizeContent = document.createElement('div');
    prizeContent.className = 'prize-content';
    if (prize.type === 'key') {
      prizeContent.classList.add('key-prize');
      prizeContent.innerHTML = `<img src="assets/sym_scatter_key.webp" style="width:50%;height:auto;"><div class="prize-amount">KEY!</div>`;
    } else {
      prizeContent.innerHTML = `<div class="prize-amount">+$${prize.value.toFixed(2)}</div>`;
    }
    cell.appendChild(prizeContent);

    cell.addEventListener('click', () => scratchCell(cell, idx));
    scratchCells.appendChild(cell);
  });

  // Position cells after creation
  if (ticketImg.complete) {
    positionCells();
  } else {
    ticketImg.onload = positionCells;
  }

  // Reposition on window resize (remove old listener first to prevent duplicates)
  if (window._scratchResizeHandler) {
    window.removeEventListener('resize', window._scratchResizeHandler);
  }
  window._scratchResizeHandler = positionCells;
  window.addEventListener('resize', positionCells);
}

function createScratchParticles(cell) {
  const rect = cell.getBoundingClientRect();
  const particleCount = 8;

  for (let i = 0; i < particleCount; i++) {
    const particle = document.createElement('div');
    particle.className = 'scratch-particle';

    // Start from center of cell
    const startX = rect.left + rect.width / 2;
    const startY = rect.top + rect.height / 2;

    particle.style.left = startX + 'px';
    particle.style.top = startY + 'px';
    particle.style.position = 'fixed';

    // Random outward direction
    const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
    const distance = 30 + Math.random() * 40;
    const endX = Math.cos(angle) * distance;
    const endY = Math.sin(angle) * distance;

    document.body.appendChild(particle);

    // Animate particle
    particle.animate([
      { transform: 'translate(0, 0) scale(1)', opacity: 1 },
      { transform: `translate(${endX}px, ${endY}px) scale(0.3)`, opacity: 0 }
    ], {
      duration: 400,
      easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
    }).onfinish = () => particle.remove();
  }
}

async function scratchCell(cell, idx) {
  if (cell.classList.contains('scratched') || scratchesUsed >= MAX_SCRATCHES || pickLocked) return;

  // Play scratch sound IMMEDIATELY using preloaded audio
  if (scratchAudio && soundEnabled) {
    scratchAudio.currentTime = 0;
    scratchAudio.play().catch(() => {});
  }

  pickLocked = true;
  scratchesUsed++;

  // Create particle debris
  createScratchParticles(cell);

  // Reveal the cell (trigger CSS animation)
  cell.classList.add('scratched');

  const prize = scratchPrizes[idx];

  // 0.5s pause before allowing next pick
  await delay(500);

  if (prize.type === 'key') {
    // KEY TO BACK ROOM
    playSound('bonus_enter.mp3');

    // Pause to let player see the KEY (2 seconds)
    await delay(2000);

    // Transition to Level 2 - assets preloaded during trigger overlay
    await showBackroomTrigger();

    // Hide crate shelf until setup complete
    const crateShelf = document.getElementById('crate-shelf');
    crateShelf.style.opacity = '0';

    // Switch to Level 2 (this changes background via CSS)
    bonusLevel = 2;
    bonusPicks = 3;
    cratesOpened = 0;
    elBonusScreen.classList.add('level2');
    elBonusTitle.textContent = 'THE BACK ROOM';
    elBonusSub.textContent = "Pick 3 crates...";

    // Force repaint to ensure new background is rendered
    void elBonusScreen.offsetHeight;
    await delay(100);

    // Set up crate shelf
    setupCrateShelf();
    updateBonusUI();

    // Fade in the crate shelf
    crateShelf.style.transition = 'opacity 0.3s ease-out';
    crateShelf.style.opacity = '1';
    pickLocked = false;

  } else {
    // Prize found
    bonusWin += prize.value;
    updateBonusUI();
    pickLocked = false;
  }

  // Check if all scratches used (and no key found)
  if (scratchesUsed >= MAX_SCRATCHES && prize.type !== 'key') {
    await delay(500);
    elCollectBtn.style.display = 'block';
  }
}

async function startBonus(spinRes) {
  inBonus = true;
  bonusLevel = 1;
  bonusPicks = 3;
  bonusWin = 0;
  pickLocked = false;
  scratchesUsed = 0;

  // Assets were preloaded during showBonusTrigger - now show the bonus screen

  // Ensure scratch ticket element is hidden until we set it up
  const scratchTicket = document.getElementById('scratch-ticket');
  scratchTicket.style.opacity = '0';

  // Set up the bonus screen state (background is in CSS, already preloaded)
  elBonusScreen.classList.remove('level2');
  elBonusScreen.classList.add('active');
  elBonusTitle.textContent = 'BEHIND THE COUNTER';
  elBonusSub.textContent = 'Scratch 3 spots to reveal prizes...';
  elCollectBtn.style.display = 'none';
  elPickGrid.innerHTML = '';

  // Force a repaint to ensure background is rendered
  void elBonusScreen.offsetHeight;

  // Brief pause to let background render
  await delay(100);

  // Now set up scratch ticket
  setupScratchTicket();
  updateBonusUI();

  // Fade in the scratch ticket
  scratchTicket.style.transition = 'opacity 0.3s ease-out';
  scratchTicket.style.opacity = '1';
}

function setupPickGrid() {
  const items = bonusLevel === 1 ? PICK_ITEMS_L1 : PICK_ITEMS_L2;
  const gridSize = bonusLevel === 1 ? 12 : 10;
  
  elPickGrid.innerHTML = '';
  
  const pickItems = [];
  for (let i = 0; i < gridSize; i++) {
    pickItems.push(items[i % items.length]);
  }
  shuffleArray(pickItems);
  
  const prizes = generatePrizes(gridSize, bonusLevel);
  
  pickItems.forEach((item, idx) => {
    const div = document.createElement('div');
    div.className = 'pick-item';
    div.style.backgroundImage = `url(assets/${item})`;
    div.dataset.prize = prizes[idx].value;
    div.dataset.type = prizes[idx].type;
    div.addEventListener('click', () => pickItem(div));
    elPickGrid.appendChild(div);
  });
}

function generatePrizes(count, level) {
  const prizes = [];
  const baseMult = level === 1 ? [2,5,10,15,20,25] : [20,30,50,75,100,150];

  for (let i = 0; i < count; i++) {
    const roll = Math.random();
    if (level === 1 && roll < 0.08) {
      prizes.push({ type: 'key2', value: 0 });
    } else if (roll < 0.1) {
      prizes.push({ type: 'end', value: 0 });
    } else {
      const mult = baseMult[Math.floor(Math.random() * baseMult.length)];
      prizes.push({ type: 'coin', value: mult * totalBet });
    }
  }

  if (level === 1 && !prizes.some(p => p.type === 'key2')) {
    prizes[Math.floor(Math.random() * count)] = { type: 'key2', value: 0 };
  }

  return prizes;
}

// ============ CRATE SHELF SETUP (Level 2) ============
const SHELF_ORIG_WIDTH = 1266;
const SHELF_ORIG_HEIGHT = 700;
const CRATE_WIDTH = 189;
const CRATE_HEIGHT = 117;

// Crate CENTER positions (10 crates total)
const CRATE_POSITIONS = [
  // Row 1 (y=200): 2 left, 1 right
  { x: 220, y: 200 }, { x: 450, y: 200 }, { x: 900, y: 200 },
  // Row 2 (y=385): 2 left, 2 right
  { x: 220, y: 385 }, { x: 450, y: 385 }, { x: 750, y: 385 }, { x: 1000, y: 385 },
  // Row 3 (y=568): 1 left, 2 right
  { x: 350, y: 568 }, { x: 750, y: 568 }, { x: 1000, y: 568 }
];

let cratePrizes = [];
let cratesOpened = 0;
const MAX_CRATES = 3;

function setupCrateShelf() {
  const crateContainer = document.getElementById('crate-container');
  const shelfImg = document.getElementById('shelf-bg');
  crateContainer.innerHTML = '';
  cratesOpened = 0;

  const positionCrates = () => {
    const displayedHeight = shelfImg.offsetHeight;
    const displayedWidth = shelfImg.offsetWidth;
    const scaleRatio = displayedHeight / SHELF_ORIG_HEIGHT;

    // Set container to match shelf size
    crateContainer.style.width = displayedWidth + 'px';
    crateContainer.style.height = displayedHeight + 'px';

    const crateW = CRATE_WIDTH * scaleRatio;
    const crateH = CRATE_HEIGHT * scaleRatio;

    // Position each crate
    CRATE_POSITIONS.forEach((pos, idx) => {
      const crate = crateContainer.children[idx];
      if (crate) {
        // Convert center to top-left
        const topLeftX = (pos.x - CRATE_WIDTH / 2) * scaleRatio;
        const topLeftY = (pos.y - CRATE_HEIGHT / 2) * scaleRatio;

        crate.style.left = topLeftX + 'px';
        crate.style.top = topLeftY + 'px';
        crate.style.width = crateW + 'px';
        crate.style.height = crateH + 'px';
      }
    });
  };

  // Generate prizes for 10 crates
  cratePrizes = [];
  const baseMults = [20, 30, 50, 75, 100, 150];

  for (let i = 0; i < 10; i++) {
    const roll = Math.random();
    if (roll < 0.1) {
      // 10% chance for END
      cratePrizes.push({ type: 'end', value: 0 });
    } else {
      const mult = baseMults[Math.floor(Math.random() * baseMults.length)];
      cratePrizes.push({ type: 'coin', value: mult * totalBet });
    }
  }
  shuffleArray(cratePrizes);

  // Create crate elements
  CRATE_POSITIONS.forEach((pos, idx) => {
    const crate = document.createElement('div');
    crate.className = 'crate';
    crate.dataset.idx = idx;
    crate.addEventListener('click', () => openCrate(crate, idx));
    crateContainer.appendChild(crate);
  });

  // Position crates after creation
  if (shelfImg.complete) {
    positionCrates();
  } else {
    shelfImg.onload = positionCrates;
  }

  // Reposition on window resize
  if (window._crateResizeHandler) {
    window.removeEventListener('resize', window._crateResizeHandler);
  }
  window._crateResizeHandler = positionCrates;
  window.addEventListener('resize', positionCrates);
}

async function openCrate(crate, idx) {
  if (crate.classList.contains('opened') || cratesOpened >= MAX_CRATES || pickLocked) return;

  // Play crate open sound immediately
  playSound('pick_reveal.mp3');

  pickLocked = true;
  cratesOpened++;

  // Shake animation
  crate.classList.add('shaking');
  await delay(400);
  crate.classList.remove('shaking');

  // Open animation
  crate.classList.add('opened');

  const prize = cratePrizes[idx];

  // Create floating prize text
  const prizeEl = document.createElement('div');
  prizeEl.className = 'crate-prize';
  if (prize.type === 'end') {
    prizeEl.classList.add('end-prize');
    prizeEl.textContent = 'END';
  } else {
    prizeEl.textContent = '+$' + prize.value.toFixed(2);
    bonusWin += prize.value;
  }

  // Position at crate center
  const crateRect = crate.getBoundingClientRect();
  const containerRect = crate.parentElement.getBoundingClientRect();
  prizeEl.style.left = (crateRect.left - containerRect.left + crateRect.width / 2) + 'px';
  prizeEl.style.top = (crateRect.top - containerRect.top + crateRect.height / 2) + 'px';
  prizeEl.style.transform = 'translateX(-50%)';
  crate.parentElement.appendChild(prizeEl);

  // Remove prize element after animation
  setTimeout(() => prizeEl.remove(), 1500);

  updateBonusUI();

  await delay(600);
  pickLocked = false;

  if (prize.type === 'end') {
    // End bonus early
    showMessage('The clerk heard you...');
    cratesOpened = MAX_CRATES;
    await delay(1500);
    elCollectBtn.style.display = 'block';
  } else if (cratesOpened >= MAX_CRATES) {
    await delay(500);
    elCollectBtn.style.display = 'block';
  }
}

let pickLocked = false; // Prevent rapid clicking during animations

async function pickItem(el) {
  if (el.classList.contains('revealed') || bonusPicks <= 0 || pickLocked) return;

  pickLocked = true; // Lock picks during reveal animation

  el.classList.add('revealed');
  bonusPicks--;

  const type = el.dataset.type;
  const value = parseInt(el.dataset.prize) || 0;

  playSound('pick_reveal.mp3');

  if (type === 'key2' && bonusLevel === 1) {
    // KEY TO BACK ROOM - Show clearly with golden glow
    el.classList.add('key-reveal');
    el.style.backgroundImage = 'url(assets/sym_scatter_key.webp)';
    el.style.backgroundSize = '60% 60%';

    // Add "KEY!" label
    const label = document.createElement('div');
    label.className = 'prize-label';
    label.style.color = '#FFD700';
    label.textContent = 'ðŸ”‘ KEY!';
    el.appendChild(label);

    // Pause so player sees the key (2 seconds)
    await delay(2000);

    // Show backroom trigger overlay then transition
    await showBackroomTrigger();

    // Hide crate shelf until setup complete
    const crateShelf = document.getElementById('crate-shelf');
    crateShelf.style.opacity = '0';

    // Switch to Level 2 (this changes background via CSS)
    bonusLevel = 2;
    bonusPicks = 3;
    cratesOpened = 0;
    elBonusScreen.classList.add('level2');
    elBonusTitle.textContent = 'THE BACK ROOM';
    elBonusSub.textContent = "Pick 3 crates...";

    // Force repaint to ensure new background is rendered
    void elBonusScreen.offsetHeight;
    await delay(100);

    // Set up crate shelf
    setupCrateShelf();
    updateBonusUI();

    // Fade in the crate shelf
    crateShelf.style.transition = 'opacity 0.3s ease-out';
    crateShelf.style.opacity = '1';
    pickLocked = false;

  } else if (type === 'end') {
    // END GAME - Clerk returning
    el.style.backgroundImage = 'url(assets/pick_tv.webp)';
    el.style.filter = 'brightness(1) hue-rotate(180deg)';

    const label = document.createElement('div');
    label.className = 'prize-label';
    label.style.color = '#FF6B9D';
    label.textContent = 'END';
    el.appendChild(label);

    await delay(1000);
    showMessage('The clerk is coming back...');
    bonusPicks = 0;

    await delay(1500);
    elCollectBtn.style.display = 'block';
    pickLocked = false;

  } else {
    // PRIZE - Show multiplier/value with animation
    el.classList.add('prize-reveal');
    el.style.backgroundImage = 'url(assets/pick_coin.webp)';

    // Add prize label showing the amount
    const label = document.createElement('div');
    label.className = 'prize-label';
    label.textContent = '+$' + value.toFixed(2);
    el.appendChild(label);

    bonusWin += value;
    updateBonusUI();

    // Pause so player sees the prize (1.5 seconds)
    await delay(1500);
    pickLocked = false;
  }

  if (bonusPicks <= 0 && type !== 'key2') {
    await delay(500);
    elCollectBtn.style.display = 'block';
  }

  updateBonusUI();
}

function updateBonusUI() {
  elBonusWin.textContent = '$' + bonusWin.toFixed(2);
  // Level 1 uses scratches, Level 2 uses crates
  if (bonusLevel === 1) {
    const remaining = MAX_SCRATCHES - scratchesUsed;
    elBonusInfo.textContent = `Scratches remaining: ${remaining}`;
  } else {
    const remaining = MAX_CRATES - cratesOpened;
    elBonusInfo.textContent = `Crates remaining: ${remaining}`;
  }
}

async function collectBonus() {
  const winAmount = bonusWin;
  balance += winAmount;
  inBonus = false;

  // Fade out bonus screen
  elBonusScreen.style.transition = 'opacity 0.5s';
  elBonusScreen.style.opacity = '0';
  await delay(500);

  elBonusScreen.classList.remove('active', 'level2');
  elBonusScreen.style.transition = '';
  elBonusScreen.style.opacity = '';

  updateUI();

  // Show big win for ANY bonus win above 15x bet, otherwise regular win
  if (winAmount >= totalBet * 15) {
    await showBigWin(winAmount);
  } else if (winAmount > 0) {
    showWin(winAmount);
  }
}

function highlightWins(wins, drawLines = false) {
  if (!wins) return;
  const cols = elReels.querySelectorAll('.reel-col');

  // Collect all reels that need expanding wild for final display
  const allExpandingReels = new Set();

  wins.forEach(win => {
    // Only process valid wins with payout
    if (!win.pay || win.pay <= 0) return;

    const { positions, reelWildPositions } = getWinPositions(win, cols, currentScreen);
    if (positions.length === 0) return;

    const isScatterWin = !win.li;

    // Track reels using reel-wild for expanding display
    if (!isScatterWin) {
      reelWildPositions.forEach(pos => {
        allExpandingReels.add(pos.col);
      });
    }

    // Highlight main winning positions (on the payline)
    positions.forEach(pos => {
      if (cols[pos.col]) {
        // If this reel has expanding wild, we still highlight but the overlay adds extra visual
        const cells = cols[pos.col].querySelectorAll('.sym-cell');
        if (cells[pos.row]) {
          cells[pos.row].classList.add('winner');
          if (isScatterWin) cells[pos.row].classList.add('scatter-win');
        }
      }
    });

    // Only draw lines for regular payline wins (not scatter)
    if (drawLines && !isScatterWin) {
      drawWinLine(positions, win.li);
    }
  });

  // Show expanding wilds for all reels that use reel-wild feature
  allExpandingReels.forEach(colIdx => {
    showExpandingWild(colIdx);
  });
}

function clearWinHighlights() {
  elReels.querySelectorAll('.sym-cell.winner').forEach(el => {
    el.classList.remove('winner', 'scatter-win', 'reel-wild-contributor');
  });
  clearWinLines();
  hideExpandingWilds();
}

// Show expanding wild animation on a reel (cat fills all 3 rows)
function showExpandingWild(colIndex) {
  const cols = elReels.querySelectorAll('.reel-col');
  if (cols[colIndex]) {
    const overlay = cols[colIndex].querySelector('.expanding-wild-overlay');
    if (overlay) {
      cols[colIndex].classList.add('expanding-wild');
      overlay.classList.add('active');
    }
  }
}

// Hide all expanding wild overlays
function hideExpandingWilds() {
  elReels.querySelectorAll('.reel-col').forEach(col => {
    col.classList.remove('expanding-wild');
    const overlay = col.querySelector('.expanding-wild-overlay');
    if (overlay) {
      overlay.classList.remove('active');
    }
  });
}

async function showLineWins(wins) {
  if (!wins || wins.length === 0) return;

  const cols = elReels.querySelectorAll('.reel-col');

  for (const win of wins) {
    // Only process valid wins with actual payout
    if (!win.pay || win.pay <= 0) continue;

    // Clear previous highlights and lines for this iteration
    clearWinHighlights();

    // Get positions to highlight (only for valid wins)
    const { positions, reelWildPositions } = getWinPositions(win, cols, currentScreen);

    // Skip if no valid positions
    if (positions.length === 0) continue;

    // Check if this is a scatter win (no line number)
    const isScatterWin = !win.li;

    // Show EXPANDING WILD animation for reels using reel-wild feature
    // This visually shows the cat filling the entire reel before drawing win line
    const expandingReels = new Set();
    if (reelWildPositions.length > 0 && !isScatterWin) {
      reelWildPositions.forEach(pos => {
        expandingReels.add(pos.col);
        showExpandingWild(pos.col);
      });
      // Wait for expanding animation to complete
      await delay(450);
    }

    // Highlight winning symbols on the payline
    positions.forEach(pos => {
      if (cols[pos.col]) {
        // If this reel has expanding wild, the overlay handles the visual
        if (!expandingReels.has(pos.col)) {
          const cells = cols[pos.col].querySelectorAll('.sym-cell');
          if (cells[pos.row]) {
            cells[pos.row].classList.add('winner');
            // Add scatter-specific highlight class
            if (isScatterWin) cells[pos.row].classList.add('scatter-win');
          }
        }
      }
    });

    // Only draw line for regular payline wins (not scatter)
    if (!isScatterWin) {
      drawWinLine(positions, win.li);
    }

    // Show win amount popup with symbol name
    const symName = getSymbolDisplayName(win.sym);
    const winLabel = isScatterWin
      ? `${symName} x${win.num} +$`
      : `${symName} x${win.num} +$`;
    elWinDisplay.textContent = `${winLabel}${win.pay.toFixed(2)}`;
    elWinDisplay.classList.add('show');
    playSound('pick_reveal.mp3');
    await delay(500);
    elWinDisplay.classList.remove('show');
    await delay(100);
  }

  // Clear after showing individual lines - highlightWins will redraw all
  clearWinHighlights();
}

// De-duplicate wins that cover the exact same symbol positions
function deduplicateWins(wins) {
  if (!wins || wins.length <= 1) return wins;

  const seen = new Set();
  const unique = [];

  for (const win of wins) {
    // Create a key from the XY positions
    let key;
    if (win.xy && win.xy.length > 0) {
      key = win.xy.map(c => `${c[0]},${c[1]}`).sort().join('|');
    } else if (win.li && win.num) {
      // Use payline pattern to generate key
      const lineIdx = win.li - 1;
      const pattern = PAYLINE_PATTERNS[lineIdx];
      if (pattern) {
        const coords = [];
        for (let c = 0; c < win.num && c < 5; c++) {
          coords.push(`${c},${pattern[c]}`);
        }
        key = coords.sort().join('|');
      }
    }

    if (key && !seen.has(key)) {
      seen.add(key);
      unique.push(win);
    } else if (!key) {
      // If we can't generate a key, include the win anyway
      unique.push(win);
    }
  }

  return unique;
}

function getWinPositions(win, cols, screen) {
  const positions = [];
  const reelWildPositions = []; // Track wilds on reel-wild reels

  // Only process if this is a valid win with pay > 0
  if (!win || !win.pay || win.pay <= 0) {
    return { positions, reelWildPositions };
  }

  // Use XY coordinates from API for line positions
  if (win.xy && win.xy.length > 0) {
    win.xy.forEach(coord => {
      // API sends [col, row] as 1-indexed, convert to 0-indexed
      const col = coord[0] - 1;
      const row = coord[1] - 1;
      positions.push({ col, row });

      // Aztec Gold "reel wild": if wild exists ANYWHERE on reels 2,3,4,
      // the entire reel acts as wild. Track these wild positions separately.
      if (screen && screen[col] && col >= 1 && col <= 3) {
        const symAtPos = screen[col][row];
        // If position doesn't have the winning symbol or wild directly,
        // there must be a wild elsewhere on this reel making it act as wild
        if (symAtPos !== win.sym && symAtPos !== SYM_WILD) {
          const wildRow = screen[col].findIndex(s => s === SYM_WILD);
          if (wildRow >= 0 && wildRow !== row) {
            // Found wild elsewhere on this reel - track it for extra highlight
            reelWildPositions.push({ col, row: wildRow });
          }
        }
      }
    });
  }

  return { positions, reelWildPositions };
}

function drawWinLine(positions, lineNum) {
  // Don't draw lines for scatter wins (lineNum undefined or 0) or single symbols
  if (!lineNum || positions.length < 2) return;

  const cols = elReels.querySelectorAll('.reel-col');
  const reelsRect = elReels.parentElement.getBoundingClientRect();

  // Get center points of each winning symbol
  const points = positions.map(pos => {
    if (!cols[pos.col]) return null;
    const cells = cols[pos.col].querySelectorAll('.sym-cell');
    if (!cells[pos.row]) return null;

    const cellRect = cells[pos.row].getBoundingClientRect();
    return {
      x: cellRect.left + cellRect.width / 2 - reelsRect.left,
      y: cellRect.top + cellRect.height / 2 - reelsRect.top
    };
  }).filter(p => p !== null);

  if (points.length < 2) return;

  // Alternate colors based on line number
  const color = lineNum % 2 === 0 ? '#00D4FF' : '#FF6B9D';
  const coreColor = lineNum % 2 === 0 ? '#FFFFFF' : '#FFD4E8';

  // Draw line segments - outer glow first, then bright inner core
  for (let i = 0; i < points.length - 1; i++) {
    // Outer glow line
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', points[i].x);
    line.setAttribute('y1', points[i].y);
    line.setAttribute('x2', points[i + 1].x);
    line.setAttribute('y2', points[i + 1].y);
    line.style.stroke = color;
    elWinLines.appendChild(line);

    // Inner bright core line (white-ish center of neon)
    const coreLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    coreLine.setAttribute('x1', points[i].x);
    coreLine.setAttribute('y1', points[i].y);
    coreLine.setAttribute('x2', points[i + 1].x);
    coreLine.setAttribute('y2', points[i + 1].y);
    coreLine.style.stroke = coreColor;
    coreLine.classList.add('neon-core');
    elWinLines.appendChild(coreLine);
  }
}

function clearWinLines() {
  elWinLines.innerHTML = '';
}

function showWin(amount) {
  elWin.textContent = '$' + amount.toFixed(2);
  elWinDisplay.textContent = '+$' + amount.toFixed(2);
  elWinDisplay.classList.add('show');
  // Sound already played during line wins, just a brief display
  setTimeout(() => elWinDisplay.classList.remove('show'), 1200);
}

async function showBigWin(amount) {
  const isMegaWin = amount >= totalBet * 50; // 50x bet = MEGA WIN

  // Get the appropriate amount element based on win type
  const amtElement = isMegaWin
    ? document.getElementById('bigwin-mega-amount')
    : document.getElementById('bigwin-amount');

  // Reset animations by removing and re-adding class
  elBigwin.classList.remove('active', 'mega');
  document.getElementById('bigwin-amount').textContent = '$0.00';
  document.getElementById('bigwin-mega-amount').textContent = '$0.00';

  // Force reflow
  void elBigwin.offsetWidth;

  // Add mega class for mega wins (shows bigwin1.webp, hides frame)
  if (isMegaWin) {
    elBigwin.classList.add('mega');
  }

  elBigwin.classList.add('active');
  playSound('bonus_enter.mp3');

  // Wait for visuals to appear, then count up the amount
  await delay(isMegaWin ? 1200 : 1500);

  // Count up animation - slower for bigger wins
  const duration = Math.min(2500, 1500 + amount * 5);
  const startTime = Date.now();

  const countUp = () => {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    const current = amount * eased;
    amtElement.textContent = '$' + current.toFixed(2);

    if (progress < 1) {
      requestAnimationFrame(countUp);
    } else {
      // Final flash when count-up completes
      amtElement.style.transform = 'scale(1.1)';
      amtElement.style.transition = 'transform 0.1s';
      setTimeout(() => {
        amtElement.style.transform = 'scale(1)';
      }, 100);
    }
  };
  countUp();

  // Hold for viewing (4 seconds after count-up starts)
  await delay(duration + 2500);

  // Fade out slowly
  elBigwin.style.transition = 'opacity 0.8s';
  elBigwin.style.opacity = '0';
  await delay(800);

  elBigwin.classList.remove('active', 'mega');
  elBigwin.style.transition = '';
  elBigwin.style.opacity = '';
}

function changeBet(dir) {
  if (spinning) return;
  betIdx = Math.max(0, Math.min(betLevels.length - 1, betIdx + dir));
  totalBet = betLevels[betIdx];
  elBet.textContent = formatBet(totalBet);
}

function formatBet(amount) {
  return '$' + amount.toFixed(2);
}

// Get friendly display name for symbols
function getSymbolDisplayName(symId) {
  const names = {
    1: 'CIGS',
    2: 'NEWS',
    3: 'CANDY',
    4: 'RECEIPT',
    5: 'ENERGY',
    6: 'COFFEE',
    7: 'RAMEN',
    8: 'HOTDOG',
    9: 'CLERK',
    10: 'LOTTO',
    11: 'WILD',
    12: 'KEY'
  };
  return names[symId] || `SYM${symId}`;
}

function toggleAuto() {
  autoSpin = !autoSpin;
  elAutoBtn.textContent = autoSpin ? 'STOP' : 'AUTO';
  elAutoBtn.style.background = autoSpin ? '#FF6B9D' : '';
  if (autoSpin && !spinning && !inBonus) spin();
}

function updateUI() {
  elBalance.textContent = '$' + balance.toFixed(2);
}

function showMessage(text) {
  elMessage.textContent = text;
  elMessage.classList.add('show');
  setTimeout(() => elMessage.classList.remove('show'), 2500);
}

function initAudio() {
  if (audioInitialized) return;
  audioInitialized = true;

  console.log('Initializing audio...');

  // Ambient hum - quiet background loop
  ambientAudio = new Audio('assets/ambient_hum.mp3');
  ambientAudio.loop = true;
  ambientAudio.volume = 0.15;

  // Rain ambient - continuous background loop (30-40% volume)
  rainAudio = new Audio('assets/rain_loop.mp3');
  rainAudio.loop = true;
  rainAudio.volume = 0.35; // 35% volume - lower than music

  // Pre-load door chime for spin
  doorChimeAudio = new Audio('assets/door_chime.mp3');
  doorChimeAudio.volume = 0.4;

  // Pre-load scratch sound for instant playback
  scratchAudio = new Audio('assets/pick_reveal.mp3');
  scratchAudio.volume = 0.5;

  if (soundEnabled) {
    ambientAudio.play().catch(e => console.log('Ambient play failed:', e));
    rainAudio.play().catch(e => console.log('Rain play failed:', e));
    // Start background music
    playRandomMusic();
  }
}

function playDoorChime() {
  if (!soundEnabled || !doorChimeAudio) return;
  // Reset and play (prevents overlapping)
  doorChimeAudio.currentTime = 0;
  doorChimeAudio.play().catch(() => {});
}

function playSound(file) {
  if (!soundEnabled) return;
  const audio = new Audio('assets/' + file);
  audio.volume = 0.5;
  audio.play().catch(() => {});
}

function playRandomMusic() {
  if (!soundEnabled) return;
  const tracks = ['muzak1.mp3', 'muzak2.mp3', 'muzak3.mp3', 'muzak4.mp3'];
  const track = tracks[Math.floor(Math.random() * tracks.length)];

  console.log('Playing music:', track);

  if (currentMusic) {
    currentMusic.pause();
    currentMusic = null;
  }

  currentMusic = new Audio('assets/' + track);
  currentMusic.volume = 0.25;
  currentMusic.loop = true;
  currentMusic.play().catch(e => console.log('Music play failed:', e));
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  document.getElementById('sound-toggle').textContent = soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
  if (ambientAudio) soundEnabled ? ambientAudio.play().catch(()=>{}) : ambientAudio.pause();
  if (rainAudio) soundEnabled ? rainAudio.play().catch(()=>{}) : rainAudio.pause();
  if (currentMusic) soundEnabled ? currentMusic.play().catch(()=>{}) : currentMusic.pause();
}

async function apiPost(path, body) {
  const res = await fetch(API + path, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': TOKEN
    },
    body: JSON.stringify(body)
  });
  const data = await res.json();
  if (!res.ok) throw new Error(data.what || 'API Error');
  return data;
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
function shuffleArray(a) { for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} }

// ============ DEBUG CONSOLE COMMANDS ============
// Call these from browser console for testing

window.debug = {
  // Trigger bonus game (Level 1 - Scratch Ticket): debug.bonus()
  bonus: async () => {
    if (spinning) { console.log('Wait for spin to finish'); return; }
    console.log('Starting bonus game (Scratch Ticket)...');
    await showBonusTrigger();
    startBonus(null);
  },

  // Trigger level 2 directly (Back Room): debug.backroom()
  backroom: async () => {
    if (spinning) { console.log('Wait for spin to finish'); return; }
    console.log('Going to back room...');
    inBonus = true;
    bonusLevel = 2;
    bonusPicks = 3;
    bonusWin = 0;
    pickLocked = false;
    cratesOpened = 0;
    await showBackroomTrigger();
    elBonusScreen.classList.add('active', 'level2');
    elBonusTitle.textContent = 'THE BACK ROOM';
    elBonusSub.textContent = "Pick 3 crates...";
    elCollectBtn.style.display = 'none';
    setupCrateShelf();
    updateBonusUI();
  },

  // Play intro video again: debug.intro()
  intro: () => {
    sessionStorage.removeItem('intro_played');
    location.reload();
  },

  // Test big win: debug.bigwin(amount)
  bigwin: (amount = 5) => {
    console.log('Showing BIG WIN: $' + amount);
    showBigWin(amount);
  },

  // Test MEGA win (50x+): debug.megawin()
  megawin: () => {
    const amount = totalBet * 55; // 55x bet triggers MEGA WIN
    console.log('Showing MEGA WIN: $' + amount + ' (55x bet)');
    showBigWin(amount);
  },

  // Add balance: debug.addMoney(amount)
  addMoney: (amount = 100) => {
    balance += amount;
    updateUI();
    console.log('Balance: $' + balance.toFixed(2));
  },

  // Show bonus trigger overlay: debug.triggerOverlay()
  triggerOverlay: () => showBonusTrigger(),

  // Show backroom trigger overlay: debug.backroomOverlay()
  backroomOverlay: () => showBackroomTrigger(),

  // End bonus and collect: debug.collect()
  collect: () => {
    if (inBonus) collectBonus();
    else console.log('Not in bonus');
  }
};

console.log('%c3AM BODEGA DEBUG', 'color: #00D4FF; font-size: 16px; font-weight: bold;');
console.log('%cCommands: debug.bonus() | debug.backroom() | debug.bigwin(5) | debug.megawin() | debug.addMoney(100) | debug.intro()', 'color: #FF6B9D;');
</script>
</body>
</html>
