<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>RealmFall</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700;900&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Georgia', serif;
    background: #000;
    min-height: 100vh;
    overflow: hidden;
}

/* Layer 1: Full screen background */
.game-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: url('assets/bg.webp') center/cover no-repeat;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* Logo */
.logo {
    width: 280px;
    margin-top: 10px;
    filter: drop-shadow(0 0 15px rgba(255, 150, 0, 0.5));
}

/* Board wrapper - maintains 2713:2170 aspect ratio */
.board-wrapper {
    position: relative;
    width: min(900px, 95vw);
    height: min(720px, calc(95vw / 1.25));
    margin-top: -40px;
    overflow: visible;
}

/* Layer 1: Backdrop behind symbols */
.board-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: none;
}

.board-backdrop img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: fill;
}

/* Layer 2: Reels clip wrapper - clips falling symbols */
.reels-clip {
    position: absolute;
    left: 11.43%;
    top: 24.10%;
    width: 77.15%;
    height: 57.47%;
    z-index: 5;
    overflow: hidden;
}

/* Symbol container - absolute positioning for true movement */
.reels {
    position: relative;
    width: 100%;
    height: 100%;
}

.symbol {
    position: absolute;
    width: 20%;  /* 100% / 5 columns */
    height: 33.33%;  /* 100% / 3 rows */
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    transition: top 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s, transform 0.25s;
    will-change: top, opacity, transform;
}

.symbol.winning {
    z-index: 20;
    animation: pulse 0.25s ease-in-out 3;
    box-shadow: 0 0 20px 5px gold, 0 0 40px 10px rgba(255, 215, 0, 0.5);
    border: 3px solid gold;
    border-radius: 8px;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* Scatter Anticipation Effects */
.symbol.scatter-hit {
    z-index: 25;
    animation: scatterPulse 0.5s ease-in-out infinite;
}

@keyframes scatterPulse {
    0%, 100% {
        filter: brightness(1) drop-shadow(0 0 10px gold);
    }
    50% {
        filter: brightness(1.5) drop-shadow(0 0 25px gold) drop-shadow(0 0 40px orange);
    }
}

.anticipation-active .board-backdrop {
    filter: brightness(0.6);
    transition: filter 0.3s;
}

.anticipation-active .board-frame img {
    filter: drop-shadow(0 0 20px rgba(255, 200, 0, 0.8));
    animation: frameGlow 0.4s ease-in-out infinite;
}

@keyframes frameGlow {
    0%, 100% { filter: drop-shadow(0 0 15px rgba(255, 200, 0, 0.6)); }
    50% { filter: drop-shadow(0 0 30px rgba(255, 200, 0, 1)); }
}

.symbol.anticipation-target {
    animation: reelAnticipation 0.3s ease-in-out infinite;
}

@keyframes reelAnticipation {
    0%, 100% { box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.3); }
    50% { box-shadow: inset 0 0 40px rgba(255, 215, 0, 0.6); }
}

.screen-shake {
    animation: shake 0.1s ease-in-out infinite;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-2px); }
    75% { transform: translateX(2px); }
}

/* Layer 3: Board frame overlay */
.board-frame {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10;
    pointer-events: none;
}

.board-frame img {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: fill;
}

/* Layer 4: Multiplier frame with image */
.multiplier-frame {
    position: absolute;
    bottom: 5%;
    left: 50%;
    transform: translateX(-50%);
    z-index: 15;
}

.multiplier-frame img {
    width: auto;
    height: 60px;
    display: block;
}

.multiplier-value {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5rem;
    font-weight: bold;
    color: #ffd700;
    text-shadow: 0 0 10px #ffd700, 2px 2px 4px #000;
}

.multiplier-glow {
    animation: multGlow 0.5s ease-out;
}

@keyframes multGlow {
    0% { transform: translate(-50%, -50%) scale(1.5); color: #fff; }
    100% { transform: translate(-50%, -50%) scale(1); color: #ffd700; }
}

/* Controls */
.controls {
    position: fixed;
    bottom: 15px;
    display: flex;
    align-items: center;
    gap: 15px;
    background: rgba(15, 10, 25, 0.95);
    padding: 12px 25px;
    border-radius: 12px;
    border: 2px solid #3a2a1a;
}

.stat {
    text-align: center;
    min-width: 70px;
}

.stat-label {
    font-size: 0.65rem;
    color: #777;
    text-transform: uppercase;
}

.stat-value {
    font-size: 1.1rem;
    color: #ffd700;
    font-weight: bold;
}

.spin-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid #ffd700;
    background: linear-gradient(180deg, #3a2000 0%, #1a1000 100%);
    color: #ffd700;
    font-size: 0.85rem;
    font-weight: bold;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
}

.spin-btn:hover:not(:disabled) {
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
}

.spin-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.bet-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
}

.bet-btns {
    display: flex;
    gap: 5px;
}

.bet-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px solid #555;
    background: #1a1a2a;
    color: #aaa;
    font-size: 1rem;
    cursor: pointer;
}

.bet-btn:hover {
    border-color: #ffd700;
    color: #ffd700;
}

/* Win display */
.win-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    font-size: 3rem;
    font-weight: bold;
    color: #ffd700;
    text-shadow: 0 0 30px #ff6600, 3px 3px 0 #000;
    z-index: 100;
    opacity: 0;
    transition: all 0.3s;
    pointer-events: none;
}

.win-display.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
}

/* Free falls banner */
.ff-banner {
    position: absolute;
    top: 80px;
    background: linear-gradient(180deg, #4a0a4a, #2a052a);
    padding: 8px 20px;
    border-radius: 8px;
    border: 2px solid #ff00ff;
    color: #ff88ff;
    font-weight: bold;
    display: none;
    z-index: 10;
}

.ff-banner.show { display: block; }

/* Responsive */
@media (max-width: 600px) {
    .logo { width: 200px; }
    .board-wrapper { width: 95vw; }
    .controls { padding: 8px 15px; gap: 10px; }
    .spin-btn { width: 55px; height: 55px; font-size: 0.7rem; }
    .stat { min-width: 50px; }
    .stat-value { font-size: 0.9rem; }
    .multiplier-frame img { height: 45px; }
    .multiplier-value { font-size: 1.2rem; }
}

/* ===== PORTAL OVERLAY - Modern Glass Effect ===== */
.portal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.6s ease, background 0.6s ease;
}

.portal-overlay.active {
    opacity: 1;
    visibility: visible;
    background: rgba(0, 0, 0, 0.85);
}

.portal-container {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transform: scale(0.8) translateY(30px);
    opacity: 0;
    transition: transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.5s ease;
}

.portal-overlay.active .portal-container {
    transform: scale(1) translateY(0);
    opacity: 1;
}

.portal-stone {
    width: 550px;
    max-width: 90vw;
    height: auto;
    filter: drop-shadow(0 20px 60px rgba(255, 170, 0, 0.4))
            drop-shadow(0 0 30px rgba(255, 100, 0, 0.3));
    animation: stoneFloat 3s ease-in-out infinite;
}

@keyframes stoneFloat {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

.portal-text-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    gap: 10px;
}

.portal-title {
    font-family: 'Georgia', serif;
    font-size: 38px;
    font-weight: bold;
    color: #ffd700;
    text-shadow:
        0 0 10px rgba(255, 200, 0, 0.8),
        0 0 30px rgba(255, 150, 0, 0.6),
        0 2px 4px rgba(0, 0, 0, 0.9);
    letter-spacing: 6px;
    text-transform: uppercase;
    opacity: 0;
    transform: translateY(-20px);
    animation: textSlideIn 0.6s ease 0.4s forwards;
}

.portal-count {
    font-family: 'Georgia', serif;
    font-size: 80px;
    font-weight: bold;
    color: #fff;
    text-shadow:
        0 0 20px rgba(255, 200, 0, 1),
        0 0 40px rgba(255, 150, 0, 0.8),
        0 0 60px rgba(255, 100, 0, 0.5),
        0 3px 6px rgba(0, 0, 0, 0.9);
    opacity: 0;
    transform: scale(0.5);
    animation: countPop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) 0.6s forwards;
}

.portal-subtitle {
    font-family: 'Georgia', serif;
    font-size: 24px;
    color: #ffcc00;
    text-shadow: 0 0 10px rgba(255, 200, 0, 0.6), 0 2px 4px rgba(0, 0, 0, 0.8);
    letter-spacing: 3px;
    opacity: 0;
    animation: textSlideIn 0.6s ease 0.8s forwards;
}

/* Win display for end of free spins */
.portal-win-display {
    font-family: 'Georgia', serif;
    font-size: 28px;
    color: #ffd700;
    text-shadow: 0 0 15px rgba(255, 200, 0, 0.8), 0 2px 4px rgba(0, 0, 0, 0.9);
    margin-top: 15px;
    opacity: 0;
    animation: textSlideIn 0.6s ease 1s forwards;
}

.portal-win-amount {
    font-size: 52px;
    color: #fff;
    display: block;
    margin-top: 5px;
    text-shadow:
        0 0 20px rgba(255, 200, 0, 1),
        0 0 40px rgba(255, 150, 0, 0.8);
}

@keyframes textSlideIn {
    to { opacity: 1; transform: translateY(0); }
}

@keyframes countPop {
    to { opacity: 1; transform: scale(1); }
}

/* Particle effects */
.portal-particles {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    pointer-events: none;
}

.portal-particles span {
    position: absolute;
    width: 8px;
    height: 8px;
    background: radial-gradient(circle, #ffd700 0%, #ff8800 100%);
    border-radius: 50%;
    opacity: 0;
    box-shadow: 0 0 10px #ffd700, 0 0 20px #ff8800;
}

.portal-overlay.active .portal-particles span {
    animation: particleFly 2.5s ease-out infinite;
}

.portal-particles span:nth-child(1) { --tx: 200px; --ty: 0; animation-delay: 0s; }
.portal-particles span:nth-child(2) { --tx: 130px; --ty: -130px; animation-delay: 0.3s; }
.portal-particles span:nth-child(3) { --tx: 0; --ty: -200px; animation-delay: 0.6s; }
.portal-particles span:nth-child(4) { --tx: -130px; --ty: -130px; animation-delay: 0.9s; }
.portal-particles span:nth-child(5) { --tx: -200px; --ty: 0; animation-delay: 1.2s; }
.portal-particles span:nth-child(6) { --tx: -130px; --ty: 130px; animation-delay: 1.5s; }
.portal-particles span:nth-child(7) { --tx: 0; --ty: 200px; animation-delay: 1.8s; }
.portal-particles span:nth-child(8) { --tx: 130px; --ty: 130px; animation-delay: 2.1s; }

@keyframes particleFly {
    0% {
        transform: translate(0, 0) scale(0);
        opacity: 0;
    }
    15% {
        opacity: 1;
        transform: translate(0, 0) scale(1.2);
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}

/* Closing animation */
.portal-overlay.closing .portal-container {
    transform: scale(0.8) translateY(-30px);
    opacity: 0;
    transition: transform 0.5s ease-in, opacity 0.4s ease;
}

.portal-overlay.closing {
    background: rgba(0, 0, 0, 0);
}

/* ===== BIG WIN OVERLAY ===== */
.bigwin-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    opacity: 0;
    visibility: hidden;
    background: rgba(0, 0, 0, 0.85);
    transition: opacity 0.3s, visibility 0.3s;
}

.bigwin-overlay.active {
    opacity: 1;
    visibility: visible;
}

.bigwin-beam {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scaleX(0);
    width: 120%;
    max-width: 1200px;
    height: auto;
    pointer-events: none;
    z-index: 2001;
    opacity: 0;
}

.bigwin-overlay.active .bigwin-beam {
    animation: beamIn 0.5s ease-out forwards;
}

@keyframes beamIn {
    0% { transform: translate(-50%, -50%) scaleX(0) scaleY(0.5); opacity: 0; }
    50% { transform: translate(-50%, -50%) scaleX(1.2) scaleY(1.2); opacity: 1; }
    100% { transform: translate(-50%, -50%) scaleX(1) scaleY(1); opacity: 0.9; }
}

.bigwin-lightning {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 600px;
    max-width: 80vw;
    height: auto;
    pointer-events: none;
    z-index: 2002;
    opacity: 0;
}

.bigwin-overlay.active .bigwin-lightning {
    animation: bigwinLightningFlash 0.8s ease-out forwards;
}

@keyframes bigwinLightningFlash {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
    40% { opacity: 0.3; transform: translate(-50%, -50%) scale(1.1); }
    60% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    80% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
}

.bigwin-content {
    position: relative;
    z-index: 2003;
    display: flex;
    justify-content: center;
    align-items: center;
    transform: scale(0) rotate(-10deg);
}

.bigwin-overlay.active .bigwin-content {
    animation: bigwinSlabIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.15s forwards;
}

@keyframes bigwinSlabIn {
    0% { transform: scale(0) rotate(-10deg); }
    60% { transform: scale(1.1) rotate(2deg); }
    100% { transform: scale(1) rotate(0deg); }
}

.bigwin-slab {
    width: 500px;
    max-width: 85vw;
    height: auto;
}

.bigwin-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    width: 80%;
}

.bigwin-tier {
    font-family: 'Cinzel Decorative', serif;
    font-size: clamp(28px, 6vw, 48px);
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: 6px;
    animation: tierPulse 1.5s ease-in-out infinite;
    -webkit-text-stroke: 2px rgba(0,0,0,0.5);
}

.bigwin-tier.big {
    color: #ffd700;
    text-shadow: 0 0 20px #ffd700, 0 0 40px #ff8c00, 0 0 60px #ff4500, 2px 2px 4px rgba(0,0,0,0.8);
}

.bigwin-tier.mega {
    color: #ff6600;
    text-shadow: 0 0 20px #ff6600, 0 0 40px #ff0000, 0 0 60px #ff0066, 2px 2px 4px rgba(0,0,0,0.8);
}

.bigwin-tier.epic {
    color: #ff00ff;
    text-shadow: 0 0 20px #ff00ff, 0 0 40px #9900ff, 0 0 60px #0066ff, 0 0 80px #00ffff, 2px 2px 4px rgba(0,0,0,0.8);
}

@keyframes tierPulse {
    0%, 100% { transform: scale(1); filter: brightness(1); }
    50% { transform: scale(1.05); filter: brightness(1.3); }
}

.bigwin-amount {
    font-family: 'Cinzel Decorative', serif;
    font-size: clamp(36px, 10vw, 72px);
    font-weight: 900;
    color: #ffffff;
    margin-top: 5px;
    text-shadow: 0 0 10px #ffffff, 0 0 20px #00ffff, 0 0 30px #00ffff, 3px 3px 6px rgba(0,0,0,0.9);
    -webkit-text-stroke: 1px rgba(0,0,0,0.3);
    animation: amountGlow 2s ease-in-out infinite;
}

@keyframes amountGlow {
    0%, 100% { text-shadow: 0 0 10px #ffffff, 0 0 20px #00ffff, 0 0 30px #00ffff, 3px 3px 6px rgba(0,0,0,0.9); }
    50% { text-shadow: 0 0 20px #ffffff, 0 0 40px #00ffff, 0 0 60px #00ffff, 3px 3px 6px rgba(0,0,0,0.9); }
}

.bigwin-overlay.closing .bigwin-content {
    animation: bigwinSlabOut 0.4s ease-in forwards;
}

.bigwin-overlay.closing .bigwin-beam,
.bigwin-overlay.closing .bigwin-lightning {
    animation: fadeOut 0.3s ease-in forwards;
}

@keyframes bigwinSlabOut {
    to { transform: scale(0) rotate(10deg); opacity: 0; }
}

@keyframes fadeOut {
    to { opacity: 0; }
}

/* ===== EPIC FREE SPINS OVERLAY ===== */
.freespins-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    background: rgba(0, 0, 0, 0);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, background 0.3s;
}

.freespins-overlay.active {
    opacity: 1;
    visibility: visible;
    background: rgba(0, 0, 10, 0.9);
}

/* Pulsing light burst - behind EVERYTHING */
.fs-light-burst {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 150%;
    height: 150%;
    background: radial-gradient(circle,
        rgba(0, 180, 255, 0.4) 0%,
        rgba(0, 100, 255, 0.2) 25%,
        rgba(100, 0, 255, 0.1) 45%,
        transparent 65%
    );
    opacity: 0;
    z-index: 2000;
    pointer-events: none;
}

.fs-light-burst.active {
    animation: lightBurstEntry 0.5s ease-out forwards,
               lightBurstPulse 2s ease-in-out 0.5s infinite;
}

@keyframes lightBurstEntry {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

@keyframes lightBurstPulse {
    0%, 100% {
        opacity: 0.8;
        transform: translate(-50%, -50%) scale(1);
        filter: hue-rotate(0deg);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
        filter: hue-rotate(20deg);
    }
}

/* Layer 1: Starburst - FAST spin + screen blend */
.fs-starburst {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 900px;
    max-width: 140vw;
    height: auto;
    transform: translate(-50%, -50%) scale(0) rotate(0deg);
    opacity: 0;
    z-index: 2001;
    pointer-events: none;
    mix-blend-mode: screen;
}

.fs-starburst.active {
    animation: starburstEntry 0.6s ease-out forwards,
               starburstSpin 2s linear 0.6s infinite;
}

@keyframes starburstEntry {
    0% {
        transform: translate(-50%, -50%) scale(0) rotate(0deg);
        opacity: 0;
    }
    100% {
        transform: translate(-50%, -50%) scale(1) rotate(180deg);
        opacity: 0.5;
    }
}

@keyframes starburstSpin {
    from { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0.5; }
    to { transform: translate(-50%, -50%) scale(1) rotate(360deg); opacity: 0.5; }
}

/* Layer 2: Portal ring - slower spin + GLOW + screen blend */
.fs-portal {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 700px;
    max-width: 110vw;
    height: auto;
    transform: translate(-50%, -50%) scale(0) rotate(0deg);
    opacity: 0;
    z-index: 2002;
    pointer-events: none;
    mix-blend-mode: screen;
    filter: drop-shadow(0 0 20px rgba(0, 180, 255, 0.8))
            drop-shadow(0 0 40px rgba(0, 120, 255, 0.6))
            drop-shadow(0 0 80px rgba(0, 80, 255, 0.4));
}

.fs-portal.active {
    animation: portalEntry 0.8s cubic-bezier(0.22, 1, 0.36, 1) forwards,
               portalSpin 8s linear 0.8s infinite,
               portalGlow 3s ease-in-out 0.8s infinite;
}

@keyframes portalEntry {
    0% {
        transform: translate(-50%, -50%) scale(0) rotate(-90deg);
        opacity: 0;
    }
    60% {
        transform: translate(-50%, -50%) scale(1.1) rotate(10deg);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        opacity: 1;
    }
}

@keyframes portalSpin {
    from { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
    to { transform: translate(-50%, -50%) scale(1) rotate(360deg); }
}

@keyframes portalGlow {
    0%, 100% {
        filter: drop-shadow(0 0 20px rgba(0, 180, 255, 0.8))
                drop-shadow(0 0 40px rgba(0, 120, 255, 0.6))
                drop-shadow(0 0 80px rgba(0, 80, 255, 0.4));
    }
    50% {
        filter: drop-shadow(0 0 40px rgba(0, 200, 255, 1))
                drop-shadow(0 0 80px rgba(0, 150, 255, 0.8))
                drop-shadow(0 0 120px rgba(0, 100, 255, 0.6));
    }
}

/* Layer 3: Energy orb - pulses + screen blend + glow */
.fs-orb {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 500px;
    max-width: 80vw;
    height: auto;
    transform: translate(-50%, -50%) scale(0);
    opacity: 0;
    z-index: 2003;
    pointer-events: none;
    mix-blend-mode: screen;
    filter: drop-shadow(0 0 30px rgba(255, 100, 255, 0.6));
}

.fs-orb.active {
    animation: orbEntry 0.5s ease-out 0.2s forwards,
               orbPulse 2s ease-in-out 0.7s infinite;
}

@keyframes orbEntry {
    0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
    }
    100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.7;
    }
}

@keyframes orbPulse {
    0%, 100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.6;
        filter: drop-shadow(0 0 30px rgba(255, 100, 255, 0.6));
    }
    50% {
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 0.9;
        filter: drop-shadow(0 0 60px rgba(255, 150, 255, 0.9));
    }
}

/* Layer 4: Horizontal beam - flash + screen blend */
.fs-beam {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 150%;
    max-width: 2000px;
    height: auto;
    transform: translate(-50%, -50%) scaleX(0);
    opacity: 0;
    z-index: 2004;
    pointer-events: none;
    mix-blend-mode: screen;
}

.fs-beam.flash {
    animation: beamFlash 0.5s ease-out forwards;
}

@keyframes beamFlash {
    0% {
        transform: translate(-50%, -50%) scaleX(0) scaleY(0.5);
        opacity: 0;
    }
    30% {
        transform: translate(-50%, -50%) scaleX(1.2) scaleY(1.5);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scaleX(1) scaleY(1);
        opacity: 0;
    }
}

/* Layer 5: Lightning bolt - aggressive flashes + screen blend + glow */
.fs-bolt {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 400px;
    max-width: 60vw;
    height: auto;
    transform: translate(-50%, -50%) rotate(0deg);
    opacity: 0;
    z-index: 2005;
    pointer-events: none;
    mix-blend-mode: screen;
    filter: drop-shadow(0 0 10px rgba(100, 200, 255, 1))
            drop-shadow(0 0 20px rgba(50, 150, 255, 0.8));
}

.fs-bolt.flash {
    animation: boltFlash 0.15s ease-out forwards;
}

@keyframes boltFlash {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.7);
        filter: drop-shadow(0 0 10px rgba(100, 200, 255, 1))
                drop-shadow(0 0 20px rgba(50, 150, 255, 0.8));
    }
    20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
        filter: drop-shadow(0 0 30px rgba(150, 220, 255, 1))
                drop-shadow(0 0 60px rgba(100, 180, 255, 1));
    }
    40% {
        opacity: 0.4;
        transform: translate(-50%, -50%) scale(1);
    }
    60% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1);
    }
}

/* Layer 6: Content */
.fs-content {
    position: relative;
    z-index: 2010;
    display: flex;
    flex-direction: column;
    align-items: center;
    transform: scale(0);
    opacity: 0;
}

.fs-content.active {
    animation: contentEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) 0.4s forwards;
}

@keyframes contentEntry {
    0% {
        transform: scale(0) translateY(50px);
        opacity: 0;
    }
    100% {
        transform: scale(1) translateY(0);
        opacity: 1;
    }
}

/* Number */
.fs-number {
    font-family: 'Cinzel Decorative', serif;
    font-size: clamp(90px, 22vw, 160px);
    font-weight: 900;
    color: #ffaa00;
    line-height: 0.9;
    margin-bottom: -15px;
    opacity: 0;
    transform: scale(0.5);
    text-shadow:
        0 0 30px #ff6600,
        0 0 60px #ff4400,
        0 0 90px #ff2200,
        0 0 120px rgba(255, 100, 0, 0.8);
    -webkit-text-stroke: 1px rgba(80, 40, 0, 0.5);
}

.fs-number.show {
    animation: numberEntry 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

@keyframes numberEntry {
    0% { transform: scale(0.5); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

.fs-number.glow {
    animation: numberEntry 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
               numberGlow 1.5s ease-in-out 0.5s infinite;
}

@keyframes numberGlow {
    0%, 100% {
        text-shadow:
            0 0 30px #ff6600,
            0 0 60px #ff4400,
            0 0 90px #ff2200,
            0 0 120px rgba(255, 100, 0, 0.8);
        transform: scale(1);
    }
    50% {
        text-shadow:
            0 0 50px #ff6600,
            0 0 100px #ff4400,
            0 0 150px #ff2200,
            0 0 200px rgba(255, 100, 0, 0.9);
        transform: scale(1.08);
    }
}

/* Slab wrapper */
.fs-slab-wrapper {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
}

.fs-slab {
    width: 480px;
    max-width: 85vw;
    height: auto;
    filter: drop-shadow(0 0 15px rgba(100, 180, 255, 0.4))
            drop-shadow(0 0 30px rgba(50, 100, 200, 0.3));
}

/* Label */
.fs-label {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Cinzel Decorative', serif;
    font-size: clamp(26px, 5.5vw, 42px);
    font-weight: 700;
    color: #ffdd99;
    letter-spacing: 5px;
    white-space: nowrap;
    opacity: 0;
    text-shadow:
        0 0 15px #ff8800,
        0 0 30px #ff6600,
        2px 2px 4px rgba(0,0,0,0.9);
}

.fs-label.show {
    animation: labelEntry 0.4s ease-out forwards;
}

@keyframes labelEntry {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

/* Exit animations */
.freespins-overlay.closing .fs-light-burst {
    animation: lightBurstOut 0.4s ease-in forwards !important;
}

@keyframes lightBurstOut {
    to { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
}

.freespins-overlay.closing .fs-starburst,
.freespins-overlay.closing .fs-portal {
    animation: spinOut 0.5s ease-in forwards !important;
}

.freespins-overlay.closing .fs-orb {
    animation: fadeOut 0.4s ease-in forwards !important;
}

.freespins-overlay.closing .fs-content {
    animation: contentOut 0.4s ease-in forwards !important;
}

@keyframes spinOut {
    to {
        transform: translate(-50%, -50%) scale(0) rotate(180deg);
        opacity: 0;
    }
}

@keyframes fadeOut {
    to { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
}

@keyframes contentOut {
    to { transform: scale(0) translateY(-50px); opacity: 0; }
}
</style>
</head>
<body>
<div class="game-container">
    <img src="assets/logo.webp" alt="RealmFall" class="logo">

    <div class="ff-banner" id="ffBanner">FREE FALLS: <span id="ffCount">0</span></div>

    <div class="board-wrapper">
        <div class="board-backdrop">
            <img src="assets/board2bck.webp" alt="">
        </div>
        <div class="reels-clip">
            <div class="reels" id="reels"></div>
        </div>
        <div class="board-frame">
            <img src="assets/board.webp" alt="">
        </div>
        <div class="multiplier-frame">
            <img src="assets/multi.webp" alt="">
            <span class="multiplier-value" id="multiplierValue">x1</span>
        </div>
    </div>

    <div class="win-display" id="winDisplay"></div>

    <div id="loading" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#ffd700;font-size:2rem;text-shadow:0 0 20px #ff6600;z-index:200;">Loading...</div>

    <div class="controls">
        <div class="stat">
            <div class="stat-label">Balance</div>
            <div class="stat-value" id="balance">1000.00</div>
        </div>

        <div class="bet-area">
            <div class="stat">
                <div class="stat-label">Bet</div>
                <div class="stat-value" id="bet">1.00</div>
            </div>
            <div class="bet-btns">
                <button class="bet-btn" onclick="changeBet(-1)">-</button>
                <button class="bet-btn" onclick="changeBet(1)">+</button>
            </div>
        </div>

        <button class="spin-btn" id="spinBtn" onclick="spin()">SPIN</button>

        <div class="stat">
            <div class="stat-label">Win</div>
            <div class="stat-value" id="win">0.00</div>
        </div>
    </div>
</div>

<script>
const API = '';
const TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzbG90b3BvbCIsImV4cCI6NDg2NzQ0NzYxNywibmJmIjoxNzA2NjQ3NjE3LCJ1aWQiOjN9.6g2Hig9ErG8IbvzkPppry5F8HJsMunZPwuQzmetGh4c';
const GAME_ALIAS = 'NetEnt/Gonzos Quest';
const BETS = [0.20, 0.40, 0.60, 0.80, 1.00, 2.00, 5.00, 10.00];

// Symbol URLs for background-image
const SYMBOLS = {};
for (let i = 1; i <= 9; i++) {
    SYMBOLS[i] = `assets/symbols/${i}.webp`;
}

let gid = null;
let balance = 1000;
let betIdx = 4;
let spinning = false;
let freeFalls = 0;
let totalWin = 0;
let bonusTotalWin = 0;  // Track total win during entire bonus round
let screen = null;
let previousHit = null;
let previousScreen = null;  // Track previous screen state for cascade animation

// Preload all symbol images into browser cache
async function preloadSymbols() {
    console.log('Preloading symbols...');
    const promises = Object.entries(SYMBOLS).map(([id, src]) => {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                console.log(`Loaded symbol ${id}`);
                resolve();
            };
            img.onerror = () => {
                console.warn(`Failed to load symbol ${id}`);
                resolve();
            };
            img.src = src;
        });
    });
    await Promise.all(promises);
    console.log('All symbols preloaded!');
}

// DOM helpers
const $ = id => document.getElementById(id);
const reelsEl = $('reels');

// Track all symbols currently on screen (absolute positioned divs)
let symbolElements = [];

// Create a single symbol element
function createSymbol(col, row, symbolId) {
    const div = document.createElement('div');
    div.className = 'symbol';

    // Validate symbolId
    if (symbolId === undefined || symbolId === null || !SYMBOLS[symbolId]) {
        console.error(`Invalid symbolId: ${symbolId} at col:${col} row:${row}`);
        symbolId = 1; // Fallback to first symbol
    }

    div.style.backgroundImage = `url('${SYMBOLS[symbolId]}')`;
    div.style.left = `${col * 20}%`;  // 20% per column
    div.style.top = `${row * 33.33}%`;  // 33.33% per row
    div.dataset.col = col;
    div.dataset.row = row;
    div.dataset.symbolId = symbolId;
    return div;
}

// Initialize reels (empty, symbols created on first spin)
function createGrid() {
    reelsEl.innerHTML = '';
    symbolElements = [];
}

// Scatter anticipation - symbol ID 2 is scatter (freefall trigger)
const SCATTER_SYMBOL_ID = 2;

function checkAnticipation(screen) {
    // Count scatters in first 3 columns
    let scatterCols = [];

    for (let col = 0; col < 5; col++) {
        for (let row = 0; row < 3; row++) {
            if (screen[col][row] === SCATTER_SYMBOL_ID) {
                scatterCols.push(col);
                break; // Only count one per column
            }
        }
    }

    // If 2+ scatters in first 3 reels, trigger anticipation
    const earlyScatters = scatterCols.filter(col => col < 3).length;
    return earlyScatters >= 2 ? scatterCols : null;
}

async function triggerAnticipation(scatterCols, remainingCols) {
    const wrapper = document.querySelector('.board-wrapper');

    // Add anticipation class to wrapper
    wrapper.classList.add('anticipation-active');

    // Highlight landed scatters
    scatterCols.forEach(col => {
        symbolElements.filter(s => parseInt(s.dataset.col) === col)
            .forEach(s => s.classList.add('scatter-hit'));
    });

    // Mark remaining columns as targets
    remainingCols.forEach(col => {
        symbolElements.filter(s => parseInt(s.dataset.col) === col)
            .forEach(s => s.classList.add('anticipation-target'));
    });

    // Add screen shake
    wrapper.classList.add('screen-shake');

    // Hold for dramatic effect
    await new Promise(r => setTimeout(r, 1500));

    // Clean up
    wrapper.classList.remove('anticipation-active', 'screen-shake');
    symbolElements.forEach(sym => {
        sym.classList.remove('scatter-hit', 'anticipation-target');
    });
}

// Render screen - absolute positioned symbols for true movement
async function renderScreen(screen, cfn, hitArray, animate = true) {
    const reels = document.getElementById('reels');

    // ===== NO ANIMATION - just set everything =====
    if (!animate) {
        reels.innerHTML = '';
        symbolElements = [];

        for (let col = 0; col < 5; col++) {
            for (let row = 0; row < 3; row++) {
                const sym = createSymbol(col, row, screen[col][row]);
                reels.appendChild(sym);
                symbolElements.push(sym);
            }
        }
        previousHit = hitArray;
        return;
    }

    // ===== INITIAL SPIN (CFN=1) - clear and create all new symbols =====
    if (cfn === 1) {
        reels.innerHTML = '';
        symbolElements = [];

        for (let col = 0; col < 5; col++) {
            for (let row = 0; row < 3; row++) {
                const sym = createSymbol(col, row, screen[col][row]);
                sym.style.top = '-40%';  // Start above screen
                sym.style.opacity = '0';
                reels.appendChild(sym);
                symbolElements.push(sym);
            }
        }

        await new Promise(r => setTimeout(r, 50));

        // Animate each column falling
        for (let col = 0; col < 5; col++) {
            const colSymbols = symbolElements.filter(s => parseInt(s.dataset.col) === col);

            colSymbols.forEach((sym, i) => {
                setTimeout(() => {
                    sym.style.top = `${i * 33.33}%`;
                    sym.style.opacity = '1';
                }, i * 50);
            });

            await new Promise(r => setTimeout(r, 80));

            // Scatter anticipation after column 2
            if (col === 2) {
                const scatterCols = checkAnticipation(screen);
                if (scatterCols && scatterCols.length >= 2) {
                    await new Promise(r => setTimeout(r, 250));
                    const remainingCols = [3, 4].filter(c => !scatterCols.includes(c));
                    await triggerAnticipation(scatterCols, remainingCols);
                }
            }
        }

        await new Promise(r => setTimeout(r, 300));
        previousHit = hitArray;
        return;
    }

    // ===== CASCADE (CFN > 1) - Symbols actually move =====
    if (!previousHit) {
        previousHit = hitArray;
        return;
    }

    // DEBUG: Log current state
    console.log('CASCADE: previousHit:', JSON.stringify(previousHit));
    console.log('Current symbols count:', symbolElements.length);

    // REBUILD POSITION MAP - figure out which symbol is at which grid position
    // by parsing their dataset.col and dataset.row
    const symbolGrid = Array(5).fill(null).map(() => Array(3).fill(null));

    symbolElements.forEach(sym => {
        const col = parseInt(sym.dataset.col);
        const row = parseInt(sym.dataset.row);
        if (col >= 0 && col < 5 && row >= 0 && row < 3) {
            symbolGrid[col][row] = sym;
        }
    });

    // STEP 1: Find and remove winning symbols using the rebuilt grid
    const toRemove = [];
    for (let col = 0; col < 5; col++) {
        if (!previousHit[col]) continue;
        for (let row = 0; row < 3; row++) {
            if (previousHit[col][row] > 0) {
                console.log(`Hit at col:${col} row:${row}, value:${previousHit[col][row]}`);
                const sym = symbolGrid[col][row];
                if (sym) {
                    console.log(`  Found symbol, removing`);
                    sym.style.transition = 'opacity 0.25s, transform 0.25s';
                    sym.style.opacity = '0';
                    sym.style.transform = 'scale(0.5)';
                    toRemove.push(sym);
                } else {
                    console.warn(`  NO SYMBOL at col:${col} row:${row}!`);
                }
            }
        }
    }

    await new Promise(r => setTimeout(r, 300));

    // Remove from DOM and array
    toRemove.forEach(sym => {
        sym.remove();
        symbolElements = symbolElements.filter(s => s !== sym);
    });

    // STEP 2: Move survivors DOWN - recalculate positions per column
    for (let col = 0; col < 5; col++) {
        if (!previousHit[col]) continue;

        // COUNT cells with hits, not SUM hit values
        const hitsInColumn = previousHit[col].filter(h => h > 0).length;
        if (hitsInColumn === 0) continue;

        // Get remaining symbols in this column
        const colSymbols = symbolElements
            .filter(s => parseInt(s.dataset.col) === col)
            .sort((a, b) => parseInt(a.dataset.row) - parseInt(b.dataset.row));

        console.log(`Col ${col}: ${hitsInColumn} hits, ${colSymbols.length} survivors`);

        // Survivors fill from bottom: if 2 survivors, rows 1,2. If 1 survivor, row 2.
        const startRow = 3 - colSymbols.length;

        colSymbols.forEach((sym, i) => {
            const newRow = startRow + i;
            if (newRow < 0 || newRow > 2) {
                console.error(`Invalid row ${newRow} for survivor!`);
                return;
            }
            console.log(`  Survivor ${i} moving to row ${newRow}`);
            sym.dataset.row = newRow;  // Update dataset for next cascade
            sym.style.transition = 'top 0.35s cubic-bezier(0.34, 1.56, 0.64, 1)';
            sym.style.top = `${newRow * 33.33}%`;
        });

        await new Promise(r => setTimeout(r, 80));
    }

    await new Promise(r => setTimeout(r, 300));

    // STEP 3: Create NEW symbols at top and drop them
    for (let col = 0; col < 5; col++) {
        if (!previousHit[col]) continue;

        // COUNT cells with hits, not SUM hit values
        const hitsInColumn = previousHit[col].filter(h => h > 0).length;
        if (hitsInColumn === 0) continue;

        console.log(`Col ${col}: Creating ${hitsInColumn} new symbols`);

        // New symbols go in rows 0 to (hitsInColumn - 1)
        for (let row = 0; row < hitsInColumn; row++) {
            const symbolId = screen[col][row];
            console.log(`  New symbol at row ${row}: symbolId ${symbolId}`);

            const sym = createSymbol(col, row, symbolId);
            sym.style.top = '-40%';  // Start ABOVE the grid
            sym.style.opacity = '0';
            reels.appendChild(sym);
            symbolElements.push(sym);

            // Animate down with stagger
            setTimeout(() => {
                sym.style.transition = 'top 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.15s ease-out';
                sym.style.top = `${row * 33.33}%`;
                sym.style.opacity = '1';
            }, 50 + row * 70);
        }

        await new Promise(r => setTimeout(r, 100));
    }

    await new Promise(r => setTimeout(r, 300));
    previousHit = hitArray;
}

// Show wins with glow effect
async function showWins(wins) {
    if (!wins || wins.length === 0) return;

    const winningSymbols = [];

    wins.forEach(win => {
        if (win.xy) {
            win.xy.forEach(([col, row]) => {
                if (col > 0 && row > 0) {
                    // Find symbol at this position (1-indexed from API)
                    const sym = symbolElements.find(s =>
                        parseInt(s.dataset.col) === col - 1 &&
                        parseInt(s.dataset.row) === row - 1
                    );
                    if (sym) winningSymbols.push(sym);
                }
            });
        }
    });

    winningSymbols.forEach(sym => sym.classList.add('winning'));

    await new Promise(r => setTimeout(r, 800));

    winningSymbols.forEach(sym => sym.classList.remove('winning'));
}

// Clear winning highlights
function clearWins() {
    symbolElements.forEach(sym => sym.classList.remove('winning'));
}

// Update multiplier display based on cascade fall number
function updateMultiplier(cfn, inBonus = false) {
    const el = $('multiplierValue');
    if (!el) return;

    // Base multipliers: 1x, 2x, 3x, 5x for cascades 1, 2, 3, 4+
    // Bonus multipliers: 3x, 6x, 9x, 15x
    const baseMults = {1: 1, 2: 2, 3: 3};
    const bonusMults = {1: 3, 2: 6, 3: 9};

    let mult;
    if (inBonus) {
        mult = cfn >= 4 ? 15 : (bonusMults[cfn] || 3);
    } else {
        mult = cfn >= 4 ? 5 : (baseMults[cfn] || 1);
    }

    el.textContent = `x${mult}`;

    // Add glow effect on increase
    if (cfn > 1) {
        el.classList.add('multiplier-glow');
        setTimeout(() => el.classList.remove('multiplier-glow'), 500);
    }
}

// Update UI
function updateUI() {
    $('balance').textContent = balance.toFixed(2);
    $('bet').textContent = BETS[betIdx].toFixed(2);
    $('win').textContent = totalWin.toFixed(2);

    if (freeFalls > 0) {
        $('ffBanner').classList.add('show');
        $('ffCount').textContent = freeFalls;
    } else {
        $('ffBanner').classList.remove('show');
    }
}

// Show win popup
function showWin(amount) {
    const el = $('winDisplay');
    el.textContent = '+' + amount.toFixed(2);
    el.classList.add('show');
    setTimeout(() => el.classList.remove('show'), 1500);
}

// ===== BIG WIN SYSTEM =====

// Win tier thresholds (multiplier of bet)
const WIN_TIERS = {
    BIG: 15,    // 15x bet
    MEGA: 30,   // 30x bet
    EPIC: 50    // 50x bet
};

function getWinTier(winAmount, betAmount) {
    const multiplier = winAmount / betAmount;
    if (multiplier >= WIN_TIERS.EPIC) return { name: 'EPIC WIN', class: 'epic' };
    if (multiplier >= WIN_TIERS.MEGA) return { name: 'MEGA WIN', class: 'mega' };
    if (multiplier >= WIN_TIERS.BIG) return { name: 'BIG WIN', class: 'big' };
    return null; // No big win display
}

async function countUp(element, start, end, duration = 1500) {
    const startTime = performance.now();
    const range = end - start;

    return new Promise(resolve => {
        function update(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Ease out cubic
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            const current = start + (range * easeProgress);

            element.textContent = current.toFixed(2);

            if (progress < 1) {
                requestAnimationFrame(update);
            } else {
                element.textContent = end.toFixed(2);
                resolve();
            }
        }
        requestAnimationFrame(update);
    });
}

async function showBigWin(winAmount, betAmount) {
    const tier = getWinTier(winAmount, betAmount);
    if (!tier) return false; // Not a big enough win

    const overlay = document.getElementById('bigwinOverlay');
    const tierEl = document.getElementById('bigwinTier');
    const amountEl = document.getElementById('bigwinAmount');

    // Setup
    tierEl.textContent = tier.name;
    tierEl.className = 'bigwin-tier ' + tier.class;
    amountEl.textContent = '0.00';

    // Show overlay
    overlay.classList.add('active');

    // Wait for effects to start, then count up
    await new Promise(r => setTimeout(r, 400));
    await countUp(amountEl, 0, winAmount, 1500);

    // Hold for a moment
    await new Promise(r => setTimeout(r, 1000));

    // Close
    overlay.classList.add('closing');
    await new Promise(r => setTimeout(r, 400));
    overlay.classList.remove('active', 'closing');

    return true;
}

// Lightning flash interval holder
let boltInterval = null;

async function showNewFreeSpinsPortal(spinsAwarded) {
    const overlay = document.getElementById('freespinsOverlay');
    const lightBurst = document.getElementById('fsLightBurst');
    const starburst = document.getElementById('fsStarburst');
    const portal = document.getElementById('fsPortal');
    const orb = document.getElementById('fsOrb');
    const beam = document.getElementById('fsBeam');
    const bolt = document.getElementById('fsBolt');
    const content = document.getElementById('fsContent');
    const number = document.getElementById('fsNumber');
    const label = document.getElementById('fsLabel');

    // Reset all states
    lightBurst.classList.remove('active');
    starburst.classList.remove('active');
    portal.classList.remove('active');
    orb.classList.remove('active');
    beam.classList.remove('flash');
    bolt.classList.remove('flash');
    content.classList.remove('active');
    number.classList.remove('show', 'glow');
    label.classList.remove('show');
    bolt.style.transform = 'translate(-50%, -50%) rotate(0deg)';

    // Clear any existing bolt interval
    if (boltInterval) {
        clearInterval(boltInterval);
        boltInterval = null;
    }

    // Set content
    number.textContent = spinsAwarded;
    label.textContent = 'FREE SPINS';

    // Step 1: Show overlay, activate spinning layers
    overlay.classList.add('active');
    lightBurst.classList.add('active');
    starburst.classList.add('active');
    portal.classList.add('active');
    orb.classList.add('active');

    // Step 2: Flash beam on impact
    setTimeout(() => {
        beam.classList.add('flash');
    }, 400);

    // Step 3: Show content
    setTimeout(() => {
        content.classList.add('active');
    }, 450);

    // Step 4: Show number with glow
    setTimeout(() => {
        number.classList.add('glow');
    }, 600);

    // Step 5: Show label
    setTimeout(() => {
        label.classList.add('show');
    }, 750);

    // Step 6: Start aggressive lightning flashes with double-flash chance
    setTimeout(() => {
        boltInterval = setInterval(() => {
            const doDoubleFlash = Math.random() > 0.5;

            bolt.classList.remove('flash');
            bolt.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg) scaleX(${Math.random() > 0.5 ? 1 : -1})`;
            void bolt.offsetWidth;
            bolt.classList.add('flash');

            if (doDoubleFlash) {
                setTimeout(() => {
                    bolt.classList.remove('flash');
                    bolt.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg) scaleX(${Math.random() > 0.5 ? 1 : -1})`;
                    void bolt.offsetWidth;
                    bolt.classList.add('flash');
                }, 150);
            }
        }, 600 + Math.random() * 300);
    }, 900);

    // Hold display
    await new Promise(r => setTimeout(r, 3500));

    // Clear bolt interval before closing
    if (boltInterval) {
        clearInterval(boltInterval);
        boltInterval = null;
    }

    // Close
    overlay.classList.add('closing');
    await new Promise(r => setTimeout(r, 600));

    // Reset all
    overlay.classList.remove('active', 'closing');
    lightBurst.classList.remove('active');
    starburst.classList.remove('active');
    portal.classList.remove('active');
    orb.classList.remove('active');
    beam.classList.remove('flash');
    bolt.classList.remove('flash');
    content.classList.remove('active');
    number.classList.remove('show', 'glow');
    label.classList.remove('show');
}

async function showNewFreeSpinsEnd(totalWinAmount) {
    const overlay = document.getElementById('freespinsOverlay');
    const lightBurst = document.getElementById('fsLightBurst');
    const starburst = document.getElementById('fsStarburst');
    const portal = document.getElementById('fsPortal');
    const orb = document.getElementById('fsOrb');
    const beam = document.getElementById('fsBeam');
    const bolt = document.getElementById('fsBolt');
    const content = document.getElementById('fsContent');
    const number = document.getElementById('fsNumber');
    const label = document.getElementById('fsLabel');

    // Reset all states
    lightBurst.classList.remove('active');
    starburst.classList.remove('active');
    portal.classList.remove('active');
    orb.classList.remove('active');
    beam.classList.remove('flash');
    bolt.classList.remove('flash');
    content.classList.remove('active');
    number.classList.remove('show', 'glow');
    label.classList.remove('show');
    bolt.style.transform = 'translate(-50%, -50%) rotate(0deg)';

    // Clear any existing bolt interval
    if (boltInterval) {
        clearInterval(boltInterval);
        boltInterval = null;
    }

    // Set content for end screen
    number.textContent = '0.00';
    label.textContent = 'TOTAL WIN';

    // Step 1: Show overlay, activate spinning layers
    overlay.classList.add('active');
    lightBurst.classList.add('active');
    starburst.classList.add('active');
    portal.classList.add('active');
    orb.classList.add('active');

    // Step 2: Flash beam
    setTimeout(() => {
        beam.classList.add('flash');
    }, 400);

    // Step 3: Show content
    setTimeout(() => {
        content.classList.add('active');
    }, 450);

    // Step 4: Show number (will count up)
    setTimeout(() => {
        number.classList.add('show');
    }, 600);

    // Step 5: Show label
    setTimeout(() => {
        label.classList.add('show');
    }, 750);

    // Step 6: Start aggressive lightning flashes with double-flash chance
    setTimeout(() => {
        boltInterval = setInterval(() => {
            const doDoubleFlash = Math.random() > 0.5;

            bolt.classList.remove('flash');
            bolt.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg) scaleX(${Math.random() > 0.5 ? 1 : -1})`;
            void bolt.offsetWidth;
            bolt.classList.add('flash');

            if (doDoubleFlash) {
                setTimeout(() => {
                    bolt.classList.remove('flash');
                    bolt.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg) scaleX(${Math.random() > 0.5 ? 1 : -1})`;
                    void bolt.offsetWidth;
                    bolt.classList.add('flash');
                }, 150);
            }
        }, 600 + Math.random() * 300);
    }, 900);

    // Count up after number appears
    setTimeout(async () => {
        await countUp(number, 0, totalWinAmount, 1500);
        number.classList.add('glow');
    }, 900);

    // Hold display
    await new Promise(r => setTimeout(r, 4500));

    // Clear bolt interval before closing
    if (boltInterval) {
        clearInterval(boltInterval);
        boltInterval = null;
    }

    // Close
    overlay.classList.add('closing');
    await new Promise(r => setTimeout(r, 600));

    // Reset all
    overlay.classList.remove('active', 'closing');
    lightBurst.classList.remove('active');
    starburst.classList.remove('active');
    portal.classList.remove('active');
    orb.classList.remove('active');
    beam.classList.remove('flash');
    bolt.classList.remove('flash');
    content.classList.remove('active');
    number.classList.remove('show', 'glow');
    label.classList.remove('show');
}

// TEST FUNCTIONS - correct bet values
window.testBigWin = () => showBigWin(20, 1);      // 20x = Big Win
window.testMegaWin = () => showBigWin(40, 1);    // 40x = Mega Win
window.testEpicWin = () => showBigWin(60, 1);    // 60x = Epic Win
window.testFreeSpinsStart = (spins = 10) => showNewFreeSpinsPortal(spins);
window.testFreeSpinsEnd = (win = 250) => showNewFreeSpinsEnd(win);

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if (e.shiftKey && e.key === 'B') testBigWin();
    if (e.shiftKey && e.key === 'M') testMegaWin();
    if (e.shiftKey && e.key === 'E') testEpicWin();
    if (e.shiftKey && e.key === 'F') testFreeSpinsStart(10);
    if (e.shiftKey && e.key === 'W') testFreeSpinsEnd(500);
});

console.log('Win display test shortcuts:');
console.log('  Shift+B = Big Win test');
console.log('  Shift+M = Mega Win test');
console.log('  Shift+E = Epic Win test');
console.log('  Shift+F = Free Spins start test');
console.log('  Shift+W = Free Spins end (Win) test');

// API call with full logging
async function api(endpoint, data) {
    const res = await fetch(API + endpoint, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + TOKEN
        },
        body: JSON.stringify(data)
    });
    const json = await res.json();
    console.log('FULL API RESPONSE for', endpoint, ':', JSON.stringify(json, null, 2));
    return json;
}

// Get current game state (screen) from API
async function getGameInfo() {
    const res = await api('/game/info', { gid: gid });
    return res;
}

// Initialize game
async function init() {
    await preloadSymbols();
    $('loading').style.display = 'none';
    createGrid();

    const res = await api('/game/new', {
        cid: 1,
        uid: 3,
        alias: GAME_ALIAS
    });

    if (res && res.gid) {
        gid = res.gid;
        balance = res.wallet || 1000;
        if (res.game && res.game.scr) {
            screen = res.game.scr;
            console.log('*** INIT: Calling renderScreen for initial display (no animation) ***');
            await renderScreen(screen, 1, null, false);  // Initial display, no animation
        }
    }

    updateUI();
}

// Change bet
function changeBet(dir) {
    if (spinning) return;
    betIdx = Math.max(0, Math.min(BETS.length - 1, betIdx + dir));
    updateUI();
}

// Main spin function
async function spin() {
    if (spinning) return;

    const bet = BETS[betIdx];
    if (freeFalls <= 0 && balance < bet) {
        alert('Insufficient balance!');
        return;
    }

    spinning = true;
    $('spinBtn').disabled = true;
    totalWin = 0;
    previousHit = null;  // Reset for new spin
    updateMultiplier(1, freeFalls > 0);
    clearWins();
    updateUI();

    // Cascade loop - keep spinning while there are wins
    let cascadeNum = 0;
    let inBonus = freeFalls > 0;
    let loopCount = 0;

    while (true) {
        loopCount++;
        console.log(`\n========== CASCADE LOOP ${loopCount} ==========`);

        // Call spin API
        const res = await api('/slot/spin', {
            gid: gid,
            bet: bet / 20  // bet per line
        });

        if (!res || res.code || res.what) {
            console.log('API Error:', res?.what || 'Unknown error');
            if (res && res.what) alert(res.what);
            break;
        }

        // Update from response
        if (res.wallet !== undefined) balance = res.wallet;
        if (res.game?.fsr !== undefined) freeFalls = res.game.fsr;

        // Get screen data - check multiple possible locations
        let scr = res.game?.scr || res.scr || null;
        const cfn = res.game?.cfn || 1;
        const hit = res.game?.hit || null;
        const wins = res.wins || [];
        const gain = res.game?.gain || 0;

        // If no screen in spin response, fetch from /game/info
        if (!scr) {
            console.log('No screen in spin response, fetching from /game/info...');
            const infoRes = await api('/game/info', { gid: gid });
            scr = infoRes.game?.scr || infoRes.scr;
            console.log('Got screen from /game/info:', scr ? 'YES' : 'NO');
        }

        console.log('CFN:', cfn, '| Wins:', wins.length, '| Screen:', scr ? 'YES' : 'NO');

        // Render screen with fall animation
        if (scr) {
            screen = scr;
            console.log(`\n*** SPIN LOOP ${loopCount}: About to call renderScreen with CFN=${cfn} ***`);
            // Await the render (animation timing is handled inside renderScreen)
            await renderScreen(scr, cfn, hit);
            console.log(`*** SPIN LOOP ${loopCount}: renderScreen returned ***`);

            // Small buffer after animation
            await new Promise(r => setTimeout(r, 100));
            console.log(`*** SPIN LOOP ${loopCount}: ready for next step ***`);
        } else {
            console.log('WARNING: No screen data available!');
        }

        // If no wins, cascade ends
        if (wins.length === 0) {
            console.log('No wins - cascade chain complete');
            break;
        }

        // Process wins
        console.log('WINS DETECTED! Gain:', gain);
        totalWin += gain;

        updateMultiplier(cfn, inBonus);
        showWin(gain);
        updateUI();

        // Show winning cells with glow (includes 800ms wait)
        console.log('Showing wins...');
        await showWins(wins);

        // Check if free spins were just triggered (scatter wins award FS)
        if (res.game?.fsr > 0 && !inBonus) {
            // Free spins just awarded! Show new overlay
            console.log('FREE SPINS TRIGGERED! Count:', res.game.fsr);
            bonusTotalWin = 0;  // Reset bonus total when entering bonus
            await showNewFreeSpinsPortal(res.game.fsr);
            inBonus = true;
        }

        // Small delay before next cascade drop
        console.log('Preparing next cascade...');
        await new Promise(r => setTimeout(r, 150));
    }

    // Done spinning
    console.log('========== SPIN COMPLETE ==========');
    console.log('Total win:', totalWin);

    // Check for big win display (after cascade chain completes)
    const currentBet = BETS[betIdx];
    await showBigWin(totalWin, currentBet);

    // Add this spin's win to bonus total if in bonus
    if (inBonus) {
        bonusTotalWin += totalWin;
    }

    spinning = false;
    $('spinBtn').disabled = false;
    $('spinBtn').textContent = freeFalls > 0 ? 'FREE' : 'SPIN';
    updateMultiplier(1, freeFalls > 0);
    clearWins();
    updateUI();

    // Check if bonus just ended
    if (inBonus && freeFalls <= 0) {
        console.log('BONUS ENDED! Total bonus win:', bonusTotalWin);
        await showNewFreeSpinsEnd(bonusTotalWin);
        bonusTotalWin = 0;  // Reset for next bonus
        return;  // Don't auto-spin after bonus ends
    }

    // Auto-spin for free falls
    if (freeFalls > 0) {
        setTimeout(spin, 1000);
    }
}

// Free spins portal display - START of free spins
async function showFreeSpinsPortal(freeSpinsCount) {
    const overlay = document.getElementById('portalOverlay');
    const titleEl = document.getElementById('portalTitle');
    const countEl = document.getElementById('portalCount');
    const subtitleEl = document.getElementById('portalSubtitle');
    const winDisplayEl = document.getElementById('portalWinDisplay');

    // Reset for start display
    titleEl.textContent = 'FREE SPINS';
    countEl.textContent = freeSpinsCount;
    subtitleEl.textContent = 'Good Luck!';
    subtitleEl.style.display = 'block';
    winDisplayEl.style.display = 'none';

    // Reset animations
    titleEl.style.animation = 'none';
    countEl.style.animation = 'none';
    subtitleEl.style.animation = 'none';
    void titleEl.offsetHeight;
    titleEl.style.animation = '';
    countEl.style.animation = '';
    subtitleEl.style.animation = '';

    // Open portal
    overlay.classList.add('active');

    // Wait for animation + display time
    await new Promise(r => setTimeout(r, 3500));

    // Close portal
    overlay.classList.add('closing');
    await new Promise(r => setTimeout(r, 600));

    // Reset
    overlay.classList.remove('active', 'closing');
}

// Free spins portal display - END of free spins with total win
async function showFreeSpinsEnd(totalWinAmount) {
    const overlay = document.getElementById('portalOverlay');
    const titleEl = document.getElementById('portalTitle');
    const countEl = document.getElementById('portalCount');
    const subtitleEl = document.getElementById('portalSubtitle');
    const winDisplayEl = document.getElementById('portalWinDisplay');
    const winAmountEl = document.getElementById('portalWinAmount');

    // Setup for end display
    titleEl.textContent = 'CONGRATULATIONS!';
    countEl.textContent = '';
    subtitleEl.style.display = 'none';
    winDisplayEl.style.display = 'block';
    winAmountEl.textContent = totalWinAmount.toFixed(2);

    // Reset animations
    titleEl.style.animation = 'none';
    winDisplayEl.style.animation = 'none';
    void titleEl.offsetHeight;
    titleEl.style.animation = '';
    winDisplayEl.style.animation = '';

    // Open portal
    overlay.classList.add('active');

    // Wait for display time
    await new Promise(r => setTimeout(r, 4000));

    // Close portal
    overlay.classList.add('closing');
    await new Promise(r => setTimeout(r, 600));

    // Reset
    overlay.classList.remove('active', 'closing');
}

// Count scatters on screen (one per column max)
function countScatters(screen) {
    let count = 0;
    for (let col = 0; col < 5; col++) {
        for (let row = 0; row < 3; row++) {
            if (screen[col][row] === SCATTER_SYMBOL_ID) {
                count++;
                break; // Only count one per column
            }
        }
    }
    return count;
}

// Start
init();
</script>

<!-- Portal Overlay -->
<div class="portal-overlay" id="portalOverlay">
    <div class="portal-container">
        <img src="assets/FSback.webp" class="portal-stone" alt="">
        <div class="portal-text-overlay">
            <div class="portal-title" id="portalTitle">FREE SPINS</div>
            <div class="portal-count" id="portalCount">10</div>
            <div class="portal-subtitle" id="portalSubtitle">Good Luck!</div>
            <div class="portal-win-display" id="portalWinDisplay" style="display: none;">
                TOTAL WIN
                <span class="portal-win-amount" id="portalWinAmount">0.00</span>
            </div>
        </div>
        <div class="portal-particles">
            <span></span><span></span><span></span><span></span>
            <span></span><span></span><span></span><span></span>
        </div>
    </div>
</div>

<!-- Big Win Overlay -->
<div class="bigwin-overlay" id="bigwinOverlay">
    <img src="assets/lighting5.webp" class="bigwin-beam" alt="">
    <img src="assets/lighting1.webp" class="bigwin-lightning" alt="">
    <div class="bigwin-content">
        <img src="assets/FSback.webp" class="bigwin-slab" alt="">
        <div class="bigwin-text">
            <div class="bigwin-tier" id="bigwinTier">BIG WIN</div>
            <div class="bigwin-amount" id="bigwinAmount">0.00</div>
        </div>
    </div>
</div>

<!-- Free Spins Overlay - EPIC VERSION -->
<div class="freespins-overlay" id="freespinsOverlay">
    <!-- Pulsing light burst background -->
    <div class="fs-light-burst" id="fsLightBurst"></div>

    <!-- Layer 1: Starburst - spins FAST -->
    <img src="assets/lighting4.webp" class="fs-starburst" id="fsStarburst" alt="">

    <!-- Layer 2: Portal ring - spins slower -->
    <img src="assets/portal.webp" class="fs-portal" id="fsPortal" alt="">

    <!-- Layer 3: Energy orb - pulses behind slab -->
    <img src="assets/lighting2.webp" class="fs-orb" id="fsOrb" alt="">

    <!-- Layer 4: Horizontal beam - flash on impact -->
    <img src="assets/lighting5.webp" class="fs-beam" id="fsBeam" alt="">

    <!-- Layer 5: Lightning bolt - random flashes -->
    <img src="assets/lighting1.webp" class="fs-bolt" id="fsBolt" alt="">

    <!-- Layer 6: Content (slab + text) -->
    <div class="fs-content" id="fsContent">
        <div class="fs-number" id="fsNumber">10</div>
        <div class="fs-slab-wrapper">
            <img src="assets/slab.webp" class="fs-slab" alt="">
            <div class="fs-label" id="fsLabel">FREE SPINS</div>
        </div>
    </div>
</div>

</body>
</html>
