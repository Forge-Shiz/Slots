<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Area 51 Files</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: #000;
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
}
.game-container {
  position: relative;
  width: 100vw;
  height: 100vh;
  max-width: 100vw;
  max-height: 100vh;
  background: url('assets/bg2.webp') center/cover no-repeat;
  display: flex;
  flex-direction: column;
  align-items: center;
  transition: background 0.5s ease;
  padding-bottom: 140px; /* Space for fixed bottom bar */
}
.game-container.freespins {
  background: url('assets/bg-freespins.webp') center/cover no-repeat;
}

/* Logo */
.logo {
  width: 80%;
  max-width: 350px;
  margin-top: 20px;
  filter: drop-shadow(0 0 20px rgba(0, 255, 136, 0.5));
}

/* Free Spins Banner */
.freespins-banner {
  display: none;
  position: absolute;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #00ff88;
  border-radius: 20px;
  padding: 10px 30px;
  color: #00ff88;
  font-size: 18px;
  font-weight: bold;
  text-shadow: 0 0 10px #00ff88;
  z-index: 100;
  animation: pulse 1s infinite;
}
.freespins-banner.active { display: block; }
@keyframes pulse {
  0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.5); }
  50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.8); }
}

/* Expanding Symbol Display */
.expanding-symbol {
  display: none;
  position: absolute;
  top: 140px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid #ffd700;
  border-radius: 15px;
  padding: 8px 20px;
  color: #ffd700;
  font-size: 14px;
  z-index: 100;
  align-items: center;
  gap: 10px;
}
.expanding-symbol.active { display: flex; }
.expanding-symbol img { width: 100px; height: 100px; }

/* Reels Container - Custom frame using reel.webp */
.reels-container {
  position: relative;
  margin-top: 15px;
  margin-bottom: auto;
  padding: 40px 35px;
  background: transparent;
  border: none;
  overflow: hidden; /* CRITICAL: clips symbols outside the frame */
}
/* Frame overlay using reel.webp */
.reels-container::before {
  content: '';
  position: absolute;
  top: -12px;
  left: -12px;
  right: -12px;
  bottom: -12px;
  background: url('assets/reel.webp') center/100% 100% no-repeat;
  pointer-events: none;
  z-index: 10; /* Frame sits on top of reels */
}
.reels {
  display: flex;
  gap: 6px;
  position: relative;
  z-index: 1;
}
.reel-window {
  overflow: hidden; /* Clips symbols during spin animation */
  height: 526px; /* 3 cells * 170px + 2 gaps * 8px = 526px */
  position: relative;
}
.reel-strip {
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: relative;
}
/* Symbol cells - Semi-transparent background */
.reel-cell {
  width: 170px;
  height: 170px;
  background: rgba(0, 0, 0, 0.55);
  border-radius: 12px;
  border: 2px solid rgba(255, 255, 255, 0.12);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  flex-shrink: 0;
  box-sizing: border-box;
  box-shadow:
    inset 0 2px 6px rgba(0, 0, 0, 0.4),
    0 2px 8px rgba(0, 0, 0, 0.5);
}
/* Symbol images - 85% of cell size */
.reel-cell img {
  width: 145px;
  height: 145px;
  object-fit: contain;
}
.reel-cell.winner {
  border-color: #ffd700 !important;
  border-width: 3px;
  background: rgba(255, 215, 0, 0.15);
  box-shadow:
    0 0 20px rgba(255, 215, 0, 0.8),
    0 0 40px rgba(255, 215, 0, 0.4),
    inset 0 0 15px rgba(255, 215, 0, 0.3);
  animation: winPulse 0.5s ease infinite alternate;
  z-index: 25;
}
.reel-cell.expanded {
  border-color: #ff00ff !important;
  border-width: 3px;
  background: rgba(255, 0, 255, 0.15);
  box-shadow:
    0 0 20px rgba(255, 0, 255, 0.8),
    0 0 40px rgba(255, 0, 255, 0.4),
    inset 0 0 15px rgba(255, 0, 255, 0.3);
  z-index: 25;
}
.reel-cell.expanding {
  animation: expandPulse 0.6s ease-out;
  border-color: #ff00ff !important;
  background: rgba(255, 0, 255, 0.25);
  box-shadow: 0 0 30px rgba(255, 0, 255, 0.9), inset 0 0 20px rgba(255, 0, 255, 0.4);
  z-index: 30;
}
@keyframes expandPulse {
  0% { transform: scale(1); opacity: 0.7; }
  50% { transform: scale(1.15); opacity: 1; }
  100% { transform: scale(1); opacity: 1; }
}
@keyframes winPulse {
  from { transform: scale(1); }
  to { transform: scale(1.05); }
}

/* ===========================================
   ANTICIPATION EFFECTS - Enhanced CSS
   =========================================== */

/* Anticipation Container - wraps the reel for effects */
.anticipation-container {
  position: absolute;
  top: -12px;
  left: -12px;
  right: -12px;
  bottom: -12px;
  pointer-events: none;
  z-index: 5;
  opacity: 0;
  transition: opacity 0.3s ease;
  border-radius: 16px;
  overflow: visible;
}

.anticipation-container.active {
  opacity: 1;
}

/* LAYER 1: Pulsing Glow Border on container */
.anticipation-container.active {
  box-shadow:
    0 0 15px #00ff00,
    0 0 30px #00aa00,
    0 0 45px rgba(0, 255, 0, 0.4);
  animation: anticipationContainerPulse 0.8s ease-in-out infinite;
}

.anticipation-container.hot {
  box-shadow:
    0 0 20px #00ff00,
    0 0 40px #ffdd00,
    0 0 60px #ff8800,
    0 0 80px rgba(255, 200, 0, 0.5);
  animation: anticipationContainerPulseHot 0.4s ease-in-out infinite, screenShake 0.08s ease-in-out infinite;
}

@keyframes anticipationContainerPulse {
  0%, 100% {
    box-shadow:
      0 0 15px #00ff00,
      0 0 30px #00aa00,
      0 0 45px rgba(0, 255, 0, 0.4);
  }
  50% {
    box-shadow:
      0 0 30px #00ff00,
      0 0 60px #44ff44,
      0 0 80px #00aa00,
      0 0 100px rgba(0, 255, 0, 0.6);
  }
}

@keyframes anticipationContainerPulseHot {
  0%, 100% {
    box-shadow:
      0 0 20px #00ff00,
      0 0 40px #ffdd00,
      0 0 60px #ff8800,
      0 0 80px rgba(255, 200, 0, 0.5);
  }
  50% {
    box-shadow:
      0 0 35px #88ff00,
      0 0 70px #ffff00,
      0 0 100px #ffd700,
      0 0 130px rgba(255, 255, 0, 0.7);
  }
}

/* Animated Gradient Border */
.anticipation-border {
  position: absolute;
  inset: 0;
  border-radius: 16px;
  padding: 4px;
  background: linear-gradient(
    45deg,
    #00ff00, #22ff44, #00ff88, #88ff00, #00ff00
  );
  background-size: 300% 300%;
  animation: anticipationBorderFlow 1.5s linear infinite;
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
}

.anticipation-container.active .anticipation-border {
  animation: anticipationBorderFlow 1.5s linear infinite, edgeFlicker 0.15s ease-in-out infinite;
}

/* Hot mode - green/gold mix */
.anticipation-container.hot .anticipation-border {
  padding: 5px;
  background: linear-gradient(
    45deg,
    #00ff00, #88ff00, #ffdd00, #ffd700, #ff8800, #ffff00, #00ff00
  );
  background-size: 400% 400%;
  animation: anticipationBorderFlowHot 0.6s linear infinite, edgeFlickerHot 0.1s ease-in-out infinite;
}

@keyframes anticipationBorderFlow {
  0% { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}

@keyframes anticipationBorderFlowHot {
  0% { background-position: 0% 50%; }
  100% { background-position: 400% 50%; }
}

/* Edge Flicker Effect */
@keyframes edgeFlicker {
  0%, 100% { opacity: 1; }
  25% { opacity: 0.85; }
  50% { opacity: 1; }
  75% { opacity: 0.9; }
}

@keyframes edgeFlickerHot {
  0%, 100% { opacity: 1; }
  20% { opacity: 0.7; }
  40% { opacity: 1; }
  60% { opacity: 0.8; }
  80% { opacity: 1; }
}

/* Inner Glow Overlay */
.anticipation-glow-inner {
  position: absolute;
  inset: 4px;
  border-radius: 12px;
  background: radial-gradient(
    ellipse at center,
    rgba(0, 255, 0, 0.2) 0%,
    rgba(0, 255, 0, 0.08) 50%,
    transparent 70%
  );
  animation: innerGlowPulse 1s ease-in-out infinite;
}

.anticipation-container.hot .anticipation-glow-inner {
  background: radial-gradient(
    ellipse at center,
    rgba(255, 255, 0, 0.3) 0%,
    rgba(255, 200, 0, 0.15) 50%,
    transparent 70%
  );
  animation: innerGlowPulseHot 0.5s ease-in-out infinite;
}

@keyframes innerGlowPulse {
  0%, 100% { opacity: 0.6; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.02); }
}

@keyframes innerGlowPulseHot {
  0%, 100% { opacity: 0.7; transform: scale(1); }
  50% { opacity: 1; transform: scale(1.04); }
}

/* LAYER 2: anticipation.webp Particle Overlay */
.anticipation-webp-overlay {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 180%;
  height: 100%;
  background: url('assets/anticipation.webp') center/contain no-repeat;
  pointer-events: none;
  opacity: 0;
  z-index: 10;
  mix-blend-mode: screen;
}

.anticipation-container.active .anticipation-webp-overlay {
  opacity: 0.9;
  animation: webpOverlayPulse 1.2s ease-in-out infinite;
}

.anticipation-container.hot .anticipation-webp-overlay {
  opacity: 1;
  filter: brightness(1.3) saturate(1.2);
  animation: webpOverlayPulseHot 0.6s ease-in-out infinite;
}

@keyframes webpOverlayPulse {
  0%, 100% { opacity: 0.85; transform: translateX(-50%) scale(1); }
  50% { opacity: 1; transform: translateX(-50%) scale(1.02); }
}

@keyframes webpOverlayPulseHot {
  0%, 100% { opacity: 0.9; transform: translateX(-50%) scale(1); }
  50% { opacity: 1; transform: translateX(-50%) scale(1.05); }
}

/* LAYER 3: BRIGHT Scanning Line Effect */
.anticipation-scanline {
  position: absolute;
  left: 0;
  right: 0;
  height: 10px;
  background: linear-gradient(
    180deg,
    transparent 0%,
    rgba(0, 255, 100, 0.5) 20%,
    rgba(0, 255, 100, 0.95) 40%,
    rgba(255, 255, 255, 0.9) 50%,
    rgba(0, 255, 100, 0.95) 60%,
    rgba(0, 255, 100, 0.5) 80%,
    transparent 100%
  );
  box-shadow:
    0 0 20px #00ff00,
    0 0 40px #00ff00,
    0 0 60px rgba(0, 255, 100, 0.8),
    0 0 80px rgba(0, 255, 100, 0.4);
  z-index: 15;
  animation: scanlineMove 2s ease-in-out infinite;
  opacity: 0;
}

.anticipation-container.active .anticipation-scanline {
  opacity: 1;
}

/* HOT mode scanline - even brighter with gold */
.anticipation-container.hot .anticipation-scanline {
  height: 14px;
  background: linear-gradient(
    180deg,
    transparent 0%,
    rgba(255, 220, 0, 0.6) 15%,
    rgba(0, 255, 100, 0.9) 30%,
    rgba(255, 255, 255, 1) 50%,
    rgba(0, 255, 100, 0.9) 70%,
    rgba(255, 220, 0, 0.6) 85%,
    transparent 100%
  );
  box-shadow:
    0 0 25px #ffff00,
    0 0 50px #00ff00,
    0 0 75px #ffd700,
    0 0 100px rgba(255, 255, 0, 0.6);
  animation: scanlineMoveHot 1.2s ease-in-out infinite;
}

@keyframes scanlineMove {
  0%, 100% { top: -10px; }
  50% { top: calc(100% - 0px); }
}

@keyframes scanlineMoveHot {
  0%, 100% { top: -14px; }
  50% { top: calc(100% + 4px); }
}

/* CSS Particle Container (backup/addition to webp) */
.anticipation-particles {
  position: absolute;
  inset: 0;
  overflow: hidden;
  pointer-events: none;
  border-radius: 14px;
  z-index: 8;
}

/* Individual Particle */
.anticipation-particle {
  position: absolute;
  width: 5px;
  height: 5px;
  border-radius: 50%;
  pointer-events: none;
  opacity: 0;
}

.anticipation-container.active .anticipation-particle {
  animation: particleFloat 2.5s ease-out infinite;
}

.anticipation-container.hot .anticipation-particle {
  animation: particleFloatHot 1.2s ease-out infinite;
}

/* Particle colors */
.anticipation-particle.green {
  background: #00ff00;
  box-shadow: 0 0 8px #00ff00, 0 0 16px #00ff00;
}
.anticipation-particle.gold {
  background: #ffd700;
  box-shadow: 0 0 8px #ffd700, 0 0 16px #ffd700;
}
.anticipation-particle.white {
  background: #ffffff;
  box-shadow: 0 0 8px #ffffff, 0 0 16px rgba(255, 255, 255, 0.9);
}

/* Hot mode particles are bigger */
.anticipation-container.hot .anticipation-particle {
  width: 7px;
  height: 7px;
}
.anticipation-container.hot .anticipation-particle.green {
  box-shadow: 0 0 12px #88ff00, 0 0 24px #00ff00;
}
.anticipation-container.hot .anticipation-particle.gold {
  box-shadow: 0 0 12px #ffd700, 0 0 24px #ffff00;
}
.anticipation-container.hot .anticipation-particle.white {
  box-shadow: 0 0 12px #ffffff, 0 0 24px rgba(255, 255, 255, 1);
}

@keyframes particleFloat {
  0% {
    opacity: 0;
    transform: translateY(100%) scale(0.5);
  }
  15% {
    opacity: 1;
  }
  85% {
    opacity: 0.9;
  }
  100% {
    opacity: 0;
    transform: translateY(-100%) scale(1.3);
  }
}

@keyframes particleFloatHot {
  0% {
    opacity: 0;
    transform: translateY(100%) scale(0.8);
  }
  10% {
    opacity: 1;
  }
  80% {
    opacity: 1;
  }
  100% {
    opacity: 0;
    transform: translateY(-130%) scale(1.6);
  }
}

/* Screen Shake for Hot Mode */
@keyframes screenShake {
  0%, 100% { transform: translate(0, 0); }
  20% { transform: translate(-2px, 1px); }
  40% { transform: translate(2px, -1px); }
  60% { transform: translate(-1px, -2px); }
  80% { transform: translate(1px, 2px); }
}

/* Alert Flicker for Hot Mode */
.anticipation-alert {
  position: absolute;
  top: -35px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 14px;
  font-weight: bold;
  letter-spacing: 3px;
  color: #ff3300;
  text-shadow: 0 0 15px #ff0000, 0 0 30px #ff6600, 0 0 45px #ffaa00;
  opacity: 0;
  pointer-events: none;
  z-index: 20;
}

.anticipation-container.hot .anticipation-alert {
  animation: alertFlicker 0.2s ease-in-out infinite;
}

@keyframes alertFlicker {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}

/* Corner Accents with enhanced glow */
.anticipation-corner {
  position: absolute;
  width: 24px;
  height: 24px;
  border-color: #00ff00;
  border-style: solid;
  border-width: 0;
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 12;
}

.anticipation-container.active .anticipation-corner {
  opacity: 1;
  animation: cornerPulse 0.8s ease-in-out infinite;
}

.anticipation-container.hot .anticipation-corner {
  border-color: #ffdd00;
  animation: cornerPulseHot 0.35s ease-in-out infinite;
}

.anticipation-corner.top-left {
  top: 0; left: 0;
  border-top-width: 4px;
  border-left-width: 4px;
  border-top-left-radius: 12px;
}
.anticipation-corner.top-right {
  top: 0; right: 0;
  border-top-width: 4px;
  border-right-width: 4px;
  border-top-right-radius: 12px;
}
.anticipation-corner.bottom-left {
  bottom: 0; left: 0;
  border-bottom-width: 4px;
  border-left-width: 4px;
  border-bottom-left-radius: 12px;
}
.anticipation-corner.bottom-right {
  bottom: 0; right: 0;
  border-bottom-width: 4px;
  border-right-width: 4px;
  border-bottom-right-radius: 12px;
}

@keyframes cornerPulse {
  0%, 100% {
    opacity: 0.7;
    box-shadow: 0 0 10px #00ff00, 0 0 20px rgba(0, 255, 0, 0.5);
  }
  50% {
    opacity: 1;
    box-shadow: 0 0 20px #00ff00, 0 0 40px #44ff44;
  }
}

@keyframes cornerPulseHot {
  0%, 100% {
    opacity: 0.8;
    box-shadow: 0 0 15px #ffdd00, 0 0 30px rgba(255, 200, 0, 0.6);
  }
  50% {
    opacity: 1;
    box-shadow: 0 0 30px #ffff00, 0 0 50px #ffd700, 0 0 70px #ff8800;
  }
}

/* Energy Lines (additional effect for hot mode) */
.anticipation-energy-line {
  position: absolute;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, #ffd700, transparent);
  opacity: 0;
  pointer-events: none;
}

.anticipation-container.hot .anticipation-energy-line {
  animation: energyLinePulse 0.5s ease-in-out infinite;
}

.anticipation-energy-line:nth-child(1) { top: 25%; animation-delay: 0s; }
.anticipation-energy-line:nth-child(2) { top: 50%; animation-delay: 0.15s; }
.anticipation-energy-line:nth-child(3) { top: 75%; animation-delay: 0.3s; }

@keyframes energyLinePulse {
  0%, 100% { opacity: 0; transform: scaleX(0.3); }
  50% { opacity: 0.8; transform: scaleX(1); }
}

/* Payline Overlay */
.payline-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 50;
}
.payline-overlay line {
  stroke-width: 4;
  stroke-linecap: round;
  fill: none;
  opacity: 0;
}
.payline-overlay line.active {
  animation: paylineFlash 0.4s ease-in-out 3;
}
@keyframes paylineFlash {
  0%, 100% { opacity: 0; }
  50% { opacity: 1; }
}

/* Bottom Control Bar */
.bottom-bar {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.85) 100%);
  padding: 12px 20px 16px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  z-index: 100;
}

/* Stats Row */
.stats-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  max-width: 400px;
}
.stat-item {
  text-align: center;
  min-width: 80px;
}
.stat-label {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  color: rgba(255,255,255,0.4);
  margin-bottom: 2px;
}
.stat-value {
  font-size: 18px;
  font-weight: 700;
  color: #fff;
  font-variant-numeric: tabular-nums;
}
.stat-value.win-active {
  color: #ffd700;
  text-shadow: 0 0 15px rgba(255,215,0,0.5);
}
.stat-value.bet {
  color: #00d4aa;
}

/* Spin Button */
.spin-btn {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  border: 3px solid #00d4aa;
  background: linear-gradient(145deg, #1a2030 0%, #0d1015 100%);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  box-shadow: 0 0 20px rgba(0,212,170,0.3), inset 0 2px 4px rgba(255,255,255,0.1);
}
.spin-btn:hover:not(:disabled) {
  transform: scale(1.05);
  box-shadow: 0 0 35px rgba(0,212,170,0.5);
  border-color: #00ffcc;
}
.spin-btn:active:not(:disabled) {
  transform: scale(0.95);
}
.spin-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.spin-btn svg {
  width: 28px;
  height: 28px;
  fill: #00d4aa;
}
.spin-btn.spinning svg {
  animation: spinRotate 0.6s linear infinite;
}
@keyframes spinRotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* Control Buttons Row */
.controls-row {
  display: flex;
  align-items: center;
  gap: 16px;
}
.ctrl-btn {
  width: 38px;
  height: 38px;
  border-radius: 50%;
  border: 1.5px solid rgba(255,255,255,0.15);
  background: rgba(255,255,255,0.05);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}
.ctrl-btn:hover {
  background: rgba(255,255,255,0.1);
  border-color: rgba(255,255,255,0.25);
}
.ctrl-btn.active {
  border-color: #00d4aa;
  background: rgba(0,212,170,0.15);
}
.ctrl-btn svg {
  width: 18px;
  height: 18px;
  fill: rgba(255,255,255,0.6);
}
.ctrl-btn:hover svg {
  fill: #fff;
}
.ctrl-btn.active svg {
  fill: #00d4aa;
}

/* Win Display Overlay */
.win-display {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.8);
  background: radial-gradient(ellipse at center, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.85) 100%);
  border: 2px solid #ffd700;
  border-radius: 16px;
  padding: 24px 40px;
  z-index: 250;
  text-align: center;
  opacity: 0;
  transition: all 0.3s ease;
  box-shadow: 0 0 40px rgba(255,215,0,0.3);
}
.win-display.active {
  display: block;
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
}
.win-display .win-label {
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 2px;
  text-transform: uppercase;
  color: #ffd700;
  margin-bottom: 4px;
}
.win-display .win-amount {
  font-size: 42px;
  font-weight: 700;
  color: #fff;
  text-shadow: 0 0 20px rgba(255,215,0,0.4);
}

/* Bet Popup */
.popup-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  z-index: 300;
  justify-content: center;
  align-items: center;
}
.popup-overlay.active { display: flex; }
.popup {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #00ff88;
  border-radius: 20px;
  padding: 30px;
  max-width: 350px;
  width: 90%;
  color: #fff;
}
.popup h2 {
  color: #00ff88;
  text-align: center;
  margin-bottom: 20px;
}
.popup-close {
  position: absolute;
  top: 10px;
  right: 15px;
  color: #fff;
  font-size: 24px;
  cursor: pointer;
}
.bet-options {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
}
.bet-option {
  padding: 15px;
  background: rgba(0, 255, 136, 0.1);
  border: 2px solid rgba(0, 255, 136, 0.3);
  border-radius: 10px;
  color: #fff;
  font-size: 18px;
  cursor: pointer;
  text-align: center;
  transition: all 0.2s;
}
.bet-option:hover, .bet-option.selected {
  background: rgba(0, 255, 136, 0.3);
  border-color: #00ff88;
}

/* Info Popup */
.info-content {
  max-height: 60vh;
  overflow-y: auto;
}
.info-content h3 {
  color: #ffd700;
  margin: 15px 0 10px;
  font-size: 14px;
  border-bottom: 1px solid rgba(255, 215, 0, 0.3);
  padding-bottom: 5px;
}
.info-content p {
  color: #ccc;
  line-height: 1.5;
  margin-bottom: 6px;
  font-size: 12px;
}
.info-content .symbol-row {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 8px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  margin-bottom: 4px;
  border-left: 3px solid transparent;
}
.info-content .symbol-row.premium {
  border-left-color: #ff00ff;
  background: rgba(255, 0, 255, 0.1);
}
.info-content .symbol-row.high {
  border-left-color: #00ffff;
  background: rgba(0, 255, 255, 0.08);
}
.info-content .symbol-row.medium {
  border-left-color: #00ff88;
  background: rgba(0, 255, 136, 0.06);
}
.info-content .symbol-row.low {
  border-left-color: #888;
}
.info-content .symbol-row.scatter-highlight {
  border-left-color: #ffd700;
  background: rgba(255, 215, 0, 0.15);
  border: 1px solid rgba(255, 215, 0, 0.4);
}
.info-content .symbol-row img {
  width: 36px;
  height: 36px;
  flex-shrink: 0;
}
.info-content .payout-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.info-content .payout-info strong {
  color: #fff;
  font-size: 12px;
}
.info-content .payout-info .payouts {
  color: #aaa;
  font-size: 10px;
  font-family: monospace;
}

/* Paylines Grid */
.paylines-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 6px;
  margin: 10px 0;
}
.payline-diagram {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 6px;
  background: rgba(0,0,0,0.4);
  border-radius: 6px;
}
.payline-diagram .line-num {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: bold;
  color: #fff;
  flex-shrink: 0;
}
.payline-diagram svg {
  width: 50px;
  height: 24px;
  flex-shrink: 0;
}
.payline-diagram .line-desc {
  font-size: 9px;
  color: #999;
  white-space: nowrap;
}

/* ===========================================
   RESPONSIVE - Mobile Layout Fixes
   =========================================== */

/* Mobile screens (max-width: 600px)
   Target: 5 cols * 58px + 4 gaps * 3px + 2 padding * 8px = 318px
   Leaves ~50px margin on 375px screen */
@media (max-width: 600px) {
  .logo {
    max-width: 180px;
    margin-top: 8px;
  }

  .reels-container {
    padding: 24px 20px;
    margin-top: 8px;
  }

  .reels-container::before {
    top: -8px;
    left: -8px;
    right: -8px;
    bottom: -8px;
  }

  .reels {
    gap: 2px;
  }

  .reel-strip {
    gap: 2px;
  }

  .reel-window {
    height: calc(3 * 54px + 2 * 2px); /* 3 cells * 54px + 2 gaps * 2px = 166px */
  }

  .reel-cell {
    width: 54px;
    height: 54px;
    border-radius: 6px;
    border-width: 1px;
    box-shadow:
      inset 0 1px 2px rgba(0, 0, 0, 0.3),
      0 1px 4px rgba(0, 0, 0, 0.4);
  }

  .reel-cell img {
    width: 46px;
    height: 46px;
  }

  .game-container {
    padding-bottom: 105px;
  }

  .bottom-bar {
    padding: 6px 12px 10px;
    gap: 5px;
  }

  .stats-row {
    max-width: 280px;
  }

  .stat-item {
    min-width: 60px;
  }

  .stat-label {
    font-size: 8px;
    letter-spacing: 1px;
  }

  .stat-value {
    font-size: 14px;
  }

  .spin-btn {
    width: 48px;
    height: 48px;
    border-width: 2px;
  }

  .spin-btn svg {
    width: 20px;
    height: 20px;
  }

  .ctrl-btn {
    width: 30px;
    height: 30px;
  }

  .ctrl-btn svg {
    width: 14px;
    height: 14px;
  }

  .controls-row {
    gap: 10px;
  }

  .win-display {
    padding: 14px 20px;
    border-radius: 12px;
  }

  .win-display .win-label {
    font-size: 10px;
    letter-spacing: 1.5px;
  }

  .win-display .win-amount {
    font-size: 26px;
  }

  .freespins-banner {
    top: 55px;
    font-size: 11px;
    padding: 5px 14px;
    border-radius: 12px;
  }

  .expanding-symbol {
    top: 80px;
    font-size: 9px;
    padding: 4px 10px;
    border-radius: 10px;
  }

  .expanding-symbol img {
    width: 35px;
    height: 35px;
  }

  .popup {
    padding: 20px;
    max-width: 300px;
  }

  .popup h2 {
    font-size: 16px;
    margin-bottom: 15px;
  }

  .bet-option {
    padding: 10px;
    font-size: 14px;
  }

  .payline-overlay line {
    stroke-width: 2;
  }

  /* Mobile anticipation adjustments */
  .anticipation-container {
    top: -8px;
    left: -8px;
    right: -8px;
    bottom: -8px;
    border-radius: 10px;
  }

  .anticipation-border {
    border-radius: 10px;
    padding: 2px;
  }

  .anticipation-glow-inner {
    border-radius: 8px;
  }

  /* Still visible scanline on mobile */
  .anticipation-scanline {
    height: 6px;
  }

  .anticipation-container.hot .anticipation-scanline {
    height: 8px;
  }

  .anticipation-particle {
    width: 3px;
    height: 3px;
  }

  .anticipation-container.hot .anticipation-particle {
    width: 5px;
    height: 5px;
  }

  .anticipation-corner {
    width: 14px;
    height: 14px;
    border-width: 0;
  }

  .anticipation-webp-overlay {
    width: 160%;
  }

  .anticipation-corner.top-left { border-top-width: 2px; border-left-width: 2px; }
  .anticipation-corner.top-right { border-top-width: 2px; border-right-width: 2px; }
  .anticipation-corner.bottom-left { border-bottom-width: 2px; border-left-width: 2px; }
  .anticipation-corner.bottom-right { border-bottom-width: 2px; border-right-width: 2px; }

  .anticipation-alert {
    font-size: 9px;
    top: -22px;
  }
}

/* Medium screens (601px - 900px) */
@media (min-width: 601px) and (max-width: 900px) {
  .logo {
    max-width: 260px;
    margin-top: 12px;
  }

  .reels-container {
    padding: 32px 26px;
  }

  .reels-container::before {
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
  }

  .reels {
    gap: 4px;
  }

  .reel-strip {
    gap: 4px;
  }

  .reel-window {
    height: calc(3 * 95px + 2 * 4px); /* 293px */
  }

  .reel-cell {
    width: 95px;
    height: 95px;
    border-radius: 10px;
    box-shadow:
      inset 0 1px 3px rgba(0, 0, 0, 0.3),
      0 2px 6px rgba(0, 0, 0, 0.4);
  }

  .reel-cell img {
    width: 80px;
    height: 80px;
  }

  .game-container {
    padding-bottom: 120px;
  }

  .win-display .win-amount {
    font-size: 34px;
  }

  /* Medium screen anticipation */
  .anticipation-container {
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    border-radius: 12px;
  }

  .anticipation-border {
    border-radius: 12px;
  }

  .anticipation-glow-inner {
    border-radius: 10px;
  }

  .anticipation-scanline {
    height: 8px;
  }

  .anticipation-container.hot .anticipation-scanline {
    height: 12px;
  }

  .anticipation-corner {
    width: 18px;
    height: 18px;
  }

  .anticipation-webp-overlay {
    width: 170%;
  }
}

/* Large screens (901px+) - use default styles */
@media (min-width: 901px) {
  .reel-window {
    height: calc(3 * 170px + 2 * 8px); /* 526px */
  }
}

/* Landscape mobile / very short screens */
@media (max-height: 500px) {
  .logo {
    max-width: 120px;
    margin-top: 4px;
  }

  .reels-container {
    padding: 18px 14px;
    margin-top: 4px;
  }

  .reels-container::before {
    top: -6px;
    left: -6px;
    right: -6px;
    bottom: -6px;
  }

  .reels {
    gap: 2px;
  }

  .reel-strip {
    gap: 2px;
  }

  .reel-window {
    height: calc(3 * 48px + 2 * 2px); /* 148px */
  }

  .reel-cell {
    width: 48px;
    height: 48px;
    border-radius: 6px;
    border-width: 1px;
    box-shadow:
      inset 0 1px 2px rgba(0, 0, 0, 0.3),
      0 1px 3px rgba(0, 0, 0, 0.4);
  }

  .reel-cell img {
    width: 40px;
    height: 40px;
  }

  .game-container {
    padding-bottom: 90px;
  }

  .bottom-bar {
    padding: 4px 8px 6px;
    gap: 3px;
  }

  .spin-btn {
    width: 40px;
    height: 40px;
  }

  .spin-btn svg {
    width: 18px;
    height: 18px;
  }

  .ctrl-btn {
    width: 26px;
    height: 26px;
  }

  .ctrl-btn svg {
    width: 12px;
    height: 12px;
  }

  .stat-value {
    font-size: 12px;
  }

  .freespins-banner,
  .expanding-symbol {
    display: none !important;
  }

  /* Landscape anticipation */
  .anticipation-container {
    top: -6px;
    left: -6px;
    right: -6px;
    bottom: -6px;
    border-radius: 8px;
  }

  .anticipation-border {
    border-radius: 8px;
    padding: 2px;
  }

  .anticipation-particle {
    width: 3px;
    height: 3px;
  }

  .anticipation-scanline {
    height: 5px;
  }

  .anticipation-container.hot .anticipation-scanline {
    height: 7px;
  }

  .anticipation-alert {
    font-size: 10px;
    top: -20px;
  }

  .anticipation-corner {
    width: 12px;
    height: 12px;
  }

  .anticipation-webp-overlay {
    width: 150%;
  }
}

/* Extra small screens (under 350px width) */
@media (max-width: 350px) {
  .reels-container {
    padding: 20px 16px;
  }

  .reels-container::before {
    top: -6px;
    left: -6px;
    right: -6px;
    bottom: -6px;
  }

  .reels {
    gap: 2px;
  }

  .reel-strip {
    gap: 2px;
  }

  .reel-window {
    height: calc(3 * 46px + 2 * 2px); /* 142px */
  }

  .reel-cell {
    width: 46px;
    height: 46px;
    border-radius: 5px;
    box-shadow:
      inset 0 1px 2px rgba(0, 0, 0, 0.3),
      0 1px 3px rgba(0, 0, 0, 0.4);
  }

  .reel-cell img {
    width: 38px;
    height: 38px;
  }

  /* Extra small anticipation */
  .anticipation-container {
    top: -6px;
    left: -6px;
    right: -6px;
    bottom: -6px;
    border-radius: 8px;
  }

  .anticipation-particle {
    width: 3px;
    height: 3px;
  }

  .anticipation-container.hot .anticipation-particle {
    width: 4px;
    height: 4px;
  }

  .anticipation-scanline {
    height: 5px;
  }

  .anticipation-container.hot .anticipation-scanline {
    height: 7px;
  }

  .anticipation-alert {
    font-size: 8px;
    top: -18px;
  }

  .anticipation-webp-overlay {
    width: 140%;
  }
}

/* ===========================================
   BONUS POPUP
   =========================================== */
.bonus-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  z-index: 500;
  justify-content: center;
  align-items: center;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.bonus-overlay.active {
  display: flex;
  opacity: 1;
}

.bonus-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  cursor: pointer;
}

.bonus-image-wrapper {
  position: relative;
  display: inline-block;
}

.bonus-image {
  max-width: 90vw;
  max-height: 70vh;
  width: auto;
  height: auto;
  object-fit: contain;
  filter: drop-shadow(0 0 30px rgba(0, 255, 136, 0.5));
}

@media (min-width: 601px) {
  .bonus-image {
    max-width: 500px;
  }
}

.bonus-spins-text {
  position: absolute;
  top: 62%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  z-index: 10;
}

.spins-number {
  font-size: 56px;
  font-weight: 900;
  color: #ffd700;
  text-shadow:
    0 0 20px rgba(255, 215, 0, 0.8),
    0 0 40px rgba(255, 215, 0, 0.5),
    2px 2px 4px rgba(0, 0, 0, 0.8);
  line-height: 1;
  font-family: 'Impact', 'Arial Black', sans-serif;
}

.spins-label {
  font-size: 22px;
  font-weight: 700;
  color: #ffd700;
  text-shadow:
    0 0 15px rgba(255, 215, 0, 0.7),
    1px 1px 3px rgba(0, 0, 0, 0.8);
  letter-spacing: 3px;
  margin-top: 4px;
  font-family: 'Segoe UI', sans-serif;
}

.tap-continue {
  margin-top: 20px;
  font-size: 16px;
  font-weight: 600;
  color: #ffd700;
  letter-spacing: 2px;
  text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
  animation: tapPulse 1.5s ease-in-out infinite;
}

@keyframes tapPulse {
  0%, 100% {
    opacity: 0.6;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.05);
  }
}

/* Mobile adjustments for bonus popup */
@media (max-width: 600px) {
  .spins-number {
    font-size: 42px;
  }

  .spins-label {
    font-size: 16px;
    letter-spacing: 2px;
  }

  .tap-continue {
    font-size: 13px;
    margin-top: 15px;
  }
}

@media (max-width: 400px) {
  .spins-number {
    font-size: 36px;
  }

  .spins-label {
    font-size: 14px;
  }
}

/* ===========================================
   BONUS COMPLETE POPUP
   =========================================== */
.bonus-complete-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.9);
  z-index: 500;
  justify-content: center;
  align-items: center;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.bonus-complete-overlay.active {
  display: flex;
  opacity: 1;
}

.bonus-complete-content {
  text-align: center;
  cursor: pointer;
  padding: 40px;
}

.bonus-complete-title {
  font-size: 28px;
  font-weight: 700;
  color: #00ff88;
  letter-spacing: 4px;
  text-transform: uppercase;
  text-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
  margin-bottom: 10px;
}

.bonus-complete-label {
  font-size: 16px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.7);
  letter-spacing: 3px;
  text-transform: uppercase;
  margin-bottom: 15px;
}

.bonus-complete-amount {
  font-size: 72px;
  font-weight: 900;
  color: #ffd700;
  text-shadow:
    0 0 30px rgba(255, 215, 0, 0.8),
    0 0 60px rgba(255, 215, 0, 0.5),
    3px 3px 6px rgba(0, 0, 0, 0.8);
  font-family: 'Impact', 'Arial Black', sans-serif;
  line-height: 1;
}

.bonus-complete-tap {
  margin-top: 30px;
  font-size: 14px;
  font-weight: 600;
  color: rgba(255, 255, 255, 0.6);
  letter-spacing: 2px;
  animation: tapPulse 1.5s ease-in-out infinite;
}

@media (max-width: 600px) {
  .bonus-complete-title {
    font-size: 20px;
  }

  .bonus-complete-amount {
    font-size: 48px;
  }

  .bonus-complete-content {
    padding: 30px;
  }
}
</style>
</head>
<body>
<audio id="bgm" loop src="assets/Area51.mp3"></audio>
<audio id="bonusMusic" loop src="assets/bonus.mp3" preload="auto"></audio>
<!-- Anticipation sound placeholders - add audio files when ready -->
<!-- <audio id="anticipationSound" src="assets/anticipation.mp3" preload="auto"></audio> -->
<!-- <audio id="anticipationHotSound" src="assets/anticipation-hot.mp3" preload="auto"></audio> -->

<div class="game-container" id="gameContainer">
  <img src="assets/logo.webp" alt="Area 51 Files" class="logo">
  
  <div class="freespins-banner" id="freespinsBanner">
    üõ∏ FREE SPINS: <span id="fsCount">0</span> LEFT
  </div>
  
  <div class="expanding-symbol" id="expandingSymbol">
    <span>EXPANDING:</span>
    <img id="expandingImg" src="assets/symbols/1.webp">
  </div>
  
  <div class="reels-container">
    <div class="reels" id="reels"></div>
    <svg class="payline-overlay" id="paylineOverlay"></svg>
  </div>
  
  <div class="win-display" id="winDisplay">
    <div class="win-label">WIN</div>
    <div class="win-amount" id="winAmount">0.00</div>
  </div>
</div>

<!-- Professional Bottom Bar -->
<div class="bottom-bar">
  <div class="stats-row">
    <div class="stat-item">
      <div class="stat-label">Balance</div>
      <div class="stat-value" id="balance">1000.00</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Win</div>
      <div class="stat-value" id="lastWin">0.00</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Bet</div>
      <div class="stat-value bet" id="betDisplay">9.00</div>
    </div>
  </div>

  <div class="controls-row">
    <button class="ctrl-btn" id="betBtn" title="Change Bet">
      <svg viewBox="0 0 24 24"><path d="M11.8 10.9c-2.27-.59-3-1.2-3-2.15 0-1.09 1.01-1.85 2.7-1.85 1.78 0 2.44.85 2.5 2.1h2.21c-.07-1.72-1.12-3.3-3.21-3.81V3h-3v2.16c-1.94.42-3.5 1.68-3.5 3.61 0 2.31 1.91 3.46 4.7 4.13 2.5.6 3 1.48 3 2.41 0 .69-.49 1.79-2.7 1.79-2.06 0-2.87-.92-2.98-2.1h-2.2c.12 2.19 1.76 3.42 3.68 3.83V21h3v-2.15c1.95-.37 3.5-1.5 3.5-3.55 0-2.84-2.43-3.81-4.7-4.4z"/></svg>
    </button>
    <button class="spin-btn" id="spinBtn">
      <svg viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>
    </button>
    <button class="ctrl-btn" id="soundBtn" title="Toggle Sound">
      <svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
    </button>
    <button class="ctrl-btn" id="infoBtn" title="Game Info">
      <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
    </button>
  </div>
</div>

<!-- Bet Popup -->
<div class="popup-overlay" id="betPopup">
  <div class="popup">
    <h2>SELECT BET</h2>
    <div class="bet-options" id="betOptions"></div>
    <button class="ctrl-btn" style="margin: 20px auto 0; display: block;" onclick="closeBetPopup()">‚úì</button>
  </div>
</div>

<!-- Info Popup -->
<div class="popup-overlay" id="infoPopup">
  <div class="popup" style="max-width: 420px;">
    <h2>üõ∏ AREA 51 FILES</h2>
    <div class="info-content">

      <h3>üìã How to Play</h3>
      <p>‚Ä¢ Spin the reels to match symbols from <strong>left to right</strong></p>
      <p>‚Ä¢ Match <strong>3, 4, or 5</strong> identical symbols on a payline to win</p>
      <p>‚Ä¢ <strong>10 paylines</strong> are always active</p>
      <p>‚Ä¢ Wins are multiplied by your bet per line (total bet √∑ 10)</p>

      <h3>üìÇ Classified File (Scatter)</h3>
      <div class="symbol-row scatter-highlight">
        <img src="assets/symbols/5.webp">
        <div>
          <strong style="color: #ffd700;">SCATTER SYMBOL</strong><br>
          <span style="font-size: 11px;">Land 3+ anywhere ‚Üí <strong>10 FREE SPINS!</strong><br>
          Scatters pay in ANY position (not just on paylines)</span>
        </div>
      </div>

      <h3>üîÆ Free Spins Bonus</h3>
      <p>‚Ä¢ A random <strong>EXPANDING SYMBOL</strong> is chosen</p>
      <p>‚Ä¢ When it lands, it <strong>expands to fill the entire reel</strong></p>
      <p>‚Ä¢ Land 3+ scatters during free spins = <strong>+10 more spins!</strong></p>

      <h3>üìä Paylines (10 Lines)</h3>
      <div class="paylines-grid">
        <div class="payline-diagram">
          <span class="line-num" style="background:#ff0000;">1</span>
          <svg viewBox="0 0 50 30"><line x1="5" y1="15" x2="45" y2="15" stroke="#ff0000" stroke-width="2"/></svg>
          <span class="line-desc">Middle</span>
        </div>
        <div class="payline-diagram">
          <span class="line-num" style="background:#00ff00;">2</span>
          <svg viewBox="0 0 50 30"><line x1="5" y1="5" x2="45" y2="5" stroke="#00ff00" stroke-width="2"/></svg>
          <span class="line-desc">Top</span>
        </div>
        <div class="payline-diagram">
          <span class="line-num" style="background:#0088ff;">3</span>
          <svg viewBox="0 0 50 30"><line x1="5" y1="25" x2="45" y2="25" stroke="#0088ff" stroke-width="2"/></svg>
          <span class="line-desc">Bottom</span>
        </div>
        <div class="payline-diagram">
          <span class="line-num" style="background:#ffff00;color:#000;">4</span>
          <svg viewBox="0 0 50 30"><polyline points="5,5 15,15 25,25 35,15 45,5" fill="none" stroke="#ffff00" stroke-width="2"/></svg>
          <span class="line-desc">V Shape</span>
        </div>
        <div class="payline-diagram">
          <span class="line-num" style="background:#ff00ff;">5</span>
          <svg viewBox="0 0 50 30"><polyline points="5,25 15,15 25,5 35,15 45,25" fill="none" stroke="#ff00ff" stroke-width="2"/></svg>
          <span class="line-desc">Inverted V</span>
        </div>
        <div class="payline-diagram">
          <span class="line-num" style="background:#00ffff;color:#000;">6</span>
          <svg viewBox="0 0 50 30"><polyline points="5,15 15,5 25,5 35,5 45,15" fill="none" stroke="#00ffff" stroke-width="2"/></svg>
          <span class="line-desc">Top Dip</span>
        </div>
        <div class="payline-diagram">
          <span class="line-num" style="background:#ff8800;">7</span>
          <svg viewBox="0 0 50 30"><polyline points="5,15 15,25 25,25 35,25 45,15" fill="none" stroke="#ff8800" stroke-width="2"/></svg>
          <span class="line-desc">Bottom Dip</span>
        </div>
        <div class="payline-diagram">
          <span class="line-num" style="background:#88ff00;color:#000;">8</span>
          <svg viewBox="0 0 50 30"><polyline points="5,5 15,5 25,15 35,25 45,25" fill="none" stroke="#88ff00" stroke-width="2"/></svg>
          <span class="line-desc">Diagonal ‚Üò</span>
        </div>
        <div class="payline-diagram">
          <span class="line-num" style="background:#ff0088;">9</span>
          <svg viewBox="0 0 50 30"><polyline points="5,25 15,25 25,15 35,5 45,5" fill="none" stroke="#ff0088" stroke-width="2"/></svg>
          <span class="line-desc">Diagonal ‚Üó</span>
        </div>
        <div class="payline-diagram">
          <span class="line-num" style="background:#8800ff;">10</span>
          <svg viewBox="0 0 50 30"><polyline points="5,15 15,5 25,15 35,25 45,15" fill="none" stroke="#8800ff" stroke-width="2"/></svg>
          <span class="line-desc">Zigzag</span>
        </div>
      </div>

      <h3>üí∞ Symbol Payouts</h3>
      <p style="font-size: 10px; color: #888; margin-bottom: 8px;">Multipliers √ó bet per line (total bet √∑ 10)</p>

      <div class="symbol-row premium">
        <img src="assets/symbols/1.webp">
        <div class="payout-info">
          <strong>Grey Alien</strong>
          <span class="payouts">√ó5: 5000 | √ó4: 1000 | √ó3: 100</span>
        </div>
      </div>
      <div class="symbol-row premium">
        <img src="assets/symbols/2.webp">
        <div class="payout-info">
          <strong>Agent</strong>
          <span class="payouts">√ó5: 2000 | √ó4: 500 | √ó3: 50</span>
        </div>
      </div>
      <div class="symbol-row high">
        <img src="assets/symbols/3.webp">
        <div class="payout-info">
          <strong>Flying Saucer</strong>
          <span class="payouts">√ó5: 750 | √ó4: 100 | √ó3: 30</span>
        </div>
      </div>
      <div class="symbol-row high">
        <img src="assets/symbols/4.webp">
        <div class="payout-info">
          <strong>Ray Gun</strong>
          <span class="payouts">√ó5: 750 | √ó4: 100 | √ó3: 30</span>
        </div>
      </div>
      <div class="symbol-row scatter-highlight">
        <img src="assets/symbols/5.webp">
        <div class="payout-info">
          <strong style="color: #ffd700;">Classified File</strong>
          <span class="payouts" style="color: #ffd700;">√ó5: 200 | √ó4: 20 | √ó3: 2 (√ótotal bet)</span>
        </div>
      </div>
      <div class="symbol-row medium">
        <img src="assets/symbols/6.webp">
        <div class="payout-info">
          <strong>Atom</strong>
          <span class="payouts">√ó5: 250 | √ó4: 40 | √ó3: 10</span>
        </div>
      </div>
      <div class="symbol-row medium">
        <img src="assets/symbols/7.webp">
        <div class="payout-info">
          <strong>Rocket</strong>
          <span class="payouts">√ó5: 250 | √ó4: 40 | √ó3: 10</span>
        </div>
      </div>
      <div class="symbol-row low">
        <img src="assets/symbols/8.webp">
        <div class="payout-info">
          <strong>TV Static</strong>
          <span class="payouts">√ó5: 100 | √ó4: 15 | √ó3: 5</span>
        </div>
      </div>
      <div class="symbol-row low">
        <img src="assets/symbols/9.webp">
        <div class="payout-info">
          <strong>Tinfoil Hat</strong>
          <span class="payouts">√ó5: 100 | √ó4: 15 | √ó3: 5</span>
        </div>
      </div>
      <div class="symbol-row low">
        <img src="assets/symbols/10.webp">
        <div class="payout-info">
          <strong>Cow</strong>
          <span class="payouts">√ó5: 100 | √ó4: 15 | √ó3: 5</span>
        </div>
      </div>

      <h3>‚ÑπÔ∏è Game Info</h3>
      <p>‚Ä¢ RTP: ~96%</p>
      <p>‚Ä¢ Volatility: High</p>
      <p>‚Ä¢ Based on the classic "Book of" mechanic</p>
    </div>
    <button class="ctrl-btn" style="margin: 20px auto 0; display: block;" onclick="closeInfoPopup()">‚úì</button>
  </div>
</div>

<!-- Bonus Popup -->
<div id="bonusPopup" class="bonus-overlay">
  <div class="bonus-content">
    <div class="bonus-image-wrapper">
      <img src="assets/bonus.webp" class="bonus-image" alt="Bonus">
      <div class="bonus-spins-text">
        <div class="spins-number" id="bonusSpinsNumber">10</div>
        <div class="spins-label">FREE SPINS</div>
      </div>
    </div>
    <div class="tap-continue">TAP TO CONTINUE</div>
  </div>
</div>

<!-- Bonus Complete Popup -->
<div id="bonusCompletePopup" class="bonus-complete-overlay">
  <div class="bonus-complete-content">
    <div class="bonus-complete-title">BONUS COMPLETE</div>
    <div class="bonus-complete-label">TOTAL WIN</div>
    <div class="bonus-complete-amount" id="bonusTotalAmount">0.00</div>
    <div class="bonus-complete-tap">TAP TO CONTINUE</div>
  </div>
</div>

<script>
// ===========================================
// CONFIGURATION
// ===========================================
const CONFIG = {
  API_URL: '', // Will be set on init
  GAME_ALIAS: 'Novomatic/Book of Ra Deluxe',
  CLUB_ID: 1,
  USER_ID: 3,
  TOKEN: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzbG90b3BvbCIsImV4cCI6NDg2NzQ0NzYxNywibmJmIjoxNzA2NjQ3NjE3LCJ1aWQiOjN9.6g2Hig9ErG8IbvzkPppry5F8HJsMunZPwuQzmetGh4c',
  COLS: 5,
  ROWS: 3,
  BETS: [0.90, 1.80, 3.60, 9.00, 18.00, 36.00, 90.00],
  SCATTER_ID: 10 // Book symbol in Book of Ra
};

// Symbol mapping: API symbol ID -> our image file
// Book of Ra API: 1=Explorer(highest), 2=Pharaoh, 3=Idol, 4=Scarab, 5=A, 6=K, 7=Q, 8=J, 9=10(lowest), 10=Book
const SYMBOLS = {
  1: 'assets/symbols/1.webp',   // Explorer (highest) -> Alien
  2: 'assets/symbols/2.webp',   // Pharaoh -> G-Man
  3: 'assets/symbols/3.webp',   // Idol -> UFO
  4: 'assets/symbols/4.webp',   // Scarab -> Ray Gun
  5: 'assets/symbols/6.webp',   // A -> Atom
  6: 'assets/symbols/7.webp',   // K -> Rocket
  7: 'assets/symbols/8.webp',   // Q -> TV Static
  8: 'assets/symbols/9.webp',   // J -> Tinfoil Hat
  9: 'assets/symbols/10.webp',  // 10 (lowest) -> Cow
  10: 'assets/symbols/5.webp'   // Book (scatter) -> Classified File
};

// Preload all symbol images into memory
const preloadedImages = {};
function preloadImages() {
  for (let i = 1; i <= 10; i++) {
    const img = new Image();
    img.src = SYMBOLS[i];
    preloadedImages[i] = img;
  }
}
preloadImages();

// Payline definitions: row positions (1=top, 2=middle, 3=bottom) for each of 5 columns
const PAYLINES = [
  { rows: [2,2,2,2,2], color: '#ff0000' },  // Line 1: middle straight - red
  { rows: [1,1,1,1,1], color: '#00ff00' },  // Line 2: top straight - green
  { rows: [3,3,3,3,3], color: '#0088ff' },  // Line 3: bottom straight - blue
  { rows: [1,2,3,2,1], color: '#ffff00' },  // Line 4: V shape - yellow
  { rows: [3,2,1,2,3], color: '#ff00ff' },  // Line 5: inverted V - magenta
  { rows: [2,1,1,1,2], color: '#00ffff' },  // Line 6: cyan
  { rows: [2,3,3,3,2], color: '#ff8800' },  // Line 7: orange
  { rows: [1,1,2,3,3], color: '#88ff00' },  // Line 8: lime
  { rows: [3,3,2,1,1], color: '#ff0088' },  // Line 9: pink
  { rows: [2,1,2,3,2], color: '#8800ff' }   // Line 10: purple
];

// ===========================================
// GAME STATE
// ===========================================
let state = {
  gid: null,
  balance: 1000,
  bet: 9.00,
  betIndex: 3,
  spinning: false,
  screen: null,
  freeSpins: 0,
  expandingSymbol: null,
  soundOn: true,
  lastWin: 0,
  inBonusMode: false,
  bonusTotalWin: 0,
  previousGain: 0  // Track cumulative gain from previous spin for per-spin win calculation
};

// ===========================================
// DOM ELEMENTS
// ===========================================
const $ = id => document.getElementById(id);
const reelsEl = $('reels');
const spinBtn = $('spinBtn');
const balanceEl = $('balance');
const betDisplayEl = $('betDisplay');
const lastWinEl = $('lastWin');
const winDisplay = $('winDisplay');
const winAmount = $('winAmount');
const freespinsBanner = $('freespinsBanner');
const fsCountEl = $('fsCount');
const expandingSymbolEl = $('expandingSymbol');
const expandingImg = $('expandingImg');
const gameContainer = $('gameContainer');

// ===========================================
// API FUNCTIONS
// ===========================================
async function api(endpoint, data = null) {
  try {
    const response = await fetch(CONFIG.API_URL + endpoint, {
      method: data ? 'POST' : 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + CONFIG.TOKEN
      },
      body: data ? JSON.stringify(data) : null
    });
    return await response.json();
  } catch (err) {
    console.error('API Error:', err);
    return null;
  }
}

async function initGame() {
  // Try to detect server
  const serverUrl = detectServer();
  CONFIG.API_URL = serverUrl;
  
  const result = await api('/game/new', {
    cid: CONFIG.CLUB_ID,
    uid: CONFIG.USER_ID,
    alias: CONFIG.GAME_ALIAS
  });
  
  if (result && result.gid) {
    state.gid = result.gid;
    state.balance = result.wallet || 1000;
    if (state.balance < 100) state.balance = 1000;

    // Parse initial screen
    if (result.game && result.game.scr) {
      state.screen = parseScreen(result.game.scr);
    } else {
      state.screen = randomScreen();
    }
    
    updateUI();
    renderReels();
    console.log('Game initialized:', result);
  } else {
    console.error('Failed to init game:', result);
    // Use demo mode
    state.screen = randomScreen();
    renderReels();
  }
}

function detectServer() {
  // Check if we're on the same server
  if (window.location.hostname === 'localhost') {
    return '';
  }
  // Use current host
  return '';
}

function parseScreen(scr) {
  // API returns array of columns, each column has ROWS symbols
  if (!scr || !Array.isArray(scr)) return randomScreen();
  
  let screen = [];
  for (let col = 0; col < CONFIG.COLS; col++) {
    screen[col] = [];
    for (let row = 0; row < CONFIG.ROWS; row++) {
      screen[col][row] = scr[col] ? scr[col][row] : Math.floor(Math.random() * 10) + 1;
    }
  }
  return screen;
}

function randomScreen() {
  let screen = [];
  for (let col = 0; col < CONFIG.COLS; col++) {
    screen[col] = [];
    for (let row = 0; row < CONFIG.ROWS; row++) {
      screen[col][row] = Math.floor(Math.random() * 10) + 1;
    }
  }
  return screen;
}

// ===========================================
// RENDER FUNCTIONS
// ===========================================
function createCell(symId) {
  const cellEl = document.createElement('div');
  cellEl.className = 'reel-cell';

  // Normalize symId to 1-10 range
  if (symId < 1 || symId > 10) symId = ((symId - 1) % 10) + 1;

  // Create image element with explicit SYMBOLS lookup
  // This ensures server symbol ID maps to correct Area 51 image
  const img = document.createElement('img');
  const imagePath = SYMBOLS[symId];
  img.src = imagePath;
  img.alt = 'Symbol ' + symId;

  // Store the server symbol ID on the element for debugging
  cellEl.dataset.symbolId = symId;
  cellEl.dataset.imagePath = imagePath;

  cellEl.appendChild(img);
  return cellEl;
}

function renderReels() {
  reelsEl.innerHTML = '';

  for (let col = 0; col < CONFIG.COLS; col++) {
    const windowEl = document.createElement('div');
    windowEl.className = 'reel-window';
    windowEl.id = `reel-window-${col}`;

    // Add anticipation container with all effect elements
    const anticipationContainer = createAnticipationContainer(col);
    windowEl.appendChild(anticipationContainer);

    const stripEl = document.createElement('div');
    stripEl.className = 'reel-strip';

    for (let row = 0; row < CONFIG.ROWS; row++) {
      const symId = state.screen[col][row];
      const cellEl = createCell(symId);
      cellEl.id = `cell-${col}-${row}`;
      stripEl.appendChild(cellEl);
    }

    windowEl.appendChild(stripEl);
    reelsEl.appendChild(windowEl);
  }
}

// Create anticipation effect container with all sub-elements
// Layer order (bottom to top): border -> inner glow -> particles -> webp overlay -> scanline -> corners
function createAnticipationContainer(reelIndex) {
  const container = document.createElement('div');
  container.className = 'anticipation-container';
  container.id = `anticipation-container-${reelIndex}`;

  // LAYER 1: Animated gradient border
  const border = document.createElement('div');
  border.className = 'anticipation-border';
  container.appendChild(border);

  // LAYER 2: Inner glow overlay
  const innerGlow = document.createElement('div');
  innerGlow.className = 'anticipation-glow-inner';
  container.appendChild(innerGlow);

  // LAYER 3: CSS Particle container (supplements webp)
  const particlesContainer = document.createElement('div');
  particlesContainer.className = 'anticipation-particles';
  particlesContainer.id = `anticipation-particles-${reelIndex}`;

  // Create CSS particles
  const particleColors = ['green', 'gold', 'white'];
  for (let i = 0; i < 18; i++) {
    const particle = document.createElement('div');
    particle.className = `anticipation-particle ${particleColors[i % 3]}`;
    // Random horizontal position
    particle.style.left = `${Math.random() * 85 + 7}%`;
    // Staggered animation delay
    particle.style.animationDelay = `${(i * 0.14)}s`;
    particlesContainer.appendChild(particle);
  }
  container.appendChild(particlesContainer);

  // LAYER 4: anticipation.webp overlay (the animated particle effect image)
  const webpOverlay = document.createElement('div');
  webpOverlay.className = 'anticipation-webp-overlay';
  container.appendChild(webpOverlay);

  // LAYER 5: Bright scanning line
  const scanline = document.createElement('div');
  scanline.className = 'anticipation-scanline';
  container.appendChild(scanline);

  // LAYER 6: Corner accents
  ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(pos => {
    const corner = document.createElement('div');
    corner.className = `anticipation-corner ${pos}`;
    container.appendChild(corner);
  });

  // Energy lines (for hot mode)
  for (let i = 0; i < 3; i++) {
    const energyLine = document.createElement('div');
    energyLine.className = 'anticipation-energy-line';
    container.appendChild(energyLine);
  }

  // Alert text (for hot mode)
  const alert = document.createElement('div');
  alert.className = 'anticipation-alert';
  alert.textContent = 'ALERT';
  container.appendChild(alert);

  return container;
}

function updateUI() {
  balanceEl.textContent = state.balance.toFixed(2);
  betDisplayEl.textContent = state.bet.toFixed(2);
  lastWinEl.textContent = state.lastWin.toFixed(2);

  // Free spins mode - use inBonusMode to keep background until bonus truly ends
  if (state.inBonusMode || state.freeSpins > 0) {
    gameContainer.classList.add('freespins');
    freespinsBanner.classList.add('active');
    fsCountEl.textContent = state.freeSpins;

    if (state.expandingSymbol) {
      expandingSymbolEl.classList.add('active');
      expandingImg.src = SYMBOLS[state.expandingSymbol] || (state.expandingSymbol + '.webp');
    }
  } else {
    gameContainer.classList.remove('freespins');
    freespinsBanner.classList.remove('active');
    expandingSymbolEl.classList.remove('active');
    state.expandingSymbol = null;
  }
}

function showWin(amount) {
  state.lastWin = amount;
  lastWinEl.textContent = amount.toFixed(2);

  if (amount > 0) {
    lastWinEl.classList.add('win-active');
    winAmount.textContent = amount.toFixed(2);
    winDisplay.classList.add('active');

    setTimeout(() => {
      winDisplay.classList.remove('active');
    }, 2000);
  } else {
    lastWinEl.classList.remove('win-active');
  }
}

function highlightWinners(wins) {
  // Clear previous highlights
  document.querySelectorAll('.winner').forEach(el => el.classList.remove('winner'));
  document.querySelectorAll('.expanded').forEach(el => el.classList.remove('expanded'));
  clearPaylines();

  if (!wins || wins.length === 0) return;

  wins.forEach(win => {
    if (win.xy && win.xy.length > 0) {
      win.xy.forEach(coord => {
        const col = coord[0] - 1;
        const row = coord[1] - 1;
        const cell = $(`cell-${col}-${row}`);
        if (cell) {
          cell.classList.add('winner');

          // Check if this is an expanding symbol
          if (state.expandingSymbol && win.sym === state.expandingSymbol) {
            cell.classList.add('expanded');
          }
        }
      });
    }

    // Draw payline using actual xy coordinates from the win
    if (win.xy && win.xy.length >= 2 && win.li !== undefined) {
      drawPayline(win.li, win.xy);
    }
  });
}

// ===========================================
// PAYLINE VISUALIZATION
// ===========================================
function clearPaylines() {
  const overlay = $('paylineOverlay');
  overlay.innerHTML = '';
}

function drawPayline(lineNum, xyCoords) {
  const overlay = $('paylineOverlay');
  const payline = PAYLINES[lineNum - 1]; // Get color from payline definition
  if (!payline || !xyCoords || xyCoords.length < 2) return;

  // Calculate cell dimensions dynamically for responsive layouts
  const firstCell = document.querySelector('.reel-cell');
  const reelsContainer = document.querySelector('.reels-container');
  const reelsEl = document.querySelector('.reels');

  const gap = parseInt(getComputedStyle(reelsEl).gap) || 8;
  const padding = parseInt(getComputedStyle(reelsContainer).padding) || 15;

  const CELL_WIDTH = firstCell ? firstCell.offsetWidth : 180;
  const CELL_HEIGHT = firstCell ? firstCell.offsetHeight : 180;
  const GAP = gap;
  const PADDING = padding;

  // Calculate positions for each point using ACTUAL xy coordinates from API
  // API xy format: [col, row] where col=1-5, row=1-3 (1=top, 2=middle, 3=bottom)
  const points = [];

  for (let i = 0; i < xyCoords.length; i++) {
    const col = xyCoords[i][0] - 1; // Convert 1-indexed to 0-indexed
    const row = xyCoords[i][1] - 1; // Convert 1-indexed to 0-indexed

    // X position: center of the cell in this column
    const x = PADDING + col * (CELL_WIDTH + GAP) + CELL_WIDTH / 2;

    // Y position: center of the cell in this row
    const y = PADDING + row * (CELL_HEIGHT + GAP) + CELL_HEIGHT / 2;

    points.push({ x, y });
  }

  // Create SVG line segments connecting the points
  for (let i = 0; i < points.length - 1; i++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', points[i].x);
    line.setAttribute('y1', points[i].y);
    line.setAttribute('x2', points[i + 1].x);
    line.setAttribute('y2', points[i + 1].y);
    line.setAttribute('stroke', payline.color);
    line.setAttribute('filter', `drop-shadow(0 0 6px ${payline.color})`);
    line.classList.add('active');
    overlay.appendChild(line);
  }
}

// ===========================================
// SPIN LOGIC
// ===========================================
async function spin() {
  if (state.spinning) return;
  if (state.freeSpins <= 0 && state.balance < state.bet) {
    alert('Insufficient balance!');
    return;
  }

  state.spinning = true;
  spinBtn.disabled = true;
  spinBtn.classList.add('spinning');
  state.lastWin = 0;
  lastWinEl.textContent = '0.00';
  lastWinEl.classList.remove('win-active');

  // Clear previous wins, expansions, and paylines
  document.querySelectorAll('.winner').forEach(el => el.classList.remove('winner'));
  document.querySelectorAll('.expanded').forEach(el => el.classList.remove('expanded'));
  document.querySelectorAll('.expanding').forEach(el => el.classList.remove('expanding'));
  clearPaylines();

  // Store previous free spins count BEFORE API call (server is source of truth)
  const previousFs = state.freeSpins;

  // Deduct bet (unless in free spins mode - server tracks free spins)
  if (!state.inBonusMode) {
    state.balance -= state.bet;
  }
  updateUI();

  // Call API
  const result = await api('/slot/spin', {
    gid: state.gid,
    bet: state.bet / 10 // API uses bet per line
  });

  // Handle API errors (e.g., "not enough money on balance")
  if (result && (result.code || result.what)) {
    console.error('Spin failed:', result.what || result.code);
    // Restore balance if we deducted it
    if (!state.inBonusMode) {
      state.balance += state.bet;
    }
    state.spinning = false;
    spinBtn.disabled = false;
    spinBtn.classList.remove('spinning');
    updateUI();
    alert(result.what || 'Spin failed');
    return;
  }

  // Parse new screen before animation
  let newScreen;
  if (result) {
    if (result.game && result.game.scr) {
      newScreen = parseScreen(result.game.scr);
      console.log('Server screen (game.scr):', JSON.stringify(result.game.scr));
    } else if (result.scr) {
      newScreen = parseScreen(result.scr);
      console.log('Server screen (scr):', JSON.stringify(result.scr));
    } else {
      newScreen = randomScreen();
      console.log('Using random screen (no server data)');
    }
  } else {
    newScreen = randomScreen();
    console.log('Using random screen (no result)');
  }

  // Log the parsed screen with symbol mapping info
  console.log('Parsed newScreen with SYMBOLS mapping:');
  for (let col = 0; col < newScreen.length; col++) {
    const symIds = newScreen[col];
    const mappedPaths = symIds.map(id => `${id}->${SYMBOLS[id].split('/').pop()}`);
    console.log(`  Reel ${col}: ${mappedPaths.join(', ')}`);
  }

  // SEAMLESS spin animation
  const windows = document.querySelectorAll('.reel-window');
  const EXTRA = 30;

  // Calculate CELL size dynamically based on actual rendered size
  const firstCell = document.querySelector('.reel-cell');
  const reelsEl = document.querySelector('.reels');
  const gap = parseInt(getComputedStyle(reelsEl).gap) || 8;
  const cellHeight = firstCell ? firstCell.offsetHeight : 180;
  const CELL = cellHeight + gap;
  const offsetToShowCurrent = (CONFIG.ROWS + EXTRA) * CELL;

  // Step 1: Build extended strips while hidden (no flash)
  windows.forEach((w, col) => {
    const strip = w.querySelector('.reel-strip');

    // Hide strip, disable transition, set future position FIRST
    strip.style.visibility = 'hidden';
    strip.style.transition = 'none';
    strip.style.transform = `translateY(-${offsetToShowCurrent}px)`;

    // Create fragment: [final 3] + [random 30]
    const fragment = document.createDocumentFragment();

    for (let row = 0; row < CONFIG.ROWS; row++) {
      const cellEl = createCell(newScreen[col][row]);
      fragment.appendChild(cellEl);
    }

    for (let i = 0; i < EXTRA; i++) {
      fragment.appendChild(createCell(Math.floor(Math.random() * 10) + 1));
    }

    // Prepend to existing strip: [final 3] + [random 30] + [current 3]
    strip.insertBefore(fragment, strip.firstChild);
  });

  // Force reflow
  document.body.offsetHeight;

  // Step 2: Show strips (now positioned to show current cells)
  windows.forEach((w) => {
    const strip = w.querySelector('.reel-strip');
    strip.style.visibility = 'visible';
  });

  // Force reflow again
  document.body.offsetHeight;

  // Count scatters in newScreen for anticipation feature
  // Scatter symbol is ID 10 (Classified File / Book) - maps to our symbol 5
  const SCATTER_ID = 10;
  const scattersPerReel = [];
  for (let col = 0; col < CONFIG.COLS; col++) {
    let count = 0;
    for (let row = 0; row < CONFIG.ROWS; row++) {
      if (newScreen[col][row] === SCATTER_ID) count++;
    }
    scattersPerReel.push(count);
  }
  console.log('Scatters per reel:', scattersPerReel);

  // Calculate cumulative scatter count after each reel
  const cumulativeScatters = [];
  let scatterTotal = 0;
  for (let i = 0; i < scattersPerReel.length; i++) {
    scatterTotal += scattersPerReel[i];
    cumulativeScatters.push(scatterTotal);
  }
  console.log('Cumulative scatters:', cumulativeScatters);

  // Find which reel triggers anticipation (first reel where cumulative >= 2)
  let anticipationStartReel = -1;
  for (let i = 0; i < cumulativeScatters.length - 1; i++) {
    if (cumulativeScatters[i] >= 2) {
      anticipationStartReel = i + 1; // Anticipation starts on NEXT reel
      break;
    }
  }
  console.log('Anticipation starts at reel:', anticipationStartReel);

  // Helper function to show/hide anticipation effects (CSS-based)
  function showAnticipation(reelIndex, isHot = false) {
    const container = document.getElementById(`anticipation-container-${reelIndex}`);

    if (container) {
      container.classList.remove('hot');
      container.classList.add('active');

      if (isHot) {
        container.classList.add('hot');
        // Play hot anticipation sound (placeholder)
        playAnticipationSound(true);
      } else {
        // Play normal anticipation sound (placeholder)
        playAnticipationSound(false);
      }

      // Re-randomize particle positions for variety
      const particles = container.querySelectorAll('.anticipation-particle');
      particles.forEach((p, i) => {
        p.style.left = `${Math.random() * 85 + 7}%`;
        p.style.animationDelay = `${(i * (isHot ? 0.07 : 0.13))}s`;
      });
    }
  }

  function hideAnticipation(reelIndex) {
    const container = document.getElementById(`anticipation-container-${reelIndex}`);

    if (container) {
      container.classList.remove('active', 'hot');
      // Stop anticipation sound (placeholder)
      stopAnticipationSound();
    }
  }

  // Step 3: Animate to translateY(0) - reveals final cells at top
  // With anticipation: slower spin for remaining reels when 2+ scatters
  const reelStopTimes = [];
  const totalReels = CONFIG.COLS;

  windows.forEach((w, col) => {
    const strip = w.querySelector('.reel-strip');
    const delay = col * 200;

    // Calculate duration - normal or extended for anticipation
    let duration;
    const hasAnticipation = anticipationStartReel > 0 && col >= anticipationStartReel;

    if (hasAnticipation) {
      // Extended duration for anticipation reels (2.5-3.5 seconds)
      duration = 2500 + (col - anticipationStartReel) * 500;
    } else {
      // Normal duration
      duration = 1500 + col * 200;
    }

    const stopTime = delay + duration;
    reelStopTimes.push(stopTime);

    setTimeout(() => {
      // Add anticipation effects if this reel should have them
      if (hasAnticipation) {
        // Check if this is the last spinning reel (hot mode)
        const isLastReel = col === totalReels - 1;
        const isOnlyOneLeft = col === totalReels - 1 && anticipationStartReel <= col;
        showAnticipation(col, isLastReel || isOnlyOneLeft);
        console.log(`Anticipation ON for reel ${col}, hot: ${isLastReel}`);
      }

      strip.style.transition = `transform ${duration}ms cubic-bezier(0.15, 0.8, 0.3, 1)`;
      strip.style.transform = 'translateY(0)';

      // Remove anticipation when reel stops
      setTimeout(() => {
        hideAnticipation(col);
        console.log(`Anticipation OFF for reel ${col}`);
      }, duration);
    }, delay);
  });

  // Wait for all animations (use max stop time)
  const totalTime = Math.max(...reelStopTimes) + 500;
  await new Promise(r => setTimeout(r, totalTime));

  // Step 4: Clean up - keep only final 3 cells
  windows.forEach((w, col) => {
    const strip = w.querySelector('.reel-strip');
    strip.style.transition = 'none';

    while (strip.children.length > CONFIG.ROWS) {
      strip.removeChild(strip.lastChild);
    }

    for (let row = 0; row < CONFIG.ROWS; row++) {
      strip.children[row].id = `cell-${col}-${row}`;
    }

    strip.style.transform = 'translateY(0)';
  });

  // Update state with new screen
  state.screen = newScreen;

  // Expand symbols in bonus mode BEFORE win calculation
  if (state.inBonusMode && state.expandingSymbol) {
    const expanded = expandSymbols();
    if (expanded) {
      await new Promise(r => setTimeout(r, 800)); // Wait for animation
    }
  }

  if (result) {
    console.log('Spin result:', result);
    console.log('result.gain:', result.gain);
    console.log('result.game:', JSON.stringify(result.game));
    console.log('result.wins:', result.wins);

    // === BONUS DEBUG ===
    console.log("=== BONUS DEBUG ===");
    console.log("result.game.es:", result.game?.es);
    console.log("result.game.fsr:", result.game?.fsr);
    console.log("result.game.gain (cumulative):", result.game?.gain);
    console.log("state.expandingSymbol:", state.expandingSymbol);
    console.log("state.inBonusMode:", state.inBonusMode);

    // Update balance
    if (result.wallet !== undefined) {
      state.balance = result.wallet;
    }

    // Get cumulative gain from server
    const cumulativeGain = result.game?.gain || result.gain || 0;
    const wins = result.wins || (result.game && result.game.wins) || [];

    // Calculate THIS spin's win (per-spin, not cumulative)
    let spinWin;
    if (state.inBonusMode) {
      spinWin = cumulativeGain - state.previousGain;
      state.previousGain = cumulativeGain;  // Store for next spin
      state.bonusTotalWin = cumulativeGain; // Use server's cumulative
    } else {
      spinWin = cumulativeGain;
    }

    console.log("Cumulative gain:", cumulativeGain, "Spin win:", spinWin);
    console.log('wins array:', wins);

    // Get free spins count from server (server is source of truth)
    // Server returns "fsr" (free spins remaining), NOT "fs"
    const newFs = (result.game && result.game.fsr !== undefined) ? result.game.fsr : 0;

    // Debug logging
    console.log('Previous FS:', previousFs, 'New FS:', newFs, 'In Bonus Mode:', state.inBonusMode);

    // Determine if free spins were triggered or retriggered
    let showBonusTrigger = false;
    let isRetrigger = false;

    if (previousFs === 0 && newFs > 0) {
      // INITIAL TRIGGER: Was not in free spins, now we have free spins
      console.log('FREE SPINS TRIGGERED! Initial trigger:', newFs);
      showBonusTrigger = true;
      isRetrigger = false;
      state.expandingSymbol = result.game?.es || pickExpandingSymbol(result);
      console.log("Expanding symbol ID:", state.expandingSymbol);
    } else if (previousFs > 0 && newFs > previousFs) {
      // RETRIGGER: Was in free spins and fs INCREASED (server added +10)
      console.log('FREE SPINS RETRIGGER! Was:', previousFs, 'Now:', newFs);
      showBonusTrigger = true;
      isRetrigger = true;
    }

    // Update state with server's free spins count
    state.freeSpins = newFs;

    // Highlight winners
    if (wins.length > 0) {
      highlightWinners(wins);
    }

    // Show per-spin win (not cumulative)
    showWin(spinWin);
    updateUI();

    // Show bonus popup if free spins were triggered or retriggered
    if (showBonusTrigger) {
      state.spinning = false;
      spinBtn.disabled = false;
      spinBtn.classList.remove('spinning');

      // Wait a moment to let the player see the scatter symbols, then show popup
      await new Promise(r => setTimeout(r, 800));

      // If this is the initial trigger, set up bonus mode
      if (!isRetrigger) {
        state.inBonusMode = true;
        state.previousGain = 0;
        state.bonusTotalWin = 0;
        console.log('Entering bonus mode');

        // Start bonus music
        playBonusMusic();
      }

      // Show popup - for retrigger show +10, for initial show the total
      const spinsToShow = isRetrigger ? 10 : newFs;
      await showBonusPopup(spinsToShow, isRetrigger);

      // Start auto-spinning free spins
      setTimeout(() => spin(), 500);
      return;
    }

    // Check if bonus just ended (was in bonus, now no free spins left)
    if (state.inBonusMode && newFs === 0) {
      console.log('Bonus ended! Total win:', state.bonusTotalWin);
      state.spinning = false;
      spinBtn.disabled = false;
      spinBtn.classList.remove('spinning');

      // Stop bonus music (fades out over 1s)
      stopBonusMusic();

      // Wait a moment, then show bonus complete popup
      await new Promise(r => setTimeout(r, 1000));
      await showBonusCompletePopup(state.bonusTotalWin);

      // Reset bonus mode
      state.inBonusMode = false;
      state.bonusTotalWin = 0;
      state.expandingSymbol = null;
      updateUI();
      return;
    }
  }

  state.spinning = false;
  spinBtn.disabled = false;
  spinBtn.classList.remove('spinning');

  // Auto-spin if free spins remain (server tracks count)
  if (state.freeSpins > 0) {
    setTimeout(() => spin(), 1500);
  }
}

function expandSymbols() {
  if (!state.inBonusMode || !state.expandingSymbol) return false;

  const es = state.expandingSymbol;
  const reelsToExpand = [];

  // Check each reel for the expanding symbol
  for (let col = 0; col < 5; col++) {
    for (let row = 0; row < 3; row++) {
      if (state.screen[col][row] === es) {
        reelsToExpand.push(col);
        break; // Only need to find it once per reel
      }
    }
  }

  console.log("Reels to expand:", reelsToExpand);

  // Animate expansion on each reel
  reelsToExpand.forEach(col => {
    for (let row = 0; row < 3; row++) {
      const cell = document.getElementById(`cell-${col}-${row}`);
      if (cell) {
        cell.classList.add('expanding');
        // Replace image with expanding symbol
        const img = cell.querySelector('img');
        if (img) img.src = SYMBOLS[es];
        // Update state.screen to reflect expansion
        state.screen[col][row] = es;
      }
    }
  });

  return reelsToExpand.length > 0;
}

function pickExpandingSymbol(result) {
  // In real Book of Ra, the expanding symbol is randomly chosen
  // We'll pick one of the non-scatter symbols
  const symbols = [1, 2, 3, 4, 5, 6, 7, 8, 9]; // Exclude 10 (scatter)
  return symbols[Math.floor(Math.random() * symbols.length)];
}

// ===========================================
// BONUS POPUP
// ===========================================
function showBonusPopup(spins, isRetrigger = false) {
  return new Promise((resolve) => {
    const popup = $('bonusPopup');
    const spinsNumber = $('bonusSpinsNumber');

    // Set the spins number text
    spinsNumber.textContent = isRetrigger ? `+${spins}` : spins;

    // Show popup with fade-in
    popup.style.display = 'flex';
    // Force reflow for transition
    popup.offsetHeight;
    popup.classList.add('active');

    // Handle click to dismiss
    const handleClick = () => {
      popup.classList.remove('active');
      setTimeout(() => {
        popup.style.display = 'none';
        popup.removeEventListener('click', handleClick);
        resolve();
      }, 300);
    };

    popup.addEventListener('click', handleClick);
  });
}

function showBonusCompletePopup(totalWin) {
  return new Promise((resolve) => {
    const popup = $('bonusCompletePopup');
    const amountEl = $('bonusTotalAmount');

    // Set the total win amount
    amountEl.textContent = totalWin.toFixed(2);

    // Show popup with fade-in
    popup.style.display = 'flex';
    popup.offsetHeight;
    popup.classList.add('active');

    // Handle click to dismiss
    const handleClick = () => {
      popup.classList.remove('active');
      setTimeout(() => {
        popup.style.display = 'none';
        popup.removeEventListener('click', handleClick);
        resolve();
      }, 300);
    };

    popup.addEventListener('click', handleClick);
  });
}

// ===========================================
// BET CONTROLS
// ===========================================
function openBetPopup() {
  const betOptions = $('betOptions');
  betOptions.innerHTML = '';
  
  CONFIG.BETS.forEach((bet, index) => {
    const btn = document.createElement('button');
    btn.className = 'bet-option' + (index === state.betIndex ? ' selected' : '');
    btn.textContent = bet.toFixed(2);
    btn.onclick = () => selectBet(index);
    betOptions.appendChild(btn);
  });
  
  $('betPopup').classList.add('active');
}

function closeBetPopup() {
  $('betPopup').classList.remove('active');
}

function selectBet(index) {
  state.betIndex = index;
  state.bet = CONFIG.BETS[index];
  updateUI();
  
  // Update selected state
  document.querySelectorAll('.bet-option').forEach((btn, i) => {
    btn.classList.toggle('selected', i === index);
  });
}

// ===========================================
// INFO POPUP
// ===========================================
function openInfoPopup() {
  $('infoPopup').classList.add('active');
}

function closeInfoPopup() {
  $('infoPopup').classList.remove('active');
}

// ===========================================
// SOUND CONTROLS
// ===========================================
function toggleSound() {
  state.soundOn = !state.soundOn;
  const bgm = $('bgm');
  const bonusMusic = $('bonusMusic');

  if (state.soundOn) {
    bgm.play().catch(e => console.log('Audio play failed'));
    // Resume bonus music if we're in bonus mode
    if (state.inBonusMode) {
      bonusMusic.play().catch(e => console.log('Bonus music play failed'));
    }
  } else {
    bgm.pause();
    bonusMusic.pause();
  }
  $('soundBtn').classList.toggle('active', state.soundOn);
}

// ===========================================
// BONUS MUSIC CONTROLS
// ===========================================
let bonusMusicFadeInterval = null;

function playBonusMusic() {
  if (!state.soundOn) return;

  const bonusMusic = $('bonusMusic');
  const bgm = $('bgm');

  // Clear any existing fade
  if (bonusMusicFadeInterval) {
    clearInterval(bonusMusicFadeInterval);
    bonusMusicFadeInterval = null;
  }

  // Fade out BGM
  fadeAudio(bgm, 0, 500, () => {
    bgm.pause();
  });

  // Start bonus music at 0 volume and fade in
  bonusMusic.volume = 0;
  bonusMusic.currentTime = 0;
  bonusMusic.play().catch(e => console.log('Bonus music play failed:', e));

  // Fade in over 0.5s
  fadeAudio(bonusMusic, 0.5, 500);

  console.log('[MUSIC] Bonus music started');
}

function stopBonusMusic() {
  const bonusMusic = $('bonusMusic');
  const bgm = $('bgm');

  // Clear any existing fade
  if (bonusMusicFadeInterval) {
    clearInterval(bonusMusicFadeInterval);
    bonusMusicFadeInterval = null;
  }

  // Fade out bonus music over 1s
  fadeAudio(bonusMusic, 0, 1000, () => {
    bonusMusic.pause();
    bonusMusic.currentTime = 0;

    // Fade BGM back in if sound is on
    if (state.soundOn) {
      bgm.volume = 0;
      bgm.play().catch(e => console.log('BGM play failed'));
      fadeAudio(bgm, 1, 500);
    }
  });

  console.log('[MUSIC] Bonus music stopped');
}

function fadeAudio(audioElement, targetVolume, duration, callback) {
  const startVolume = audioElement.volume;
  const volumeDiff = targetVolume - startVolume;
  const steps = 20;
  const stepTime = duration / steps;
  let currentStep = 0;

  const fadeInterval = setInterval(() => {
    currentStep++;
    const progress = currentStep / steps;
    // Ease out for smoother fade
    const easeProgress = 1 - Math.pow(1 - progress, 2);
    audioElement.volume = Math.max(0, Math.min(1, startVolume + (volumeDiff * easeProgress)));

    if (currentStep >= steps) {
      clearInterval(fadeInterval);
      audioElement.volume = targetVolume;
      if (callback) callback();
    }
  }, stepTime);

  return fadeInterval;
}

// ===========================================
// ANTICIPATION SOUND PLACEHOLDERS
// ===========================================
// These functions are hooks for adding anticipation sounds later.
// To add sounds:
// 1. Create audio elements: <audio id="anticipationSound" src="assets/anticipation.mp3"></audio>
// 2. Create hot version: <audio id="anticipationHotSound" src="assets/anticipation-hot.mp3"></audio>
// 3. Implement the functions below to play/stop the sounds

let anticipationSoundPlaying = false;

function playAnticipationSound(isHot = false) {
  if (!state.soundOn) return;

  // Placeholder - uncomment when audio files are added:
  // const soundId = isHot ? 'anticipationHotSound' : 'anticipationSound';
  // const sound = $(soundId);
  // if (sound) {
  //   sound.currentTime = 0;
  //   sound.play().catch(e => console.log('Anticipation sound failed:', e));
  //   anticipationSoundPlaying = true;
  // }

  // Console log for debugging/testing
  console.log(`[SOUND] Anticipation ${isHot ? 'HOT' : 'normal'} - play()`);
  anticipationSoundPlaying = true;
}

function stopAnticipationSound() {
  if (!anticipationSoundPlaying) return;

  // Placeholder - uncomment when audio files are added:
  // const sounds = ['anticipationSound', 'anticipationHotSound'];
  // sounds.forEach(id => {
  //   const sound = $(id);
  //   if (sound) {
  //     sound.pause();
  //     sound.currentTime = 0;
  //   }
  // });

  console.log('[SOUND] Anticipation - stop()');
  anticipationSoundPlaying = false;
}

// ===========================================
// EVENT LISTENERS
// ===========================================
spinBtn.addEventListener('click', spin);
$('betBtn').addEventListener('click', openBetPopup);
$('soundBtn').addEventListener('click', toggleSound);
$('infoBtn').addEventListener('click', openInfoPopup);

// Close popups on overlay click
$('betPopup').addEventListener('click', e => {
  if (e.target === $('betPopup')) closeBetPopup();
});
$('infoPopup').addEventListener('click', e => {
  if (e.target === $('infoPopup')) closeInfoPopup();
});

// Keyboard support
document.addEventListener('keydown', e => {
  if (e.code === 'Space' && !state.spinning) {
    e.preventDefault();
    spin();
  }
});

// ===========================================
// DEBUG/TEST FUNCTIONS (UI-only, no API calls)
// ===========================================

// Expose test functions globally for console access
window.testBonus = function() {
  console.log('Testing bonus popup (UI only)...');
  showBonusPopup(10, false).then(() => {
    state.freeSpins = 10;
    state.inBonusMode = true;
    state.previousGain = 0;
    state.bonusTotalWin = 0;
    state.expandingSymbol = Math.floor(Math.random() * 9) + 1;
    updateUI();
    playBonusMusic(); // Start bonus music
    console.log('Free spins mode active. Expanding symbol:', state.expandingSymbol);
  });
};

window.testBonusRetrigger = function() {
  console.log('Testing retrigger popup (UI only)...');
  showBonusPopup(10, true);
};

window.testBonusEnd = function() {
  console.log('Testing bonus end popup (UI only)...');
  stopBonusMusic(); // Stop bonus music with fade
  showBonusCompletePopup(1234.56).then(() => {
    state.inBonusMode = false;
    state.freeSpins = 0;
    updateUI();
  });
};

window.testFreeSpins = function() {
  console.log('Activating free spins mode (UI only)...');
  state.freeSpins = 10;
  state.inBonusMode = true;
  state.previousGain = 0;
  state.bonusTotalWin = 0;
  state.expandingSymbol = Math.floor(Math.random() * 9) + 1;
  updateUI();
  playBonusMusic(); // Start bonus music
  console.log('Free spins activated! Expanding symbol:', state.expandingSymbol);
};

window.testBonusMusicOn = function() {
  console.log('Testing bonus music ON...');
  playBonusMusic();
};

window.testBonusMusicOff = function() {
  console.log('Testing bonus music OFF...');
  stopBonusMusic();
};

window.addBalance = function(amount = 1000) {
  state.balance += amount;
  updateUI();
  console.log('Added', amount, 'to balance. New balance:', state.balance);
};

window.debugSymbols = function() {
  console.log('=== SYMBOL MAPPING DEBUG ===');
  console.log('Server Symbol ID -> Image File:');
  for (let i = 1; i <= 10; i++) {
    console.log(`  Server ${i} -> ${SYMBOLS[i]}`);
  }
  console.log('');
  console.log('Current screen state.screen:');
  if (state.screen) {
    for (let col = 0; col < state.screen.length; col++) {
      console.log(`  Reel ${col}: ${JSON.stringify(state.screen[col])}`);
    }
  }
  console.log('');
  console.log('Rendered cells (check data-symbol-id and data-image-path):');
  document.querySelectorAll('.reel-cell').forEach((cell, i) => {
    const img = cell.querySelector('img');
    console.log(`  Cell ${i}: symbolId=${cell.dataset.symbolId}, path=${cell.dataset.imagePath}, actual src=${img?.src}`);
  });
  console.log('');
  console.log('KEY MAPPINGS:');
  console.log(`  Scatter: Server sends 10 -> shows ${SYMBOLS[10]} (should be Classified File 5.webp)`);
  console.log(`  Ace: Server sends 5 -> shows ${SYMBOLS[5]} (should be Atom 6.webp)`);
};

window.testSymbolRender = function(symId) {
  console.log(`Testing render for server symbol ${symId}:`);
  console.log(`  SYMBOLS[${symId}] = ${SYMBOLS[symId]}`);
  const cell = createCell(symId);
  const img = cell.querySelector('img');
  console.log(`  Rendered img.src = ${img.src}`);
  console.log(`  Cell data-symbol-id = ${cell.dataset.symbolId}`);
  console.log(`  Cell data-image-path = ${cell.dataset.imagePath}`);
  return cell;
};

window.testAnticipation = function() {
  console.log('Testing ENHANCED anticipation effects on reels 3, 4, 5...');
  console.log('Watch for:');
  console.log('  - BRIGHT green scanline sweeping up/down');
  console.log('  - Pulsing glow border on container');
  console.log('  - anticipation.webp particle overlay');
  console.log('  - CSS particles floating up');
  console.log('  - HOT mode: gold/green mix, screen shake, ALERT!');

  function showAnticipationTest(reelIndex, isHot) {
    const container = document.getElementById(`anticipation-container-${reelIndex}`);
    if (container) {
      container.classList.remove('hot');
      container.classList.add('active');
      if (isHot) container.classList.add('hot');

      // Re-randomize particle positions
      const particles = container.querySelectorAll('.anticipation-particle');
      particles.forEach((p, i) => {
        p.style.left = `${Math.random() * 85 + 7}%`;
        p.style.animationDelay = `${(i * (isHot ? 0.07 : 0.13))}s`;
      });

      playAnticipationSound(isHot);
    }
  }

  function hideAnticipationTest(reelIndex) {
    const container = document.getElementById(`anticipation-container-${reelIndex}`);
    if (container) {
      container.classList.remove('active', 'hot');
      stopAnticipationSound();
    }
  }

  // Show anticipation on reels 3, 4 (normal) then 5 (hot)
  setTimeout(() => {
    showAnticipationTest(2, false);
    console.log('Reel 3: NORMAL anticipation (green glow, particles, scanline)');
  }, 0);

  setTimeout(() => {
    hideAnticipationTest(2);
    showAnticipationTest(3, false);
    console.log('Reel 4: NORMAL anticipation');
  }, 2000);

  setTimeout(() => {
    hideAnticipationTest(3);
    showAnticipationTest(4, true);
    console.log('Reel 5: HOT anticipation (gold/white, screen shake, ALERT flicker!)');
  }, 4000);

  setTimeout(() => {
    hideAnticipationTest(4);
    console.log('Anticipation test complete!');
  }, 7000);
};

// Quick test for individual effects
window.testAnticipationNormal = function(reelIndex = 2) {
  const container = document.getElementById(`anticipation-container-${reelIndex}`);
  if (container) {
    container.classList.remove('hot');
    container.classList.add('active');
    console.log(`Normal anticipation ON for reel ${reelIndex + 1}`);
    console.log('  - Green pulsing glow border');
    console.log('  - BRIGHT scanline sweep');
    console.log('  - anticipation.webp overlay');
    console.log('  - Floating particles');
    playAnticipationSound(false);
  }
};

window.testAnticipationHot = function(reelIndex = 4) {
  const container = document.getElementById(`anticipation-container-${reelIndex}`);
  if (container) {
    container.classList.add('active', 'hot');
    console.log(`HOT anticipation ON for reel ${reelIndex + 1}`);
    console.log('  - Gold/green intense glow');
    console.log('  - MEGA BRIGHT scanline');
    console.log('  - Screen shake effect');
    console.log('  - ALERT flicker!');
    playAnticipationSound(true);
  }
};

window.testAnticipationOff = function() {
  for (let i = 0; i < 5; i++) {
    const container = document.getElementById(`anticipation-container-${i}`);
    if (container) container.classList.remove('active', 'hot');
  }
  stopAnticipationSound();
  console.log('All anticipation effects OFF');
};

// ===========================================
// INIT
// ===========================================
initGame();
</script>

</body>
</html>
