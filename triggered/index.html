<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>TRIGGERED — Cluster Slot</title>
<!-- Version: RGS-v2 2026-02-05 17:15 -->
<style>
  @import url('https://fonts.googleapis.com/css2?family=Lilita+One&family=Nunito:wght@600;700;900&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

  :root {
    --accent: #ff3d5a;
    --gold: #ffd93d;
    --green: #6bcb77;
    --dark: #0d0d0d;
    --panel: rgba(0,0,0,0.65);
    --border: rgba(255,255,255,0.12);
  }

  body {
    background: #000;
    color: #fff;
    font-family: 'Nunito', sans-serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
  }

  /* ── LOADING SCREEN ── */
  .loading-screen {
    position: fixed;
    inset: 0;
    z-index: 1000;
    background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 24px;
    transition: opacity 0.5s ease-out;
  }
  .loading-screen.fade-out {
    opacity: 0;
    pointer-events: none;
  }
  .loading-screen.hidden {
    display: none;
  }

  .loading-logo {
    width: 280px;
    max-width: 80%;
    height: auto;
    filter: drop-shadow(0 0 20px rgba(255,61,90,0.8))
            drop-shadow(0 0 40px rgba(255,61,90,0.5))
            drop-shadow(0 0 60px rgba(255,61,90,0.3))
            drop-shadow(0 4px 8px rgba(0,0,0,0.5));
    animation: loading-shake 0.15s ease-in-out infinite;
  }
  @keyframes loading-shake {
    0%, 100% { transform: translateX(0) rotate(0); }
    25% { transform: translateX(-3px) rotate(-0.5deg); }
    75% { transform: translateX(3px) rotate(0.5deg); }
  }

  .loading-bar-container {
    width: 280px;
    max-width: 80%;
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    overflow: hidden;
  }
  .loading-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--accent), #ff6b8a, var(--accent));
    background-size: 200% 100%;
    border-radius: 2px;
    animation: loading-bar-shimmer 1s ease-in-out infinite;
    transition: width 0.3s ease-out;
  }
  @keyframes loading-bar-shimmer {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }

  .loading-tip {
    font-size: 0.85rem;
    color: rgba(255,255,255,0.7);
    text-align: center;
    max-width: 300px;
    min-height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 20px;
  }

  .loading-status {
    font-size: 0.7rem;
    color: rgba(255,255,255,0.4);
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  /* ══════════════════════════════════════════════════════════════
     GAME WRAPPER - Contains background image and all game elements
     Background is an actual IMG element for precise positioning
     ══════════════════════════════════════════════════════════════ */
  .game-wrapper {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    z-index: 0;
  }

  /* Desktop background image */
  .bg-img {
    position: absolute;
    width: 100%;
    height: 100%;
    object-fit: contain;
    z-index: 0;
  }

  /* Mobile background image - hidden on desktop */
  .bg-img-mobile {
    display: none;
  }

  /* ── GAME CONTAINER ──
     Positioned via JavaScript to match actual rendered image bounds */
  .game-container {
    position: absolute;
    z-index: 1;
    /* JS will set: top, left, width, height */
  }

  /* ── LAPTOP SCREEN AREA ──
     Percentage positions relative to the game container */
  .laptop-screen {
    position: absolute;
    left: 22%;
    top: 17%;
    width: 56%;
    height: 45%;
    display: flex;
    flex-direction: column;
    padding: 1%;
    gap: 0.5%;
    overflow: hidden;
  }

  /* ── CRT SCAN LINES ── */
  .scanlines {
    position: absolute;
    left: 22%;
    top: 17%;
    width: 56%;
    height: 45%;
    pointer-events: none;
    z-index: 10;
    overflow: hidden;
  }
  .scanlines::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 200%;
    background: repeating-linear-gradient(
      0deg,
      transparent 0px,
      transparent 3px,
      rgba(0,0,0,0.06) 3px,
      rgba(0,0,0,0.06) 4px
    );
    animation: scanline-scroll 12s linear infinite;
  }
  @keyframes scanline-scroll {
    0% { transform: translateY(0); }
    100% { transform: translateY(-50%); }
  }

  /* ── TWEET CARDS (Desktop) ── */
  .tweet-container {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 5;
  }
  .tweet-card {
    position: absolute;
    width: 220px;
    background: rgba(30, 30, 40, 0.95);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    padding: 12px 14px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.4);
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.5s ease, transform 0.5s ease;
    backdrop-filter: blur(10px);
  }
  .tweet-card.show {
    opacity: 1;
    transform: translateY(0);
  }
  .tweet-card.left {
    left: 3%;
    top: 35%;
  }
  .tweet-card.right {
    right: 3%;
    top: 30%;
  }
  .tweet-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }
  .tweet-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    flex-shrink: 0;
    object-fit: cover;
  }
  .tweet-handle {
    font-weight: 700;
    font-size: 0.8rem;
    color: #8899a6;
  }
  .tweet-text {
    font-size: 0.85rem;
    color: #fff;
    line-height: 1.45;
    word-wrap: break-word;
  }
  .tweet-footer {
    margin-top: 12px;
    display: flex;
    gap: 16px;
    font-size: 0.65rem;
    color: #8899a6;
  }

  /* ── MOBILE MARQUEE ── */
  .mobile-marquee {
    display: none;
    width: 100%;
    height: 18px;
    background: rgba(0,0,0,0.85);
    border-radius: 4px;
    overflow: hidden;
    flex-shrink: 0;
    order: 10; /* Move to bottom of laptop screen */
  }
  .marquee-track {
    display: inline-flex;
    gap: 60px;
    animation: marquee-scroll 100s linear infinite;
    white-space: nowrap;
    height: 100%;
    align-items: center;
    padding-left: 100%;
  }
  .marquee-item {
    font-size: 0.55rem;
    color: rgba(255,255,255,0.9);
    flex-shrink: 0;
  }
  @keyframes marquee-scroll {
    0% { transform: translateX(0); }
    100% { transform: translateX(calc(-50% - 30px)); }
  }

  /* Hide old notification container */
  .notification-container { display: none; }

  /* ── BROWSER TOOLBAR ── */
  .browser-toolbar {
    display: flex;
    align-items: center;
    background: linear-gradient(180deg, #3a3a3c 0%, #2c2c2e 100%);
    border-radius: 8px 8px 0 0;
    padding: 6px 10px;
    gap: 10px;
    flex-shrink: 0;
    border-bottom: 1px solid rgba(0,0,0,0.3);
  }

  .window-controls {
    display: flex;
    gap: 6px;
    flex-shrink: 0;
  }
  .window-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
  }
  .window-dot.red { background: #ff5f57; }
  .window-dot.yellow { background: #febc2e; }
  .window-dot.green { background: #28c840; }

  .url-bar {
    flex: 1;
    display: flex;
    align-items: center;
    background: rgba(0,0,0,0.35);
    border-radius: 6px;
    padding: 4px 12px;
    min-width: 0;
  }
  .url-icon {
    font-size: 0.6rem;
    margin-right: 6px;
    opacity: 0.5;
  }
  .url-text {
    font-size: 0.65rem;
    color: rgba(255,255,255,0.5);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .toolbar-stats {
    display: flex;
    gap: 6px;
    flex-shrink: 0;
  }
  .stat-badge {
    display: flex;
    align-items: center;
    gap: 4px;
    background: rgba(0,0,0,0.4);
    border-radius: 4px;
    padding: 3px 8px;
  }
  .stat-badge .stat-icon {
    font-size: 0.6rem;
  }
  .stat-badge .stat-label {
    font-size: 0.5rem;
    color: rgba(255,255,255,0.4);
    text-transform: uppercase;
  }
  .stat-badge .stat-value {
    font-weight: 700;
    font-size: 0.7rem;
    color: var(--gold);
  }
  .stat-badge.win-badge .stat-value {
    color: var(--green);
  }

  /* Sound toggle button */
  .sound-toggle {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    background: rgba(0,0,0,0.4);
    border: none;
    color: rgba(255,255,255,0.5);
    font-size: 0.9rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }
  .sound-toggle:hover {
    background: rgba(0,0,0,0.6);
    color: rgba(255,255,255,0.8);
  }
  .sound-toggle.active {
    background: rgba(255,61,90,0.3);
    color: var(--accent);
  }

  /* ── GRID AREA ── */
  .grid-frame {
    flex: 1;
    min-height: 0;
    background: rgba(0,0,0,0.55);
    border-radius: 6px;
    padding: 4px;
    border: 1px solid var(--border);
    box-shadow:
      0 0 10px rgba(0,0,0,0.6),
      inset 0 0 10px rgba(0,0,0,0.3);
    backdrop-filter: blur(6px);
    overflow: hidden;
    transition: all 0.5s ease;
    position: relative;
  }

  /* Progressive meltdown atmosphere */
  .grid-frame.meltdown-1 {
    background: rgba(30,10,10,0.6);
    border-color: rgba(255,100,80,0.3);
  }
  .grid-frame.meltdown-2 {
    background: rgba(50,15,15,0.65);
    border-color: rgba(255,80,60,0.4);
    box-shadow: 0 0 15px rgba(255,50,30,0.3), inset 0 0 15px rgba(255,50,30,0.1);
  }
  .grid-frame.meltdown-3 {
    background: rgba(60,10,10,0.7);
    border-color: rgba(255,60,40,0.6);
    box-shadow: 0 0 20px rgba(255,30,10,0.4), inset 0 0 20px rgba(255,50,30,0.15);
    animation: meltdown-pulse 1s ease-in-out infinite;
  }
  @keyframes meltdown-pulse {
    0%, 100% { box-shadow: 0 0 20px rgba(255,30,10,0.4), inset 0 0 20px rgba(255,50,30,0.15); }
    50% { box-shadow: 0 0 30px rgba(255,50,20,0.5), inset 0 0 25px rgba(255,70,40,0.2); }
  }

  /* Heat embers for meltdown-3 */
  .grid-frame.meltdown-3::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(180deg, transparent 70%, rgba(255,100,50,0.1) 100%);
    pointer-events: none;
    z-index: 100;
  }

  /* Scatter anticipation effect */
  .grid-frame.scatter-anticipation {
    animation: scatter-anticipation-pulse 0.4s ease-in-out infinite;
  }
  @keyframes scatter-anticipation-pulse {
    0%, 100% {
      box-shadow: 0 0 15px rgba(255,100,0,0.5), inset 0 0 10px rgba(255,80,0,0.3);
      border-color: rgba(255,150,50,0.6);
    }
    50% {
      box-shadow: 0 0 25px rgba(255,50,0,0.7), inset 0 0 15px rgba(255,100,0,0.4);
      border-color: rgba(255,100,0,0.8);
    }
  }

  /* Scatter symbol highlight during anticipation */
  .cell.scatter-highlight {
    animation: scatter-symbol-pulse 0.3s ease-in-out infinite alternate;
  }
  @keyframes scatter-symbol-pulse {
    0% { transform: scale(1); filter: brightness(1); }
    100% { transform: scale(1.1); filter: brightness(1.3) drop-shadow(0 0 8px rgba(255,200,0,0.8)); }
  }

  .grid {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(6, 1fr);
    gap: 2px;
    width: 100%;
    height: 100%;
  }

  .cell {
    border-radius: 2px;
    background: rgba(255,255,255,0.04);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
    transition: background 0.15s;
  }

  .cell-content {
    width: 86%;
    height: 86%;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    z-index: 5;
  }

  /* Symbol images use background-image to prevent flickering */
  .symbol-img {
    width: 100%;
    height: 100%;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
  }

  /* Scatter symbol glow - drop-shadow on the symbol image itself, not the cell */
  .scatter-symbol {
    filter: drop-shadow(0 0 8px rgba(255, 61, 90, 0.7)) drop-shadow(0 0 15px rgba(255, 61, 90, 0.4));
    animation: scatter-symbol-pulse 1.5s ease-in-out infinite;
  }
  @keyframes scatter-symbol-pulse {
    0%, 100% { filter: drop-shadow(0 0 8px rgba(255, 61, 90, 0.7)) drop-shadow(0 0 15px rgba(255, 61, 90, 0.4)); }
    50% { filter: drop-shadow(0 0 12px rgba(255, 100, 50, 0.9)) drop-shadow(0 0 20px rgba(255, 61, 90, 0.6)); }
  }

  /* Poof effect - grows across 4 frames, centered in cell */
  .poof-img {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    z-index: 20;
    pointer-events: none;
  }

  .cell-content .fallback {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Lilita One', cursive;
    font-size: 0.7rem;
    color: #fff;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    border: 2px solid rgba(255,255,255,0.25);
  }

  /* Multiplier badge on cell */
  .cell .multi-badge {
    position: absolute;
    bottom: 2px;
    right: 2px;
    background: var(--accent);
    color: #fff;
    font-size: 0.55rem;
    font-weight: 900;
    padding: 1px 4px;
    border-radius: 3px;
    z-index: 5;
    line-height: 1;
    transition: all 0.3s ease;
  }

  /* Multiplier glow levels */
  .cell.multi-1 { box-shadow: inset 0 0 8px rgba(100,149,237,0.6), 0 0 4px rgba(100,149,237,0.4); }
  .cell.multi-1 .multi-badge { background: #6495ED; }

  .cell.multi-2 { box-shadow: inset 0 0 10px rgba(107,203,119,0.7), 0 0 6px rgba(107,203,119,0.5); }
  .cell.multi-2 .multi-badge { background: #6BCB77; }

  .cell.multi-4 { box-shadow: inset 0 0 12px rgba(255,215,61,0.8), 0 0 8px rgba(255,215,61,0.6); }
  .cell.multi-4 .multi-badge { background: #FFD93D; color: #000; }

  .cell.multi-8 {
    box-shadow: inset 0 0 14px rgba(255,140,0,0.8), 0 0 10px rgba(255,140,0,0.6);
    animation: multi-pulse-8 0.8s ease-in-out infinite;
  }
  .cell.multi-8 .multi-badge { background: #FF8C00; }
  @keyframes multi-pulse-8 {
    0%, 100% { box-shadow: inset 0 0 14px rgba(255,140,0,0.8), 0 0 10px rgba(255,140,0,0.6); }
    50% { box-shadow: inset 0 0 18px rgba(255,140,0,1), 0 0 14px rgba(255,140,0,0.8); }
  }

  .cell.multi-16 {
    box-shadow: inset 0 0 16px rgba(255,61,90,0.9), 0 0 12px rgba(255,61,90,0.7);
    animation: multi-pulse-16 0.6s ease-in-out infinite;
  }
  .cell.multi-16 .multi-badge { background: #FF3D5A; }
  @keyframes multi-pulse-16 {
    0%, 100% { box-shadow: inset 0 0 16px rgba(255,61,90,0.9), 0 0 12px rgba(255,61,90,0.7); }
    50% { box-shadow: inset 0 0 22px rgba(255,61,90,1), 0 0 18px rgba(255,61,90,0.9); }
  }

  .cell.multi-32 {
    box-shadow: inset 0 0 18px rgba(255,0,50,1), 0 0 15px rgba(255,0,50,0.8);
    animation: multi-pulse-32 0.5s ease-in-out infinite;
  }
  .cell.multi-32 .multi-badge { background: #FF0032; text-shadow: 0 0 4px #fff; }
  @keyframes multi-pulse-32 {
    0%, 100% { box-shadow: inset 0 0 18px rgba(255,0,50,1), 0 0 15px rgba(255,0,50,0.8); }
    50% { box-shadow: inset 0 0 25px rgba(255,50,100,1), 0 0 22px rgba(255,0,50,1); }
  }

  .cell.multi-64 {
    box-shadow: inset 0 0 20px rgba(200,0,100,1), 0 0 18px rgba(255,0,80,0.9), 0 0 30px rgba(150,0,200,0.5);
    animation: multi-pulse-64 0.4s ease-in-out infinite;
  }
  .cell.multi-64 .multi-badge {
    background: linear-gradient(135deg, #FF0050, #AA00FF);
    text-shadow: 0 0 6px #fff;
    animation: badge-glow 0.3s ease-in-out infinite alternate;
  }
  @keyframes multi-pulse-64 {
    0%, 100% { box-shadow: inset 0 0 20px rgba(200,0,100,1), 0 0 18px rgba(255,0,80,0.9), 0 0 30px rgba(150,0,200,0.5); }
    50% { box-shadow: inset 0 0 28px rgba(255,50,150,1), 0 0 25px rgba(255,0,100,1), 0 0 40px rgba(200,0,255,0.7); }
  }
  @keyframes badge-glow {
    0% { transform: scale(1); }
    100% { transform: scale(1.1); }
  }

  /* Multiplier increase flash - uses gold glow instead of white to not hide symbols */
  .cell.multi-flash::after {
    content: '';
    position: absolute;
    inset: -4px;
    border-radius: 4px;
    background: radial-gradient(circle, rgba(255,217,61,0.7) 0%, transparent 70%);
    animation: multi-flash-anim 0.4s ease-out forwards;
    pointer-events: none;
    z-index: 1;
  }
  @keyframes multi-flash-anim {
    0% { opacity: 1; transform: scale(1.2); }
    100% { opacity: 0; transform: scale(1); }
  }

  /* Symbol idle animation */
  .grid.idle .cell .cell-content {
    animation: symbol-idle 3s ease-in-out infinite;
    animation-delay: var(--idle-delay, 0ms);
  }
  @keyframes symbol-idle {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-2px); }
  }

  /* Win states - enhanced celebration effect */
  .cell.winning {
    z-index: 2;
    animation: win-bg-pulse 0.4s ease-in-out infinite alternate;
    animation-delay: var(--win-delay, 0ms);
  }
  @keyframes win-bg-pulse {
    0% { background: rgba(255,217,61,0.2); }
    50% { background: rgba(255,217,61,0.35); }
    100% { background: rgba(255,217,61,0.25); }
  }

  .cell.winning::before {
    content: '';
    position: absolute;
    inset: -4px;
    border-radius: 4px;
    background: radial-gradient(circle, rgba(255,217,61,0.6) 0%, transparent 70%);
    animation: win-glow-radiate 0.6s ease-out forwards;
    animation-delay: var(--win-delay, 0ms);
    pointer-events: none;
  }
  @keyframes win-glow-radiate {
    0% { transform: scale(0.5); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: scale(1.5); opacity: 0; }
  }

  .cell.winning::after {
    content: '';
    position: absolute;
    inset: 0;
    border: 2px solid var(--gold);
    border-radius: 2px;
    box-shadow:
      0 0 10px var(--gold),
      0 0 20px rgba(255,217,61,0.5),
      inset 0 0 10px rgba(255,217,61,0.3);
    animation: win-border-pulse 0.3s ease-in-out infinite alternate;
    animation-delay: var(--win-delay, 0ms);
    pointer-events: none;
  }
  @keyframes win-border-pulse {
    from { box-shadow: 0 0 8px var(--gold), 0 0 15px rgba(255,217,61,0.4), inset 0 0 8px rgba(255,217,61,0.2); }
    to { box-shadow: 0 0 15px var(--gold), 0 0 30px rgba(255,217,61,0.6), inset 0 0 15px rgba(255,217,61,0.4); }
  }

  .cell.winning .cell-content {
    animation: win-pop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    animation-delay: var(--win-delay, 0ms);
  }
  @keyframes win-pop {
    0% { transform: scale(1); }
    50% { transform: scale(1.18); }
    100% { transform: scale(1.05); }
  }

  /* Sparkle particles on winning cells */
  .cell.winning .sparkle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #fff;
    border-radius: 50%;
    box-shadow: 0 0 4px 1px var(--gold), 0 0 8px 2px rgba(255,217,61,0.5);
    animation: sparkle-shoot 0.5s ease-out forwards;
    pointer-events: none;
  }
  .cell.winning .sparkle:nth-child(2) { animation-delay: 0.05s; }
  .cell.winning .sparkle:nth-child(3) { animation-delay: 0.1s; }
  .cell.winning .sparkle:nth-child(4) { animation-delay: 0.15s; }

  .cell.winning .sparkle.s1 { --sx: -15px; --sy: -15px; }
  .cell.winning .sparkle.s2 { --sx: 15px; --sy: -12px; }
  .cell.winning .sparkle.s3 { --sx: -12px; --sy: 15px; }
  .cell.winning .sparkle.s4 { --sx: 15px; --sy: 12px; }

  @keyframes sparkle-shoot {
    0% { transform: translate(0, 0) scale(1); opacity: 1; }
    100% { transform: translate(var(--sx, 10px), var(--sy, -10px)) scale(0); opacity: 0; }
  }

  /* ══════════════════════════════════════════
     REMOVAL ANIMATION - POOF EFFECT ONLY
     ══════════════════════════════════════════ */

  .cell.removing {
    animation-delay: var(--remove-delay, 0ms);
  }

  /* Simple fade out for cell content (fallback if poof images fail) */
  .cell.removing .cell-content {
    animation: symbol-fadeout 0.3s ease-out forwards;
    animation-delay: var(--remove-delay, 0ms);
  }
  @keyframes symbol-fadeout {
    0% { opacity: 1; }
    100% { opacity: 0; }
  }

  /* Smoke poof effect - now uses .poof-img with background-image (defined above) */

  /* ══════════════════════════════════════════
     DROP ANIMATION WITH BOUNCE & DUST
     ══════════════════════════════════════════ */

  .cell.dropping .cell-content {
    animation: drop-bounce 0.35s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  }
  @keyframes drop-bounce {
    0% { transform: translateY(calc(var(--drop-dist, 1) * -120%)); opacity: 0.2; }
    70% { transform: translateY(5%); opacity: 1; }
    85% { transform: translateY(-3%); }
    100% { transform: translateY(0); opacity: 1; }
  }

  /* Dust puff on landing */
  .cell.dropping::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    width: 0;
    height: 0;
    background: radial-gradient(ellipse at center, rgba(255,255,255,0.4) 0%, transparent 70%);
    border-radius: 50%;
    transform: translateX(-50%);
    animation: dust-puff 0.3s ease-out forwards;
    animation-delay: 0.2s;
    pointer-events: none;
    z-index: 1;
  }
  @keyframes dust-puff {
    0% { width: 0; height: 0; opacity: 0.8; }
    50% { width: 30px; height: 10px; opacity: 0.5; }
    100% { width: 40px; height: 6px; opacity: 0; }
  }

  /* Initial spin animations */
  .cell.spin-out .cell-content {
    animation: spin-out 0.15s ease-in forwards;
  }
  @keyframes spin-out {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0.3); opacity: 0; }
  }

  .cell.spin-in .cell-content {
    animation: spin-in 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    animation-delay: var(--row-delay, 0ms);
    opacity: 0;
    transform: translateY(-200%);
  }
  @keyframes spin-in {
    0% { transform: translateY(-200%); opacity: 0; }
    60% { opacity: 1; }
    100% { transform: translateY(0); opacity: 1; }
  }

  /* ── FREE SPINS INFO IN URL BAR ── */
  /* Free spins info displays IN the URL bar during meltdown mode */
  .fs-url-info {
    display: none;
    align-items: center;
    gap: 6px;
    font-family: 'Lilita One', cursive;
  }
  .fs-url-info.active {
    display: flex;
  }
  .fs-url-fire {
    font-size: 0.9rem;
    animation: fire-flicker 0.3s ease-in-out infinite alternate;
  }
  @keyframes fire-flicker {
    0% { transform: scale(1); filter: brightness(1); }
    100% { transform: scale(1.1); filter: brightness(1.2); }
  }
  .fs-url-label {
    color: var(--accent);
    font-size: 0.7rem;
    letter-spacing: 1px;
  }
  .fs-url-count {
    color: var(--gold);
    font-size: 0.75rem;
    font-weight: bold;
  }
  .fs-url-divider {
    color: rgba(255,255,255,0.3);
    font-size: 0.6rem;
  }
  .fs-url-multi {
    color: var(--green);
    font-size: 0.7rem;
    padding: 1px 6px;
    background: rgba(0,255,136,0.2);
    border-radius: 3px;
    border: 1px solid rgba(0,255,136,0.4);
  }
  .fs-url-total {
    color: var(--gold);
    font-size: 0.75rem;
    font-weight: bold;
    text-shadow: 0 0 8px rgba(255,215,61,0.5);
  }

  /* Hide normal URL text during free spins */
  .url-bar.meltdown .url-text {
    display: none;
  }
  .url-bar.meltdown .url-icon {
    display: none;
  }
  /* Meltdown URL bar styling */
  .url-bar.meltdown {
    background: linear-gradient(90deg, rgba(80,20,40,0.9), rgba(40,10,20,0.9));
    border-color: var(--accent);
    box-shadow: 0 0 10px rgba(255,61,90,0.3);
  }
  /* Tier-based styling for running total in URL bar */
  .fs-url-total.tier-medium {
    font-size: 0.85rem;
    text-shadow: 0 0 12px rgba(255,215,61,0.8);
  }
  .fs-url-total.tier-big {
    font-size: 0.9rem;
    text-shadow: 0 0 15px rgba(255,215,61,1), 0 0 25px rgba(255,140,0,0.6);
    animation: total-pulse 0.5s ease-in-out infinite;
  }
  .fs-url-total.tier-mega {
    font-size: 0.95rem;
    background: linear-gradient(90deg, var(--gold), var(--accent), var(--gold));
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    filter: drop-shadow(0 0 8px rgba(255,61,90,0.8));
    animation: total-mega 0.3s ease-in-out infinite, total-gradient 2s linear infinite;
  }
  @keyframes total-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  @keyframes total-mega {
    0%, 100% { transform: scale(1) rotate(-0.5deg); }
    50% { transform: scale(1.08) rotate(0.5deg); }
  }
  @keyframes total-gradient {
    0% { background-position: 0% center; }
    100% { background-position: 200% center; }
  }

  /* ── DOCK CONTROLS ── */
  .dock {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    background: rgba(255,255,255,0.08);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 16px;
    padding: 6px 12px;
    border: 1px solid rgba(255,255,255,0.12);
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    flex-shrink: 0;
  }

  .dock-divider {
    width: 1px;
    height: 24px;
    background: rgba(255,255,255,0.15);
    margin: 0 4px;
  }

  .dock-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.06);
    border-radius: 10px;
    padding: 4px 10px;
    cursor: pointer;
    transition: all 0.15s ease;
    border: 1px solid transparent;
  }
  .dock-item:hover {
    background: rgba(255,255,255,0.12);
    transform: translateY(-2px);
  }
  .dock-item .dock-icon {
    font-size: 0.9rem;
    margin-bottom: 1px;
  }
  .dock-item .dock-label {
    font-size: 0.45rem;
    color: rgba(255,255,255,0.5);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .dock-item.active {
    background: rgba(255,61,90,0.2);
    border-color: var(--accent);
  }
  .dock-item.active .dock-label {
    color: var(--accent);
  }
  .dock-item.disabled {
    opacity: 0.4;
    pointer-events: none;
    cursor: not-allowed;
  }

  /* Turbo mode button */
  .dock-item.turbo-active {
    background: rgba(255,215,0,0.3);
    border-color: var(--gold);
    box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 0 8px rgba(255,215,0,0.2);
  }
  .dock-item.turbo-active .dock-icon {
    animation: turbo-pulse 0.5s ease-in-out infinite;
  }
  @keyframes turbo-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
  }

  /* Autoplay button and dropdown */
  .autoplay-container {
    position: relative;
  }
  .autoplay-dropdown {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(20,20,25,0.95);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px;
    display: none;
    flex-direction: column;
    gap: 4px;
    min-width: 80px;
    margin-bottom: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    z-index: 100;
  }
  .autoplay-dropdown.show {
    display: flex;
  }
  .autoplay-option {
    background: rgba(255,255,255,0.1);
    border: none;
    color: #fff;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.75rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.15s;
  }
  .autoplay-option:hover {
    background: rgba(255,61,90,0.3);
  }
  .dock-item .auto-count {
    font-size: 0.55rem;
    color: var(--gold);
    font-weight: 700;
  }

  .bet-controls {
    display: flex;
    align-items: center;
    gap: 2px;
    background: rgba(0,0,0,0.25);
    border-radius: 8px;
    padding: 2px;
  }

  .bet-btn {
    background: rgba(255,255,255,0.1);
    border: none;
    color: #fff;
    width: 22px;
    height: 22px;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 700;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.15s;
  }
  .bet-btn:hover { background: rgba(255,255,255,0.2); }

  .bet-amount {
    min-width: 50px;
    text-align: center;
    padding: 0 6px;
  }
  .bet-amount .bet-label {
    font-size: 0.4rem;
    color: rgba(255,255,255,0.4);
    text-transform: uppercase;
  }
  .bet-amount .bet-value {
    font-weight: 700;
    font-size: 0.7rem;
    color: var(--gold);
  }

  .spin-btn {
    background: linear-gradient(135deg, var(--accent) 0%, #cc1133 100%);
    border: none;
    border-radius: 50%;
    width: 48px;
    height: 48px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow:
      0 0 20px rgba(255,61,90,0.5),
      0 4px 12px rgba(0,0,0,0.3),
      inset 0 1px 0 rgba(255,255,255,0.2);
    transition: all 0.15s ease;
    flex-shrink: 0;
    position: relative;
  }
  .spin-btn::before {
    content: '';
    position: absolute;
    inset: 3px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.2);
  }
  .spin-btn .spin-icon {
    font-size: 1.3rem;
    color: #fff;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
  }
  .spin-btn:hover {
    transform: scale(1.08);
    box-shadow:
      0 0 30px rgba(255,61,90,0.7),
      0 6px 16px rgba(0,0,0,0.4),
      inset 0 1px 0 rgba(255,255,255,0.2);
  }
  .spin-btn:active { transform: scale(0.95); }
  .spin-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
  }

  /* ── WIN DISPLAY ── */
  .win-display {
    min-height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    flex-shrink: 0;
  }

  .win-text {
    font-family: 'Lilita One', cursive;
    font-size: 0.9rem;
    color: var(--gold);
    text-shadow: 0 2px 8px rgba(255,217,61,0.5);
    opacity: 0;
    transition: opacity 0.3s;
  }
  .win-text.show { opacity: 1; }

  /* ── WIN BANNER OVERLAY (Tweet Style) ── */
  .win-banner-overlay {
    position: fixed;
    inset: 0;
    z-index: 100;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.8);
    backdrop-filter: blur(6px);
    cursor: pointer;
  }
  .win-banner-overlay.show { display: flex; }

  .win-tweet-wrapper {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    animation: tweet-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  .win-banner-image {
    width: 220px;
    height: auto;
    position: relative;
    z-index: 2;
    margin-bottom: -60px;
    filter: drop-shadow(0 8px 24px rgba(0,0,0,0.5));
  }

  .win-banner-fallback {
    width: 220px;
    height: 110px;
    position: relative;
    z-index: 2;
    margin-bottom: -60px;
    border-radius: 12px;
    display: none;
    align-items: center;
    justify-content: center;
    font-family: 'Lilita One', cursive;
    font-size: 1.4rem;
    color: #fff;
    text-shadow: 0 2px 10px rgba(0,0,0,0.4);
    letter-spacing: 3px;
    filter: drop-shadow(0 8px 24px rgba(0,0,0,0.5));
  }

  .win-tweet-card {
    width: 340px;
    max-width: 90vw;
    background: #fff;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 10px 50px rgba(0,0,0,0.5);
    position: relative;
    z-index: 1;
  }

  .win-tweet-body {
    padding: 50px 16px 14px 16px;
  }

  .win-tweet-user {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }
  .win-tweet-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    flex-shrink: 0;
    object-fit: cover;
  }
  .win-tweet-user-info {
    flex: 1;
    min-width: 0;
  }
  .win-tweet-name {
    font-weight: 700;
    font-size: 0.9rem;
    color: #0f1419;
  }
  .win-tweet-handle {
    font-size: 0.8rem;
    color: #536471;
  }

  .win-tweet-text {
    font-size: 1rem;
    color: #0f1419;
    line-height: 1.5;
    margin-bottom: 12px;
  }
  .win-tweet-amount {
    font-weight: 700;
    color: #1d9bf0;
  }

  .win-tweet-stats {
    display: flex;
    gap: 20px;
    padding-top: 12px;
    border-top: 1px solid #eff3f4;
    font-size: 0.85rem;
    color: #536471;
  }
  .win-tweet-stat {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .win-tweet-tap {
    text-align: center;
    padding: 10px;
    font-size: 0.7rem;
    color: #536471;
    background: #f7f9f9;
  }

  @keyframes tweet-in {
    from { transform: scale(0.8) translateY(20px); opacity: 0; }
    to { transform: scale(1) translateY(0); opacity: 1; }
  }

  /* ── FREE SPINS TOTAL WIN SCREEN ── */
  .fs-total-overlay {
    position: fixed;
    inset: 0;
    z-index: 100;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.9);
    backdrop-filter: blur(8px);
    cursor: pointer;
  }
  .fs-total-overlay.show { display: flex; }

  .fs-total-wrapper {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    animation: tweet-in 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  .fs-total-banner {
    width: 280px;
    height: auto;
    position: relative;
    z-index: 2;
    margin-bottom: -70px;
    filter: drop-shadow(0 8px 30px rgba(255,61,90,0.6));
    animation: fs-total-banner-glow 1.5s ease-in-out infinite alternate;
  }
  @keyframes fs-total-banner-glow {
    from { filter: drop-shadow(0 8px 25px rgba(255,61,90,0.5)); }
    to { filter: drop-shadow(0 8px 40px rgba(255,61,90,0.8)); }
  }

  .fs-total-card {
    width: 400px;
    max-width: 95vw;
    background: #fff;
    border-radius: 20px;
    overflow: hidden;
    box-shadow: 0 15px 60px rgba(0,0,0,0.5);
    position: relative;
    z-index: 1;
  }

  .fs-total-body {
    padding: 60px 20px 20px 20px;
  }

  .fs-total-user {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 14px;
  }
  .fs-total-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    flex-shrink: 0;
    object-fit: cover;
  }
  .fs-total-user-info { flex: 1; }
  .fs-total-name {
    font-weight: 700;
    font-size: 1rem;
    color: #0f1419;
  }
  .fs-total-handle {
    font-size: 0.9rem;
    color: #536471;
  }

  .fs-total-text {
    font-size: 1.1rem;
    color: #0f1419;
    line-height: 1.5;
    margin-bottom: 16px;
  }
  .fs-total-text .amount {
    font-weight: 700;
    color: var(--accent);
  }

  .fs-total-win-box {
    text-align: center;
    padding: 20px;
    background: linear-gradient(135deg, rgba(255,217,61,0.2), rgba(255,217,61,0.1));
    border-radius: 12px;
    margin-bottom: 16px;
    border: 2px solid var(--gold);
  }
  .fs-total-win-label {
    font-size: 0.8rem;
    color: #536471;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 4px;
  }
  .fs-total-win-amount {
    font-family: 'Lilita One', cursive;
    font-size: 2.8rem;
    color: var(--gold);
    text-shadow: 0 2px 10px rgba(255,217,61,0.5);
    letter-spacing: 2px;
    animation: fs-total-amount-pulse 1s ease-in-out infinite;
  }
  @keyframes fs-total-amount-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  .fs-total-stats {
    display: flex;
    gap: 24px;
    padding-top: 14px;
    border-top: 1px solid #eff3f4;
    font-size: 1rem;
    color: #536471;
    justify-content: center;
  }
  .fs-total-stat {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .fs-total-stat-value {
    font-weight: 700;
    color: #0f1419;
  }

  .fs-total-tap {
    text-align: center;
    padding: 14px;
    font-size: 0.8rem;
    color: #536471;
    background: #f7f9f9;
    font-weight: 600;
  }

  /* ── FREESPIN TRIGGER OVERLAY ── */
  .fs-trigger-overlay {
    position: fixed;
    inset: 0;
    z-index: 100;
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.3s ease-out;
  }
  .fs-trigger-overlay.show {
    display: flex;
    opacity: 1;
  }
  .fs-trigger-overlay.fade-out {
    opacity: 0;
  }

  /* Background with radial pulse */
  .fs-bg {
    position: absolute;
    inset: 0;
    background: radial-gradient(circle at 50% 50%, rgba(255,61,90,0.4) 0%, rgba(0,0,0,0.95) 70%);
    animation: fs-bg-pulse 1.5s ease-in-out infinite;
  }
  @keyframes fs-bg-pulse {
    0%, 100% { background: radial-gradient(circle at 50% 50%, rgba(255,61,90,0.3) 0%, rgba(0,0,0,0.95) 60%); }
    50% { background: radial-gradient(circle at 50% 50%, rgba(255,100,50,0.5) 0%, rgba(0,0,0,0.95) 70%); }
  }

  /* Pulsing red vignette */
  .fs-vignette {
    position: absolute;
    inset: 0;
    box-shadow: inset 0 0 150px 50px rgba(255,0,0,0.3);
    animation: fs-vignette-pulse 1s ease-in-out infinite alternate;
    pointer-events: none;
  }
  @keyframes fs-vignette-pulse {
    from { box-shadow: inset 0 0 150px 50px rgba(255,0,0,0.2); }
    to { box-shadow: inset 0 0 200px 80px rgba(255,0,0,0.4); }
  }

  /* White flash effect */
  .fs-flash {
    position: absolute;
    inset: 0;
    background: #fff;
    opacity: 0;
    pointer-events: none;
  }
  .fs-flash.active {
    animation: fs-flash-anim 0.15s ease-out;
  }
  @keyframes fs-flash-anim {
    0% { opacity: 0.9; }
    100% { opacity: 0; }
  }

  /* Ember particles */
  .fs-embers {
    position: absolute;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
  }
  .fs-ember {
    position: absolute;
    bottom: -20px;
    width: 4px;
    height: 4px;
    background: #ff6b35;
    border-radius: 50%;
    box-shadow: 0 0 6px 2px rgba(255,100,50,0.8);
    animation: fs-ember-rise linear infinite;
  }
  @keyframes fs-ember-rise {
    0% { transform: translateY(0) translateX(0) scale(1); opacity: 1; }
    50% { opacity: 0.8; }
    100% { transform: translateY(-100vh) translateX(var(--drift, 20px)) scale(0.3); opacity: 0; }
  }

  /* Main content wrapper with zoom */
  .fs-content {
    position: relative;
    z-index: 2;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    animation: fs-zoom-in 3.5s ease-out forwards;
  }
  @keyframes fs-zoom-in {
    from { transform: scale(0.95); }
    to { transform: scale(1.05); }
  }

  /* Breaking news bar */
  .fs-news-bar {
    width: 100%;
    max-width: 800px;
    background: linear-gradient(180deg, #1a0a0a 0%, #2a0a0a 50%, #1a0a0a 100%);
    border-top: 3px solid #ff3d5a;
    border-bottom: 3px solid #ff3d5a;
    box-shadow: 0 0 60px rgba(255,61,90,0.5), inset 0 0 100px rgba(0,0,0,0.5);
    position: relative;
    overflow: hidden;
  }
  /* Noise texture overlay */
  .fs-news-bar::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
    opacity: 0.08;
    pointer-events: none;
  }
  /* Glitch effect */
  .fs-news-bar::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg, transparent 0%, rgba(255,0,0,0.1) 50%, transparent 100%);
    animation: fs-glitch 2s steps(1) infinite;
    pointer-events: none;
  }
  @keyframes fs-glitch {
    0%, 90%, 100% { transform: translateX(0); opacity: 0; }
    92% { transform: translateX(-5px) skewX(-2deg); opacity: 1; }
    94% { transform: translateX(5px) skewX(2deg); opacity: 1; }
    96% { transform: translateX(-3px); opacity: 0.5; }
    98% { transform: translateX(3px); opacity: 0; }
  }

  /* Scrolling ticker */
  .fs-ticker {
    background: linear-gradient(90deg, #cc0000, #ff0000, #cc0000);
    padding: 6px 0;
    overflow: hidden;
    white-space: nowrap;
  }
  .fs-ticker-text {
    display: inline-block;
    font-family: 'Nunito', sans-serif;
    font-weight: 900;
    font-size: 0.75rem;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 2px;
    animation: fs-ticker-scroll 15s linear infinite;
    padding-left: 100%;
  }
  @keyframes fs-ticker-scroll {
    0% { transform: translateX(0); }
    100% { transform: translateX(-50%); }
  }

  /* Center content area */
  .fs-center {
    padding: 30px 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }

  /* Banner image */
  .fs-banner-img {
    max-width: 280px;
    width: 80%;
    height: auto;
    filter: drop-shadow(0 0 30px rgba(255,61,90,0.8));
    animation: fs-banner-glow 1s ease-in-out infinite alternate;
  }
  @keyframes fs-banner-glow {
    from { filter: drop-shadow(0 0 20px rgba(255,61,90,0.6)); }
    to { filter: drop-shadow(0 0 40px rgba(255,61,90,1)); }
  }

  /* Spins count */
  .fs-spins-text {
    font-family: 'Lilita One', cursive;
    font-size: 3.5rem;
    color: var(--gold);
    text-shadow:
      0 0 20px rgba(255,217,61,0.8),
      0 0 40px rgba(255,217,61,0.5),
      0 4px 8px rgba(0,0,0,0.5);
    letter-spacing: 4px;
    animation: fs-spins-pulse 0.8s ease-in-out infinite;
  }
  @keyframes fs-spins-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.08); }
  }

  /* Multiplier text */
  .fs-multi-text {
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    font-size: 1.1rem;
    color: #fff;
    text-shadow: 0 0 20px rgba(255,150,50,0.8), 0 0 40px rgba(255,100,0,0.5);
    letter-spacing: 1px;
  }

  /* Tap to dismiss text */
  .fs-dismiss-text {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.7rem;
    color: rgba(255,255,255,0.4);
    letter-spacing: 1px;
    z-index: 3;
  }

  /* Heavy shake animation */
  @keyframes fs-heavy-shake {
    0%, 100% { transform: translate(0, 0) rotate(0); }
    10% { transform: translate(-8px, -6px) rotate(-1deg); }
    20% { transform: translate(8px, 4px) rotate(1deg); }
    30% { transform: translate(-6px, 8px) rotate(-0.5deg); }
    40% { transform: translate(6px, -4px) rotate(0.5deg); }
    50% { transform: translate(-4px, 6px) rotate(-1deg); }
    60% { transform: translate(4px, -8px) rotate(1deg); }
    70% { transform: translate(-8px, 4px) rotate(-0.5deg); }
    80% { transform: translate(8px, 6px) rotate(0.5deg); }
    90% { transform: translate(-4px, -6px) rotate(0); }
  }
  .game-container.fs-shake {
    animation: fs-heavy-shake 0.5s ease-in-out infinite;
  }

  /* ── PAYTABLE PANEL ── */
  .paytable-overlay {
    position: fixed;
    inset: 0;
    z-index: 200;
    display: none;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(8px);
    overflow-y: auto;
    padding: 20px;
  }
  .paytable-overlay.show { display: block; }

  .paytable {
    max-width: 500px;
    margin: 0 auto;
  }
  .paytable-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
  }
  .paytable-header h2 {
    font-family: 'Lilita One', cursive;
    font-size: 1.5rem;
    color: var(--accent);
  }
  .paytable-close {
    background: none;
    border: none;
    color: rgba(255,255,255,0.5);
    font-size: 1.8rem;
    cursor: pointer;
    padding: 4px 10px;
  }

  .pt-section-title {
    font-family: 'Lilita One', cursive;
    font-size: 0.9rem;
    color: var(--gold);
    margin: 16px 0 8px;
    padding-left: 8px;
    border-left: 3px solid var(--accent);
  }

  .pt-row {
    display: flex;
    align-items: center;
    gap: 12px;
    background: rgba(255,255,255,0.04);
    border-radius: 8px;
    padding: 8px 12px;
    margin-bottom: 6px;
  }
  .pt-symbol {
    width: 40px;
    height: 40px;
    flex-shrink: 0;
  }
  .pt-pays {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    flex: 1;
  }
  .pt-pay {
    text-align: center;
    min-width: 55px;
  }
  .pt-pay .cluster-size {
    font-size: 0.6rem;
    color: rgba(255,255,255,0.35);
  }
  .pt-pay .payout {
    font-weight: 900;
    font-size: 0.85rem;
    color: var(--gold);
  }

  .pt-info {
    background: rgba(255,255,255,0.04);
    border-radius: 8px;
    padding: 12px;
    margin-top: 12px;
    font-size: 0.75rem;
    color: rgba(255,255,255,0.5);
    line-height: 1.6;
  }
  .pt-info strong { color: rgba(255,255,255,0.8); }

  /* ── CONFIRM DIALOG ── */
  .confirm-overlay {
    position: fixed;
    inset: 0;
    z-index: 200;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.8);
    backdrop-filter: blur(6px);
  }
  .confirm-overlay.show { display: flex; }

  .confirm-box {
    background: #1a1a2e;
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 24px;
    text-align: center;
    max-width: 320px;
    width: 90%;
  }
  .confirm-box h3 {
    font-family: 'Lilita One', cursive;
    color: var(--accent);
    font-size: 1.2rem;
    margin-bottom: 8px;
  }
  .confirm-box p {
    font-size: 0.85rem;
    color: rgba(255,255,255,0.6);
    margin-bottom: 16px;
  }
  .confirm-box .cost {
    color: var(--gold);
    font-weight: 900;
    font-size: 1.1rem;
  }
  .confirm-btns {
    display: flex;
    gap: 10px;
    justify-content: center;
  }
  .confirm-btns button {
    font-family: 'Nunito', sans-serif;
    font-weight: 900;
    padding: 8px 24px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    font-size: 0.85rem;
  }
  .confirm-yes {
    background: var(--accent);
    color: #fff;
  }
  .confirm-no {
    background: rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.6);
  }

  /* ── SCREEN SHAKE ── */
  .game-container.shake {
    animation: screen-shake 0.4s ease-in-out;
  }
  @keyframes screen-shake {
    0%, 100% { transform: translate(0); }
    10% { transform: translate(-4px, 2px); }
    20% { transform: translate(4px, -2px); }
    30% { transform: translate(-3px, -3px); }
    40% { transform: translate(3px, 3px); }
    50% { transform: translate(-2px, 1px); }
    60% { transform: translate(2px, -1px); }
    70% { transform: translate(-1px, 2px); }
    80% { transform: translate(1px, -1px); }
    90% { transform: translate(-1px, 1px); }
  }

  /* ── RESPONSIVE ── */
  /* Desktop: Show tweet cards, hide mobile marquee */
  @media (min-width: 769px) {
    .mobile-marquee { display: none !important; }
    .tweet-container { display: block; }
  }

  /* ══════════════════════════════════════════════════════════════
     MOBILE LAYOUT (under 768px) - COMPLETE OVERRIDE

     Structure from top to bottom:
     1. Browser toolbar (inside laptop screen)
     2. Game grid (inside laptop screen)
     3. Scrolling ticker (MOVED outside laptop, above controls via JS)
     4. Controls bar (MOVED TO BODY via JS, fixed to bottom of viewport)
     ══════════════════════════════════════════════════════════════ */
  @media screen and (max-width: 768px) {

    /* === VIEWPORT LOCK === */
    html, body {
      overflow: hidden !important;
      height: 100vh !important;
      height: 100dvh !important;
      width: 100vw !important;
      position: fixed !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    /* === SWAP BACKGROUND IMAGES === */
    .bg-img {
      display: none !important;
    }
    .bg-img-mobile {
      display: block !important;
      position: absolute !important;
      width: 100% !important;
      height: 100% !important;
      object-fit: contain !important;
      object-position: top center !important;
      z-index: 0 !important;
    }

    /* === HIDE TWEET CARDS ON MOBILE === */
    .tweet-container {
      display: none !important;
    }

    /* === BROWSER TOOLBAR - Compact, flush to top === */
    .browser-toolbar {
      position: relative !important;
      width: 100% !important;
      padding: 2px 4px !important;
      margin: 0 !important;
      gap: 3px !important;
      border-radius: 3px 3px 0 0 !important;
      flex-shrink: 0 !important;
    }
    .window-dot {
      width: 5px !important;
      height: 5px !important;
    }
    .url-bar {
      padding: 1px 4px !important;
    }
    .url-text {
      font-size: 0.4rem !important;
    }
    .stat-badge {
      padding: 1px 3px !important;
    }
    .stat-badge .stat-value {
      font-size: 0.45rem !important;
    }
    .stat-badge .stat-label {
      font-size: 0.25rem !important;
    }
    .sound-toggle {
      font-size: 0.7rem !important;
      padding: 1px 3px !important;
    }

    /* === GRID FRAME - Fills space between toolbar and marquee === */
    .grid-frame {
      position: relative !important;
      width: 100% !important;
      flex: 1 1 auto !important;
      min-height: 0 !important;
      padding: 1px !important;
      margin: 0 !important;
      border-radius: 0 !important;
    }

    /* === GRID - Smaller cells to fit 6 rows in laptop screen === */
    .grid {
      width: 100% !important;
      height: 100% !important;
      gap: 1px !important;
    }

    .cell {
      border-radius: 1px !important;
    }
    .cell-content {
      width: 88% !important;
      height: 88% !important;
    }

    /* === MOBILE MARQUEE - At bottom of laptop screen === */
    .mobile-marquee {
      display: block !important;
      position: relative !important;
      width: 100% !important;
      height: 14px !important;
      flex-shrink: 0 !important;
      margin: 0 !important;
      order: 10 !important;
    }
    .marquee-item {
      font-size: 0.4rem !important;
    }

    /* === WIN DISPLAY === */
    .win-display {
      position: absolute !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
    }
    .win-text {
      font-size: 0.7rem !important;
    }

    /* === FREESPIN BAR === */
    /* Free spins URL bar info - mobile sizes */
    .fs-url-info {
      gap: 3px !important;
    }
    .fs-url-fire {
      font-size: 0.6rem !important;
    }
    .fs-url-label {
      font-size: 0.45rem !important;
    }
    .fs-url-count {
      font-size: 0.5rem !important;
    }
    .fs-url-divider {
      font-size: 0.4rem !important;
    }
    .fs-url-multi {
      font-size: 0.45rem !important;
      padding: 0px 3px !important;
    }
    .fs-url-total {
      font-size: 0.5rem !important;
    }

    /* === AUTOPLAY MENU - Opens upward from fixed dock === */
    .autoplay-menu {
      position: fixed !important;
      bottom: 90px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      font-size: 0.6rem !important;
      min-width: 120px !important;
      z-index: 10000 !important;
    }

    /* === OVERLAYS === */
    .win-banner-overlay,
    .fs-total-overlay,
    .fs-trigger-overlay {
      padding: 12px !important;
      z-index: 10001 !important;
    }
  }

  /* ═══════════════════════════════════════════════════════════════
     MOBILE DOCK - Styles for when dock is moved to body via JavaScript
     Applied via .mobile-dock class added by JS
     ═══════════════════════════════════════════════════════════════ */
  .mobile-dock {
    position: fixed !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    top: auto !important;
    width: 100vw !important;
    height: auto !important;
    min-height: 65px !important;
    margin: 0 !important;
    padding: 10px 8px !important;
    padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px)) !important;
    gap: 5px !important;
    border-radius: 0 !important;
    background: #0a0a14 !important;
    backdrop-filter: none !important;
    border: none !important;
    border-top: 1px solid rgba(255,255,255,0.15) !important;
    box-shadow: 0 -4px 20px rgba(0,0,0,0.9) !important;
    z-index: 9999 !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    flex-wrap: nowrap !important;
  }

  .mobile-dock .dock-item {
    padding: 6px 8px !important;
    min-height: 40px !important;
    border-radius: 8px !important;
    background: rgba(255,255,255,0.1) !important;
  }
  .mobile-dock .dock-item .dock-icon {
    font-size: 1.1rem !important;
  }
  .mobile-dock .dock-item .dock-label {
    font-size: 0.4rem !important;
  }

  .mobile-dock .dock-divider {
    width: 1px !important;
    height: 35px !important;
    margin: 0 3px !important;
    background: rgba(255,255,255,0.2) !important;
  }

  .mobile-dock .bet-controls {
    border-radius: 8px !important;
    padding: 3px 5px !important;
    background: rgba(255,255,255,0.08) !important;
    min-height: 40px !important;
  }
  .mobile-dock .bet-btn {
    width: 36px !important;
    height: 36px !important;
    min-width: 36px !important;
    min-height: 36px !important;
    font-size: 1.2rem !important;
  }
  .mobile-dock .bet-amount {
    min-width: 50px !important;
    padding: 0 6px !important;
  }
  .mobile-dock .bet-amount .bet-value {
    font-size: 0.8rem !important;
  }
  .mobile-dock .bet-amount .bet-label {
    font-size: 0.35rem !important;
  }

  /* SPIN BUTTON - Large for easy tapping */
  .mobile-dock .spin-btn {
    width: 56px !important;
    height: 56px !important;
    min-width: 56px !important;
    min-height: 56px !important;
  }
  .mobile-dock .spin-btn .spin-icon {
    font-size: 1.5rem !important;
  }

  /* ═══════════════════════════════════════════════════════════════
     MOBILE MARQUEE (MOVED) - When marquee is moved to body via JavaScript
     Fixed position above the dock/controls bar
     ═══════════════════════════════════════════════════════════════ */
  .mobile-marquee-moved {
    display: block !important;
    position: fixed !important;
    bottom: 85px !important; /* Just above the dock (65px min-height + safe area) */
    left: 0 !important;
    right: 0 !important;
    top: auto !important;
    width: 100vw !important;
    height: 24px !important;
    margin: 0 !important;
    padding: 0 !important;
    background: rgba(10, 10, 20, 0.95) !important;
    border-top: 1px solid rgba(255, 255, 255, 0.1) !important;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important;
    z-index: 9998 !important; /* Just below dock (9999) */
    overflow: hidden !important;
  }
  .mobile-marquee-moved .marquee-track {
    animation-duration: 60s !important; /* Slower scroll for readability */
  }
  .mobile-marquee-moved .marquee-item {
    font-size: 0.55rem !important;
    padding: 0 20px !important;
  }

  /* ═══════════════════════════════════════════════════════════════
     MOBILE TWEET POPUP - Replaces scrolling ticker on mobile
     Fixed position above the dock, fades in/out
     ═══════════════════════════════════════════════════════════════ */
  .mobile-tweet-popup {
    display: none;
    position: fixed;
    bottom: 130px; /* Above the dock */
    left: 50%;
    transform: translateX(-50%) translateY(10px);
    width: 90%;
    max-width: 340px;
    background: rgba(20, 20, 30, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.15);
    border-radius: 12px;
    padding: 10px 12px;
    box-shadow: 0 6px 25px rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(10px);
    z-index: 9000;
    opacity: 0;
    transition: opacity 0.4s ease, transform 0.4s ease;
  }
  .mobile-tweet-popup.show {
    display: block;
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
  .mobile-tweet-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 6px;
  }
  .mobile-tweet-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    flex-shrink: 0;
    object-fit: cover;
  }
  .mobile-tweet-handle {
    font-weight: 700;
    font-size: 0.7rem;
    color: #8899a6;
  }
  .mobile-tweet-text {
    font-size: 0.75rem;
    color: #fff;
    line-height: 1.4;
    word-wrap: break-word;
  }

</style>
</head>
<body>

<!-- LOADING SCREEN -->
<div class="loading-screen" id="loadingScreen">
  <img class="loading-logo" src="logo/logo.png" alt="TRIGGERED">
  <div class="loading-bar-container">
    <div class="loading-bar" id="loadingBar"></div>
  </div>
  <div class="loading-tip" id="loadingTip">Checking your privilege...</div>
  <div class="loading-status" id="loadingStatus">Loading safe space...</div>
</div>

<!-- GAME WRAPPER - Contains background image and all game elements -->
<div class="game-wrapper" id="gameWrapper">
  <!-- Background as actual IMG for precise positioning -->
  <img src="bg/background.png" class="bg-img" id="bgImg" alt="">
  <img src="bg/mobile.png" class="bg-img-mobile" id="bgImgMobile" alt="">

  <!-- Game elements positioned relative to rendered image -->
  <div class="game-container" id="gameContainer">
    <div class="laptop-screen" id="laptopScreen">
    <!-- BROWSER TOOLBAR -->
    <div class="browser-toolbar">
      <div class="window-controls">
        <div class="window-dot red"></div>
        <div class="window-dot yellow"></div>
        <div class="window-dot green"></div>
      </div>
      <!-- URL BAR: Shows normal URL or FREE SPINS info -->
      <div class="url-bar">
        <span class="url-icon" id="urlIcon">🔒</span>
        <span class="url-text" id="urlText">meltdown-mode.com/triggered</span>
        <!-- Free spins info - hidden by default, replaces URL during free spins -->
        <div class="fs-url-info" id="fsUrlInfo">
          <span class="fs-url-fire">🔥</span>
          <span class="fs-url-label">MELTDOWN</span>
          <span class="fs-url-count" id="fsCount">0/0</span>
          <span class="fs-url-divider">|</span>
          <span class="fs-url-multi" id="fsMulti">×1</span>
          <span class="fs-url-divider">|</span>
          <span class="fs-url-total" id="fsRunningAmount">$0.00</span>
        </div>
      </div>
      <div class="toolbar-stats">
        <div class="stat-badge">
          <span class="stat-value" id="balanceDisplay">$1,000.00</span>
        </div>
        <div class="stat-badge win-badge">
          <span class="stat-label">Win</span>
          <span class="stat-value" id="winDisplay">$0.00</span>
        </div>
      </div>
      <button class="sound-toggle" id="soundToggle" onclick="toggleSound()" title="Toggle Sound">🔇</button>
    </div>

    <!-- GAME GRID - Clean, no overlapping UI -->
    <div class="grid-frame">
      <div class="grid" id="grid"></div>
    </div>

    <!-- WIN TEXT -->
    <div class="win-display">
      <div class="win-text" id="winText"></div>
    </div>

    <!-- DOCK CONTROLS -->
    <div class="dock">
      <div class="dock-item" onclick="openPaytable()">
        <span class="dock-icon">📋</span>
        <span class="dock-label">Pay</span>
      </div>

      <div class="dock-divider"></div>

      <div class="bet-controls">
        <button class="bet-btn" onclick="changeBet(-1)">−</button>
        <div class="bet-amount">
          <div class="bet-label">Bet</div>
          <div class="bet-value" id="betDisplay">$1.00</div>
        </div>
        <button class="bet-btn" onclick="changeBet(1)">+</button>
      </div>

      <button class="spin-btn" id="spinBtn" onclick="spin()" disabled>
        <span class="spin-icon">▶</span>
      </button>

      <div class="autoplay-container">
        <div class="dock-item" id="autoplayBtn" onclick="toggleAutoplayMenu()">
          <span class="dock-icon">🔄</span>
          <span class="dock-label" id="autoplayLabel">Auto</span>
        </div>
        <div class="autoplay-dropdown" id="autoplayDropdown">
          <button class="autoplay-option" onclick="startAutoplay(10)">10 Spins</button>
          <button class="autoplay-option" onclick="startAutoplay(25)">25 Spins</button>
          <button class="autoplay-option" onclick="startAutoplay(50)">50 Spins</button>
          <button class="autoplay-option" onclick="startAutoplay(100)">100 Spins</button>
        </div>
      </div>

      <div class="dock-item" id="turboBtn" onclick="toggleTurbo()">
        <span class="dock-icon">⚡</span>
        <span class="dock-label">Turbo</span>
      </div>

      <div class="dock-divider"></div>

      <div class="dock-item active" id="buyBtn" onclick="showBuyConfirm()">
        <span class="dock-icon">🔥</span>
        <span class="dock-label">Buy</span>
      </div>
    </div>
  </div>

  <!-- CRT SCAN LINES -->
  <div class="scanlines" id="scanlines"></div>
</div>
</div>

<!-- TWEET CARDS (Desktop - outside laptop, over coffee shop) -->
<div class="tweet-container" id="tweetContainer">
  <div class="tweet-card left" id="tweetLeft">
    <div class="tweet-header">
      <img class="tweet-avatar" id="tweetAvatarLeft" src="" alt="">
      <div class="tweet-handle" id="tweetHandleLeft">@WokeWarrior69</div>
    </div>
    <div class="tweet-text" id="tweetTextLeft"></div>
    <div class="tweet-footer">
      <span>💬 47</span>
      <span>🔁 128</span>
      <span>❤️ 2.4K</span>
    </div>
  </div>
  <div class="tweet-card right" id="tweetRight">
    <div class="tweet-header">
      <img class="tweet-avatar" id="tweetAvatarRight" src="" alt="">
      <div class="tweet-handle" id="tweetHandleRight">@SafeSpaceSally</div>
    </div>
    <div class="tweet-text" id="tweetTextRight"></div>
    <div class="tweet-footer">
      <span>💬 89</span>
      <span>🔁 312</span>
      <span>❤️ 5.1K</span>
    </div>
  </div>
</div>

<!-- WIN BANNER OVERLAY (Tweet Style) -->
<div class="win-banner-overlay" id="winBannerOverlay" onclick="dismissWinBanner()">
  <div class="win-tweet-wrapper">
    <img class="win-banner-image" id="winBannerImg" src="" alt="">
    <div class="win-banner-fallback" id="winBannerFallback"></div>
    <div class="win-tweet-card">
      <div class="win-tweet-body">
        <div class="win-tweet-user">
          <img class="win-tweet-avatar" id="winTweetAvatar" src="" alt="">
          <div class="win-tweet-user-info">
            <div class="win-tweet-name" id="winTweetName">You</div>
            <div class="win-tweet-handle" id="winTweetHandle">@YOU</div>
          </div>
        </div>
        <div class="win-tweet-text" id="winTweetText"></div>
        <div class="win-tweet-stats">
          <span class="win-tweet-stat">💬 <span id="winStatComments">1.2K</span></span>
          <span class="win-tweet-stat">🔁 <span id="winStatRetweets">5.4K</span></span>
          <span class="win-tweet-stat">❤️ <span id="winStatLikes">12.8K</span></span>
        </div>
      </div>
      <div class="win-tweet-tap">Tap anywhere to dismiss</div>
    </div>
  </div>
</div>

<!-- FREE SPINS TOTAL WIN SCREEN -->
<div class="fs-total-overlay" id="fsTotalOverlay" onclick="dismissFsTotal()">
  <div class="fs-total-wrapper">
    <img class="fs-total-banner" id="fsTotalBanner" src="banners/meltdown.png" alt="MELTDOWN">
    <div class="fs-total-card">
      <div class="fs-total-body">
        <div class="fs-total-user">
          <img class="fs-total-avatar" id="fsTotalAvatar" src="" alt="">
          <div class="fs-total-user-info">
            <div class="fs-total-name" id="fsTotalName">Breaking News</div>
            <div class="fs-total-handle" id="fsTotalHandle">@MeltdownAlert</div>
          </div>
        </div>
        <div class="fs-total-text" id="fsTotalText"></div>
        <div class="fs-total-win-box">
          <div class="fs-total-win-label">TOTAL WIN</div>
          <div class="fs-total-win-amount" id="fsTotalAmount">$0.00</div>
        </div>
        <div class="fs-total-stats">
          <span class="fs-total-stat">💬 <span class="fs-total-stat-value" id="fsTotalComments">89.2K</span></span>
          <span class="fs-total-stat">🔁 <span class="fs-total-stat-value" id="fsTotalRetweets">245K</span></span>
          <span class="fs-total-stat">❤️ <span class="fs-total-stat-value" id="fsTotalLikes">1.2M</span></span>
        </div>
      </div>
      <div class="fs-total-tap">TAP TO CONTINUE</div>
    </div>
  </div>
</div>

<!-- FREE SPIN TRIGGER OVERLAY -->
<div class="fs-trigger-overlay" id="fsTriggerOverlay" onclick="dismissFsTrigger()">
  <!-- Background with radial pulse -->
  <div class="fs-bg"></div>

  <!-- Pulsing red vignette -->
  <div class="fs-vignette"></div>

  <!-- White flash -->
  <div class="fs-flash" id="fsFlash"></div>

  <!-- Ember particles container -->
  <div class="fs-embers" id="fsEmbers"></div>

  <!-- Main content -->
  <div class="fs-content">
    <div class="fs-news-bar">
      <!-- Scrolling ticker -->
      <div class="fs-ticker">
        <div class="fs-ticker-text" id="fsTickerText">
          BREAKING: FULL MELTDOWN DETECTED • ALL REELS COMPROMISED • SAFE SPACES BREACHED • THIS IS NOT A DRILL • BREAKING: FULL MELTDOWN DETECTED • ALL REELS COMPROMISED • SAFE SPACES BREACHED • THIS IS NOT A DRILL •
        </div>
      </div>

      <!-- Center content -->
      <div class="fs-center">
        <img class="fs-banner-img" id="fsBannerImg" src="banners/meltdown.png" alt="MELTDOWN">
        <div class="fs-spins-text" id="fsSpinsText">10 FREE SPINS</div>
        <div class="fs-multi-text">Global Multiplier Active 🔥</div>
      </div>
    </div>
  </div>

  <!-- Tap to dismiss -->
  <div class="fs-dismiss-text">TAP ANYWHERE TO CONTINUE</div>
</div>

<!-- BONUS BUY CONFIRM -->
<div class="confirm-overlay" id="buyConfirmOverlay">
  <div class="confirm-box">
    <h3>🔥 BUY MELTDOWN MODE</h3>
    <p>Skip straight to free spins?</p>
    <div class="cost" id="buyCost">$200.00</div>
    <br>
    <div class="confirm-btns">
      <button class="confirm-no" onclick="closeBuyConfirm()">Cancel</button>
      <button class="confirm-yes" onclick="buyBonus()">LET'S GO</button>
    </div>
  </div>
</div>

<!-- PAYTABLE -->
<div class="paytable-overlay" id="paytableOverlay">
  <div class="paytable">
    <div class="paytable-header">
      <h2>PAYTABLE</h2>
      <button class="paytable-close" onclick="closePaytable()">✕</button>
    </div>
    <div id="paytableContent"></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════
//  TRIGGERED — CLUSTER SLOT ENGINE
//  Version: RGS-v2 2026-02-05
// ═══════════════════════════════════════════

console.log('%c[TRIGGERED] Game script loaded - RGS Version v2', 'color: #ff3d5a; font-weight: bold; font-size: 16px');
console.log('%c[TRIGGERED] If you see this, clear your browser cache with Ctrl+Shift+R', 'color: orange');

// ── CONFIG ──
const COLS = 8, ROWS = 6;
const BETS = [0.20, 0.50, 1.00, 2.00, 5.00];
const MAX_WIN_MULTI = 5000;
const BONUS_BUY_MULTI = 200;

const SYMBOLS = {
  h1: { name: 'Oat Milk Latte', file: 'symbols/h1.png', color: '#E8D4B8', letter: 'H1', type: 'high' },
  h2: { name: 'Megaphone', file: 'symbols/h2.png', color: '#FF4444', letter: 'H2', type: 'high' },
  h3: { name: 'Avocado Toast', file: 'symbols/h3.png', color: '#7CB342', letter: 'H3', type: 'high' },
  h4: { name: 'Protest Sign', file: 'symbols/h4.png', color: '#FF8A65', letter: 'H4', type: 'high' },
  l1: { name: 'Pronoun Pin', file: 'symbols/l1.png', color: '#AB47BC', letter: 'L1', type: 'low' },
  l2: { name: 'Pink Hat', file: 'symbols/l2.png', color: '#F48FB1', letter: 'L2', type: 'low' },
  l3: { name: 'Participation Trophy', file: 'symbols/l3.png', color: '#FFD54F', letter: 'L3', type: 'low' },
  l4: { name: 'Pill Bottle', file: 'symbols/l4.png', color: '#FF7043', letter: 'L4', type: 'low' },
  wild: { name: 'Safe Space Wild', file: 'symbols/wild.png', color: '#FF1744', letter: 'W', type: 'wild' },
  scatter: { name: 'TRIGGERED Scatter', file: 'symbols/scatter.png', color: '#00E676', letter: 'S', type: 'scatter' },
};

// Symbol weights for random generation
const WEIGHTS = {
  h1: 8, h2: 10, h3: 12, h4: 14,
  l1: 18, l2: 20, l3: 22, l4: 24,
  wild: 3, scatter: 3
};

// Paytable: cluster_size → multiplier (of bet)
const PAYTABLE = {
  h1: { 5: 5.0, 8: 12.5, 12: 25.0, 20: 60.0 },
  h2: { 5: 4.0, 8: 10.0, 12: 20.0, 20: 50.0 },
  h3: { 5: 3.0, 8: 8.0,  12: 15.0, 20: 40.0 },
  h4: { 5: 2.0, 8: 6.0,  12: 10.0, 20: 30.0 },
  l1: { 5: 1.0, 8: 3.0,  12: 6.0,  20: 15.0 },
  l2: { 5: 0.8, 8: 2.5,  12: 5.0,  20: 12.0 },
  l3: { 5: 0.6, 8: 2.0,  12: 4.0,  20: 10.0 },
  l4: { 5: 0.5, 8: 1.5,  12: 3.0,  20: 8.0  },
};

const PAYING_IDS = ['h1','h2','h3','h4','l1','l2','l3','l4'];
const ALL_SPIN_IDS = Object.keys(SYMBOLS); // includes wild + scatter

// Free spin scatter thresholds
const FS_TRIGGERS = { 4: 10, 5: 15, 6: 20, 7: 20 };

// Win tier thresholds (in multiples of bet)
const WIN_TIERS = [
  { min: 100, label: 'DEPLATFORMED', color: '#FF1744', banner: 'banners/dep.png' },
  { min: 50,  label: 'CANCELLED', color: '#D50000', banner: 'banners/cancelled.png' },
  { min: 20,  label: 'TRIGGERED', color: '#FF3D5A', banner: 'banners/triggered.png' },
  { min: 10,  label: 'OFFENDED', color: '#FF6D00', banner: 'banners/offended.png' },
  { min: 5,   label: 'MICRO-AGGRESSION', color: '#FFD93D', banner: 'banners/micro.png' },
];

// ── STATE ──
let balance = 1000.00;
let betIndex = 2; // $1.00
let board = []; // board[col][row]
let gridMultipliers = []; // gridMultipliers[col][row]
let spinning = false;
let inFreeSpins = false;
let freeSpinsRemaining = 0;
let freeSpinsTotal = 0;
let globalMultiplier = 1;
let totalSpinWin = 0;
let totalFreeSpinWin = 0;
let imageCache = {};

// ── RGS API INTEGRATION ──
console.log('%c[RGS] Module loaded - API endpoint:', 'color: cyan; font-weight: bold', '/api/triggered');
const RGS_API_BASE = '/api/triggered';
let rgsSessionId = null;
let rgsConnected = false;

// Create RGS indicator immediately
(function createRgsIndicator() {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      const indicator = document.createElement('div');
      indicator.id = 'rgsIndicator';
      indicator.style.cssText = 'position:fixed;top:5px;left:5px;padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace;z-index:9999;pointer-events:none;background:rgba(100,100,100,0.8);color:#fff;';
      indicator.textContent = 'RGS: Connecting...';
      document.body.appendChild(indicator);
    });
  } else {
    const indicator = document.createElement('div');
    indicator.id = 'rgsIndicator';
    indicator.style.cssText = 'position:fixed;top:5px;left:5px;padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace;z-index:9999;pointer-events:none;background:rgba(100,100,100,0.8);color:#fff;';
    indicator.textContent = 'RGS: Connecting...';
    document.body.appendChild(indicator);
  }
})();

// Map API symbol names to frontend symbol IDs
const API_SYMBOL_MAP = {
  'H1': 'h1', 'H2': 'h2', 'H3': 'h3', 'H4': 'h4',
  'L1': 'l1', 'L2': 'l2', 'L3': 'l3', 'L4': 'l4',
  'W': 'wild', 'S': 'scatter'
};

// Initialize RGS session
async function initRgsSession() {
  console.log('%c[RGS] Attempting connection to:', 'color: cyan', RGS_API_BASE);
  try {
    const resp = await fetch(`${RGS_API_BASE}/init`, { method: 'POST' });
    console.log('%c[RGS] Init response status:', 'color: cyan', resp.status);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();
    console.log('%c[RGS] INIT SUCCESS:', 'color: lime; font-weight: bold', data);
    rgsSessionId = data.session_id;
    balance = data.balance;
    rgsConnected = true;
    updateRgsIndicator(true);
    updateUI();
    return true;
  } catch (err) {
    console.error('%c[RGS] CONNECTION FAILED:', 'color: red; font-weight: bold', err);
    rgsConnected = false;
    updateRgsIndicator(false);
    return false;
  }
}

// Update visual RGS status indicator
function updateRgsIndicator(connected) {
  let indicator = document.getElementById('rgsIndicator');
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.id = 'rgsIndicator';
    indicator.style.cssText = 'position:fixed;top:5px;left:5px;padding:4px 8px;border-radius:4px;font-size:11px;font-family:monospace;z-index:9999;pointer-events:none;';
    document.body.appendChild(indicator);
  }
  if (connected) {
    indicator.style.background = 'rgba(0,200,0,0.8)';
    indicator.style.color = '#fff';
    indicator.textContent = 'RGS: Connected';
  } else {
    indicator.style.background = 'rgba(200,0,0,0.8)';
    indicator.style.color = '#fff';
    indicator.textContent = 'RGS: Disconnected';
  }
}

// Call RGS spin endpoint
async function rgsSpinRequest(betAmount, betMode = 'base') {
  if (!rgsSessionId) {
    console.error('%c[RGS] No session ID - cannot spin', 'color: red');
    return null;
  }
  console.log('%c[RGS] SPIN REQUEST:', 'color: yellow', { session: rgsSessionId.substring(0,8), bet: betAmount, mode: betMode });
  try {
    const resp = await fetch(`${RGS_API_BASE}/spin`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        session_id: rgsSessionId,
        bet_amount: betAmount,
        bet_mode: betMode
      })
    });
    console.log('%c[RGS] Spin response status:', 'color: yellow', resp.status);
    if (!resp.ok) {
      const err = await resp.json();
      throw new Error(err.detail || `HTTP ${resp.status}`);
    }
    const data = await resp.json();
    console.log('%c[RGS] SPIN SUCCESS:', 'color: lime; font-weight: bold', { win: data.win, events: data.events?.length, balance: data.balance });
    return data;
  } catch (err) {
    console.error('%c[RGS] SPIN FAILED:', 'color: red; font-weight: bold', err);
    updateRgsIndicator(false);
    return null;
  }
}

// Add balance (for testing)
async function rgsAddBalance(amount) {
  if (!rgsSessionId) return;
  try {
    const resp = await fetch(`${RGS_API_BASE}/add-balance`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: rgsSessionId, amount: amount })
    });
    if (resp.ok) {
      const data = await resp.json();
      balance = data.balance;
      updateUI();
      console.log(`Added ${amount} credits, balance: ${balance}`);
    }
  } catch (err) {
    console.error('Add balance failed:', err);
  }
}

// Convert API screen (8 reels x 6 rows) to frontend board format
function apiScreenToBoard(screen) {
  const newBoard = [];
  const unmappedSymbols = new Set();

  for (let c = 0; c < COLS; c++) {
    newBoard[c] = [];
    for (let r = 0; r < ROWS; r++) {
      const apiSymbol = screen[c] && screen[c][r] ? screen[c][r] : 'L1';
      const frontendSymbol = API_SYMBOL_MAP[apiSymbol];

      if (!frontendSymbol) {
        unmappedSymbols.add(apiSymbol);
      }

      newBoard[c][r] = frontendSymbol || 'l1';
    }
  }

  if (unmappedSymbols.size > 0) {
    console.warn('%c[SYMBOL MAP] Unmapped symbols:', 'color: red', Array.from(unmappedSymbols));
  }

  // DEBUG: Log symbol mapping check
  console.log('%c[SYMBOL MAP] API -> Frontend mapping:', 'color: #888',
    'H1→h1, H2→h2, H3→h3, H4→h4, L1→l1, L2→l2, L3→l3, L4→l4, W→wild, S→scatter');

  return newBoard;
}

// Convert API multipliers grid to frontend format
function apiMultipliersToGrid(mults) {
  const grid = [];
  for (let c = 0; c < COLS; c++) {
    grid[c] = [];
    for (let r = 0; r < ROWS; r++) {
      grid[c][r] = mults[c] && mults[c][r] ? mults[c][r] : 0;
    }
  }
  return grid;
}

// Convert API win positions to cell set
function apiWinsToWinCells(wins) {
  const cells = new Set();
  for (const win of wins) {
    for (const pos of win.positions) {
      cells.add(`${pos.reel},${pos.row}`);
    }
  }
  return cells;
}

// Expose addBalance to console for testing
window.addCredits = function(amount = 1000) {
  rgsAddBalance(amount);
};

// ── LOADING SCREEN ──
let loadingStartTime = Date.now();
let loadedImages = 0;
let totalImages = 0;
let loadingTipInterval = null;

const LOADING_TIPS = [
  "Checking your privilege...",
  "Loading safe space...",
  "Activating emotional support mode...",
  "Calibrating outrage sensors...",
  "Warming up the cancel button...",
  "Polishing participation trophies...",
  "Brewing oat milk lattes...",
  "Sharpening protest signs...",
  "Counting pronouns...",
  "Manifesting big wins...",
  "Preparing your trigger warnings...",
  "Consulting with HR...",
  "Filing emotional damages...",
  "Loading virtue signals...",
  "Activating victim complex..."
];

const LOADING_STATUSES = [
  "Loading safe space...",
  "Checking your privilege...",
  "Initializing meltdown mode...",
  "Preparing emotional support...",
  "Calibrating sensitivity..."
];

function updateLoadingBar() {
  const bar = document.getElementById('loadingBar');
  const percent = totalImages > 0 ? (loadedImages / totalImages) * 100 : 0;
  bar.style.width = Math.min(percent, 100) + '%';
}

function cycleLoadingTip() {
  const tipEl = document.getElementById('loadingTip');
  const statusEl = document.getElementById('loadingStatus');

  // Pick random tip from TWEET_MESSAGES (if available) or LOADING_TIPS
  const tips = typeof TWEET_MESSAGES !== 'undefined' ? TWEET_MESSAGES : LOADING_TIPS;
  tipEl.textContent = tips[Math.floor(Math.random() * tips.length)];

  // Pick random status
  statusEl.textContent = LOADING_STATUSES[Math.floor(Math.random() * LOADING_STATUSES.length)];
}

function checkLoadingComplete() {
  const elapsed = Date.now() - loadingStartTime;
  const minTime = 2000; // Minimum 2 seconds

  if (loadedImages >= totalImages && elapsed >= minTime) {
    dismissLoadingScreen();
  } else if (loadedImages >= totalImages) {
    // All loaded but min time not reached, wait for it
    setTimeout(dismissLoadingScreen, minTime - elapsed);
  }
}

// Flag to track if all images are loaded - spin is blocked until true
let allImagesLoaded = false;

async function dismissLoadingScreen() {
  console.log('%c[GAME] dismissLoadingScreen called', 'color: orange; font-weight: bold');
  if (loadingTipInterval) {
    clearInterval(loadingTipInterval);
    loadingTipInterval = null;
  }

  // Initialize RGS connection
  console.log('%c[GAME] About to call initRgsSession...', 'color: orange');
  const rgsOk = await initRgsSession();
  if (!rgsOk) {
    console.warn('%c[GAME] RGS not available, using LOCAL FALLBACK mode', 'color: orange; font-weight: bold');
  } else {
    console.log('%c[GAME] RGS connected successfully!', 'color: lime; font-weight: bold');
  }

  // Mark images as loaded and enable spinning
  allImagesLoaded = true;

  // Force update all symbols now that images are cached
  updateAllSymbols();

  // Enable spin button
  document.getElementById('spinBtn').disabled = false;

  const screen = document.getElementById('loadingScreen');
  screen.classList.add('fade-out');

  setTimeout(() => {
    screen.classList.add('hidden');
    // Start idle animation once loading is complete
    startIdleAnimation();
  }, 500);
}

// ══════════════════════════════════════════════════════════════
// RESPONSIVE LAYOUT SYSTEM
// Positions game elements relative to actual rendered image bounds
// ══════════════════════════════════════════════════════════════

// Get actual rendered bounds of an image with object-fit: contain
function getImageBounds(imgElement, naturalW, naturalH, objectPosition = 'center') {
  const imgRatio = naturalW / naturalH;
  const containerW = imgElement.clientWidth;
  const containerH = imgElement.clientHeight;
  const containerRatio = containerW / containerH;

  let renderW, renderH, offsetX, offsetY;
  if (containerRatio > imgRatio) {
    // Letterboxed on sides (pillarboxing)
    renderH = containerH;
    renderW = containerH * imgRatio;
    offsetX = (containerW - renderW) / 2;
    offsetY = 0;
  } else {
    // Letterboxed on top/bottom
    renderW = containerW;
    renderH = containerW / imgRatio;
    offsetX = 0;
    // Adjust offsetY based on object-position
    if (objectPosition === 'top') {
      offsetY = 0; // Image pinned to top
    } else {
      offsetY = (containerH - renderH) / 2; // Image centered
    }
  }
  return { renderW, renderH, offsetX, offsetY };
}

// Position game container to match rendered image
function positionGameElements() {
  const isMobile = window.innerWidth < 768;
  const gameContainer = document.getElementById('gameContainer');
  const laptopScreen = document.getElementById('laptopScreen');
  const scanlines = document.getElementById('scanlines');

  if (isMobile) {
    // Mobile: use mobile background (object-position: top center)
    const mobileImg = document.getElementById('bgImgMobile');
    if (!mobileImg) return;

    const bounds = getImageBounds(mobileImg, 1024, 1536, 'top');

    // Position game container to match image
    gameContainer.style.position = 'absolute';
    gameContainer.style.left = bounds.offsetX + 'px';
    gameContainer.style.top = bounds.offsetY + 'px';
    gameContainer.style.width = bounds.renderW + 'px';
    gameContainer.style.height = bounds.renderH + 'px';

    // Mobile laptop screen position - percentages relative to mobile.png (1024x1536)
    // ADJUST THESE VALUES based on debug overlay feedback
    const laptopLeft = 8.3;    // % from left
    const laptopTop = 11.85;   // % from top
    const laptopWidth = 83.2;  // % width
    const laptopHeight = 41.85; // % height

    if (laptopScreen) {
      laptopScreen.style.position = 'absolute';
      laptopScreen.style.left = laptopLeft + '%';
      laptopScreen.style.top = laptopTop + '%';
      laptopScreen.style.width = laptopWidth + '%';
      laptopScreen.style.height = laptopHeight + '%';
      laptopScreen.style.padding = '0.3%';
      laptopScreen.style.gap = '0';
      laptopScreen.style.overflow = 'hidden';
      laptopScreen.style.display = 'flex';
      laptopScreen.style.flexDirection = 'column';
    }
    if (scanlines) {
      scanlines.style.left = laptopLeft + '%';
      scanlines.style.top = laptopTop + '%';
      scanlines.style.width = laptopWidth + '%';
      scanlines.style.height = laptopHeight + '%';
    }
  } else {
    // Desktop: use desktop background
    const desktopImg = document.getElementById('bgImg');
    if (!desktopImg) return;

    const bounds = getImageBounds(desktopImg, 1536, 1024);

    // Position game container to match image
    gameContainer.style.position = 'absolute';
    gameContainer.style.left = bounds.offsetX + 'px';
    gameContainer.style.top = bounds.offsetY + 'px';
    gameContainer.style.width = bounds.renderW + 'px';
    gameContainer.style.height = bounds.renderH + 'px';

    // Desktop laptop screen position (matches background.png)
    if (laptopScreen) {
      laptopScreen.style.position = 'absolute';
      laptopScreen.style.left = '22%';
      laptopScreen.style.top = '17%';
      laptopScreen.style.width = '56%';
      laptopScreen.style.height = '45%';
      laptopScreen.style.padding = '1%';
      laptopScreen.style.gap = '0.5%';
      laptopScreen.style.overflow = 'hidden';
    }
    if (scanlines) {
      scanlines.style.left = '22%';
      scanlines.style.top = '17%';
      scanlines.style.width = '56%';
      scanlines.style.height = '45%';
    }
  }
}

// Mobile layout: move dock to body, create popup tweets
function setupMobileLayout() {
  const isMobile = window.innerWidth < 768;
  const dock = document.querySelector('.dock');
  const body = document.body;
  const laptopScreen = document.getElementById('laptopScreen');

  if (isMobile) {
    // Move dock to body if not already there
    if (dock && dock.parentElement !== body) {
      body.appendChild(dock);
      dock.classList.add('mobile-dock');
    }
    // Create mobile tweet popup container if it doesn't exist
    if (!document.getElementById('mobileTweetPopup')) {
      const popup = document.createElement('div');
      popup.id = 'mobileTweetPopup';
      popup.className = 'mobile-tweet-popup';
      popup.innerHTML = `
        <div class="mobile-tweet-header">
          <img class="mobile-tweet-avatar" id="mobileTweetAvatar" src="" alt="">
          <div class="mobile-tweet-handle" id="mobileTweetHandle">@WokeWarrior</div>
        </div>
        <div class="mobile-tweet-text" id="mobileTweetText"></div>
      `;
      body.appendChild(popup);
    }
  } else {
    // Desktop: move dock back to laptop screen if needed
    if (dock && dock.classList.contains('mobile-dock') && laptopScreen) {
      laptopScreen.appendChild(dock);
      dock.classList.remove('mobile-dock');
    }
    // Hide mobile tweet popup on desktop
    const mobileTweetPopup = document.getElementById('mobileTweetPopup');
    if (mobileTweetPopup) {
      mobileTweetPopup.classList.remove('show');
    }
  }
}

// Combined layout update
function updateLayout() {
  positionGameElements();
  setupMobileLayout();
}

// Debounced resize handler
let resizeTimeout;
function handleResize() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(updateLayout, 100);
}

// ── INIT ──
function init() {
  // Disable spin button until images load
  document.getElementById('spinBtn').disabled = true;

  // Setup responsive layout system
  // Wait for background images to load before positioning
  const bgImg = document.getElementById('bgImg');
  const bgImgMobile = document.getElementById('bgImgMobile');

  function onBgLoad() {
    updateLayout();
  }

  if (bgImg) {
    if (bgImg.complete) onBgLoad();
    else bgImg.onload = onBgLoad;
  }
  if (bgImgMobile) {
    if (bgImgMobile.complete) onBgLoad();
    else bgImgMobile.onload = onBgLoad;
  }

  // Also update layout on resize
  window.addEventListener('resize', handleResize);

  // Initial layout update (in case images already loaded)
  setTimeout(updateLayout, 50);

  // Start loading tip cycle
  cycleLoadingTip();
  loadingTipInterval = setInterval(cycleLoadingTip, 1500);

  // Initialize game state
  initBoard();
  initMultipliers();

  // Initialize persistent grid cells ONCE
  initGridCells();

  // Initial render (will use fallbacks until images load)
  renderBoard();

  // Start preloading images (async)
  preloadImages();

  buildPaytable();
  updateUI();
}

// ══════════════════════════════════════════
// IMAGE PRELOADING SYSTEM - Store actual Image objects
// ══════════════════════════════════════════

// Caches store actual Image objects, not booleans
let bannerCache = {};   // file path -> Image object
let avatarCache = {};   // file path -> Image object
let poofCache = {};     // file path -> Image object
const AVATAR_COUNT = 20;

const POOF_FILES = [
  'effects/poof.png',
  'effects/poof2.png',
  'effects/poof3.png',
  'effects/poof4.png'
];

function getRandomAvatar() {
  const idx = Math.floor(Math.random() * AVATAR_COUNT) + 1;
  return `avatars/a${idx}.png`;
}

function preloadImages() {
  const symbolIds = Object.keys(SYMBOLS);
  const bannerFiles = [
    'banners/micro.png',
    'banners/offended.png',
    'banners/triggered.png',
    'banners/cancelled.png',
    'banners/dep.png',
    'banners/meltdown.png'
  ];

  const avatarFiles = [];
  for (let i = 1; i <= AVATAR_COUNT; i++) {
    avatarFiles.push(`avatars/a${i}.png`);
  }

  totalImages = symbolIds.length + bannerFiles.length + avatarFiles.length + POOF_FILES.length;
  loadedImages = 0;

  // Preload symbol images - store actual Image objects
  for (const id of symbolIds) {
    const sym = SYMBOLS[id];
    const img = new Image();
    img.onload = () => {
      imageCache[id] = img; // Store the actual Image object
      loadedImages++;
      updateLoadingBar();
      checkLoadingComplete();
    };
    img.onerror = () => {
      imageCache[id] = null;
      loadedImages++;
      updateLoadingBar();
      checkLoadingComplete();
    };
    img.src = sym.file;
  }

  // Preload banner images
  for (const file of bannerFiles) {
    const img = new Image();
    img.onload = () => {
      bannerCache[file] = img;
      loadedImages++;
      updateLoadingBar();
      checkLoadingComplete();
    };
    img.onerror = () => {
      bannerCache[file] = null;
      loadedImages++;
      updateLoadingBar();
      checkLoadingComplete();
    };
    img.src = file;
  }

  // Preload avatar images
  for (const file of avatarFiles) {
    const img = new Image();
    img.onload = () => {
      avatarCache[file] = img;
      loadedImages++;
      updateLoadingBar();
      checkLoadingComplete();
    };
    img.onerror = () => {
      avatarCache[file] = null;
      loadedImages++;
      updateLoadingBar();
      checkLoadingComplete();
    };
    img.src = file;
  }

  // Preload poof effect images
  for (const file of POOF_FILES) {
    const img = new Image();
    img.onload = () => {
      poofCache[file] = img;
      loadedImages++;
      updateLoadingBar();
      checkLoadingComplete();
    };
    img.onerror = () => {
      poofCache[file] = null;
      loadedImages++;
      updateLoadingBar();
      checkLoadingComplete();
    };
    img.src = file;
  }
}

// ══════════════════════════════════════════
// SOUND SYSTEM
// ══════════════════════════════════════════
let soundEnabled = false;
let audioContext = null;
const sounds = {};
const music = {};

// Sound file definitions
const SOUND_FILES = {
  // Game sounds
  spin: 'sounds/spin.wav',
  drop: 'sounds/drop.mp3',
  poof: 'sounds/poof.mp3',
  scatter: 'sounds/scatter.mp3',
  freespinTrigger: 'sounds/freespin-trigger.mp3',
  freespinEnd: 'sounds/freespin-end.mp3',
  cashregister: 'sounds/cashregister.wav',
  tweet: 'sounds/tweet.mp3',
  slam: 'sounds/slam.mp3',
  counting: 'sounds/counting.mp3',
  // Win sounds by cluster size
  winSmall: 'sounds/win-small.mp3',
  winMed: 'sounds/win-med.mp3',
  winBig: 'sounds/win-big.mp3',
  // Tier sounds
  tierMicro: 'sounds/tier-micro.mp3',
  tierTriggered: 'sounds/tier-triggered.mp3',
  tierCancelled: 'sounds/tier-cancelled.mp3',
  tierDep: 'sounds/tier-dep.mp3'
};

const MUSIC_FILES = {
  base: 'sounds/music-base.mp3',
  meltdown: 'sounds/music-meltdown.mp3',
  ambience: 'sounds/ambience.mp3'
};

// Sound volumes
const SOUND_VOLUMES = {
  spin: 0.25,
  drop: 0.2,
  poof: 0.175,
  scatter: 0.35,
  freespinTrigger: 0.4,
  freespinEnd: 0.3,
  cashregister: 0.3,
  tweet: 0.2,
  slam: 0.15,
  counting: 0.15,
  winSmall: 0.25,
  winMed: 0.3,
  winBig: 0.35,
  tierMicro: 0.15,
  tierTriggered: 0.15,
  tierCancelled: 0.15,
  tierDep: 0.15
};

const MUSIC_VOLUMES = {
  base: 0.3,
  meltdown: 0.5,
  ambience: 0.022
};

let currentMusic = null;
let countingSound = null;

function preloadAudio() {
  // Preload sound effects
  for (const [name, file] of Object.entries(SOUND_FILES)) {
    const audio = new Audio();
    audio.src = file;
    audio.preload = 'auto';
    audio.volume = SOUND_VOLUMES[name] || 0.5;
    sounds[name] = audio;
  }

  // Preload music
  for (const [name, file] of Object.entries(MUSIC_FILES)) {
    const audio = new Audio();
    audio.src = file;
    audio.preload = 'auto';
    audio.loop = true;
    audio.volume = 0;
    music[name] = audio;
  }
}

function playSound(name) {
  if (!soundEnabled || !sounds[name]) return;

  // Clone the audio for overlapping plays
  const sound = sounds[name].cloneNode();
  sound.volume = SOUND_VOLUMES[name] || 0.5;
  sound.play().catch(() => {});
  return sound;
}

function playSoundLoop(name) {
  if (!soundEnabled || !sounds[name]) return null;

  const sound = sounds[name].cloneNode();
  sound.volume = SOUND_VOLUMES[name] || 0.5;
  sound.loop = true;
  sound.play().catch(() => {});
  return sound;
}

function stopSound(sound) {
  if (sound) {
    sound.pause();
    sound.currentTime = 0;
  }
}

function playWinSound(clusterSize) {
  // Win sounds removed - no cluster size sounds play
}

function playTierSound(tierLabel) {
  const tierSoundMap = {
    'MICRO-AGGRESSION': 'tierMicro',
    'OFFENDED': 'tierMicro', // Reuse micro for offended
    'TRIGGERED': 'tierTriggered',
    'CANCELLED': 'tierCancelled',
    'DEPLATFORMED': 'tierDep'
  };
  const soundName = tierSoundMap[tierLabel];
  if (soundName) playSound(soundName);
}

function startMusic(name, fadeIn = true) {
  if (!soundEnabled || !music[name]) return;

  const targetVolume = MUSIC_VOLUMES[name] || 0.3;

  if (fadeIn) {
    music[name].volume = 0;
    music[name].play().catch(() => {});

    // Fade in over 1 second
    let vol = 0;
    const fadeInterval = setInterval(() => {
      vol += targetVolume / 20;
      if (vol >= targetVolume) {
        music[name].volume = targetVolume;
        clearInterval(fadeInterval);
      } else {
        music[name].volume = vol;
      }
    }, 50);
  } else {
    music[name].volume = targetVolume;
    music[name].play().catch(() => {});
  }
}

function stopMusic(name, fadeOut = true) {
  if (!music[name]) return;

  if (fadeOut) {
    const startVol = music[name].volume;
    let vol = startVol;
    const fadeInterval = setInterval(() => {
      vol -= startVol / 20;
      if (vol <= 0) {
        music[name].volume = 0;
        music[name].pause();
        music[name].currentTime = 0;
        clearInterval(fadeInterval);
      } else {
        music[name].volume = vol;
      }
    }, 50);
  } else {
    music[name].pause();
    music[name].currentTime = 0;
  }
}

function crossfadeMusic(fromName, toName, duration = 500) {
  if (!soundEnabled) return;

  currentMusic = toName;

  // Fade out current track over duration
  if (fromName && music[fromName]) {
    const fromAudio = music[fromName];
    const startVol = fromAudio.volume;
    const steps = 20;
    const stepTime = duration / steps;
    let step = 0;

    const fadeOut = setInterval(() => {
      step++;
      fromAudio.volume = Math.max(0, startVol * (1 - step / steps));
      if (step >= steps) {
        clearInterval(fadeOut);
        fromAudio.pause();
        fromAudio.currentTime = 0;
        fromAudio.volume = 0;
      }
    }, stepTime);
  }

  // Fade in new track over duration (start immediately, concurrent with fade out)
  if (toName && music[toName]) {
    const toAudio = music[toName];
    const targetVol = MUSIC_VOLUMES[toName] || 0.3;
    toAudio.volume = 0;
    toAudio.play().catch(() => {});

    const steps = 20;
    const stepTime = duration / steps;
    let step = 0;

    const fadeIn = setInterval(() => {
      step++;
      toAudio.volume = Math.min(targetVol, targetVol * (step / steps));
      if (step >= steps) {
        clearInterval(fadeIn);
        toAudio.volume = targetVol;
      }
    }, stepTime);
  }
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  const btn = document.getElementById('soundToggle');

  if (soundEnabled) {
    btn.textContent = '🔊';
    btn.classList.add('active');

    // Start base music and ambience
    currentMusic = 'base';
    startMusic('base', true);
    startMusic('ambience', true);
  } else {
    btn.textContent = '🔇';
    btn.classList.remove('active');

    // Stop all audio
    for (const audio of Object.values(music)) {
      audio.pause();
      audio.currentTime = 0;
      audio.volume = 0;
    }

    // Stop any playing counting sound
    if (countingSound) {
      stopSound(countingSound);
      countingSound = null;
    }
  }
}

function startCountingSound() {
  if (countingSound) stopSound(countingSound);
  countingSound = playSoundLoop('counting');
}

function stopCountingSound() {
  if (countingSound) {
    stopSound(countingSound);
    countingSound = null;
  }
}

// ── WIN COUNTER ANIMATION ──
let currentDisplayedWin = 0;
let winCounterInterval = null;

function animateWinCounter(targetAmount, duration = 1000) {
  return new Promise((resolve) => {
    const startAmount = currentDisplayedWin;
    const diff = targetAmount - startAmount;

    if (diff <= 0) {
      currentDisplayedWin = targetAmount;
      document.getElementById('winDisplay').textContent = `$${targetAmount.toFixed(2)}`;
      resolve();
      return;
    }

    const startTime = performance.now();
    // Adjust duration based on win size - small wins count faster
    const adjustedDuration = Math.min(duration, Math.max(300, diff * 10));

    if (winCounterInterval) cancelAnimationFrame(winCounterInterval);

    function tick() {
      const elapsed = performance.now() - startTime;
      const progress = Math.min(elapsed / adjustedDuration, 1);

      // Ease out for smoother finish
      const easedProgress = 1 - Math.pow(1 - progress, 3);
      const currentValue = startAmount + (diff * easedProgress);

      currentDisplayedWin = currentValue;
      document.getElementById('winDisplay').textContent = `$${currentValue.toFixed(2)}`;

      if (progress < 1) {
        winCounterInterval = requestAnimationFrame(tick);
      } else {
        currentDisplayedWin = targetAmount;
        document.getElementById('winDisplay').textContent = `$${targetAmount.toFixed(2)}`;
        resolve();
      }
    }

    winCounterInterval = requestAnimationFrame(tick);
  });
}

function resetWinCounter() {
  currentDisplayedWin = 0;
  document.getElementById('winDisplay').textContent = '$0.00';
}

// Initialize audio preload
preloadAudio();

function initBoard() {
  board = [];
  for (let c = 0; c < COLS; c++) {
    board[c] = [];
    for (let r = 0; r < ROWS; r++) {
      board[c][r] = randomSymbol();
    }
  }
}

function initMultipliers() {
  gridMultipliers = [];
  for (let c = 0; c < COLS; c++) {
    gridMultipliers[c] = [];
    for (let r = 0; r < ROWS; r++) {
      gridMultipliers[c][r] = 0; // 0 = inactive
    }
  }
}

// ── RANDOM SYMBOL ──
function randomSymbol() {
  const total = Object.values(WEIGHTS).reduce((a, b) => a + b, 0);
  let r = Math.random() * total;
  for (const [id, w] of Object.entries(WEIGHTS)) {
    r -= w;
    if (r <= 0) return id;
  }
  return 'l4';
}

// ══════════════════════════════════════════
// HIGH-PERFORMANCE RENDERING SYSTEM
// ══════════════════════════════════════════

// Persistent cell references - created once, never destroyed
let cellElements = [];  // 2D array [col][row] of cell DOM elements
let cellData = [];      // 2D array [col][row] of { content, img, fallback, badge }
let gridInitialized = false;

// Track what symbol is ACTUALLY displayed in each cell (completely separate from board state)
let displayedSymbols = [];  // 2D array [col][row] of symbol ID strings

// Track active poof animations for cleanup
let activePoofAnimations = [];

// Initialize grid cells ONCE on startup
function initGridCells() {
  const grid = document.getElementById('grid');
  grid.innerHTML = '';

  cellElements = [];
  cellData = [];
  displayedSymbols = [];

  for (let c = 0; c < COLS; c++) {
    cellElements[c] = [];
    cellData[c] = [];
    displayedSymbols[c] = [];
    for (let r = 0; r < ROWS; r++) {
      displayedSymbols[c][r] = null;
    }
  }

  // Create all 48 cells in row-major order for CSS grid
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';

      // Cell content container
      const content = document.createElement('div');
      content.className = 'cell-content';

      // Symbol div with background-image (prevents flickering vs img.src)
      const symbolDiv = document.createElement('div');
      symbolDiv.className = 'symbol-img';
      content.appendChild(symbolDiv);

      // Fallback element (hidden by default)
      const fallback = document.createElement('div');
      fallback.className = 'fallback';
      fallback.style.display = 'none';
      content.appendChild(fallback);

      cell.appendChild(content);

      // Multiplier badge (hidden by default)
      const badge = document.createElement('div');
      badge.className = 'multi-badge';
      badge.style.display = 'none';
      cell.appendChild(badge);

      // Debug label for symbol ID (toggle with showDebugSymbols)
      const debugLabel = document.createElement('div');
      debugLabel.className = 'debug-symbol-label';
      debugLabel.style.cssText = 'position:absolute;top:2px;left:2px;font-size:8px;color:#fff;background:rgba(0,0,0,0.7);padding:1px 3px;border-radius:2px;display:none;z-index:5;font-family:monospace;';
      cell.appendChild(debugLabel);

      // Store references
      cellElements[c][r] = cell;
      cellData[c][r] = { content, symbolDiv, fallback, badge, debugLabel };

      grid.appendChild(cell);
    }
  }

  gridInitialized = true;
}

// Debug mode - toggle with window.showDebugSymbols = true in console
let showDebugSymbols = false;
window.toggleDebugSymbols = function() {
  showDebugSymbols = !showDebugSymbols;
  console.log('Debug symbols:', showDebugSymbols ? 'ON' : 'OFF');
  renderBoard();
};

// ── DEBUG MODE FOR WIN VERIFICATION ──
// Enabled via ?debug=true URL param or toggle button
let debugMode = new URLSearchParams(window.location.search).get('debug') === 'true';
let debugPaused = false;
let debugResolve = null; // Promise resolver for NEXT button

// Create debug panel
function createDebugPanel() {
  const panel = document.createElement('div');
  panel.id = 'debugPanel';
  panel.style.cssText = `
    position: fixed;
    top: 50px;
    right: 10px;
    background: rgba(0,0,0,0.9);
    border: 2px solid #0ff;
    border-radius: 8px;
    padding: 10px;
    z-index: 10000;
    font-family: monospace;
    font-size: 12px;
    color: #0ff;
    display: ${debugMode ? 'block' : 'none'};
    min-width: 200px;
  `;
  panel.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <span style="font-weight:bold;color:#ff0;">🔧 DEBUG MODE</span>
      <button id="debugToggleBtn" style="background:#333;color:#fff;border:1px solid #666;padding:2px 8px;cursor:pointer;border-radius:4px;">
        ${debugMode ? 'ON' : 'OFF'}
      </button>
    </div>
    <div style="border-top:1px solid #333;padding-top:8px;">
      <div style="margin-bottom:5px;color:#888;">Step through tumbles:</div>
      <button id="debugNextBtn" style="
        background: #0a0;
        color: #fff;
        border: none;
        padding: 8px 20px;
        cursor: pointer;
        border-radius: 4px;
        font-weight: bold;
        font-size: 14px;
        width: 100%;
        display: none;
      ">▶ NEXT</button>
      <div id="debugStatus" style="margin-top:8px;color:#888;font-size:11px;">Waiting...</div>
    </div>
    <div style="border-top:1px solid #333;margin-top:8px;padding-top:8px;">
      <label style="display:flex;align-items:center;gap:5px;cursor:pointer;">
        <input type="checkbox" id="debugShowSymbols" ${showDebugSymbols ? 'checked' : ''}>
        <span>Show symbol IDs</span>
      </label>
      <label style="display:flex;align-items:center;gap:5px;cursor:pointer;margin-top:5px;">
        <input type="checkbox" id="debugShowMults" checked>
        <span>Show all multipliers</span>
      </label>
    </div>
  `;
  document.body.appendChild(panel);

  // Toggle debug mode
  document.getElementById('debugToggleBtn').addEventListener('click', () => {
    debugMode = !debugMode;
    document.getElementById('debugToggleBtn').textContent = debugMode ? 'ON' : 'OFF';
    document.getElementById('debugToggleBtn').style.background = debugMode ? '#0a0' : '#333';
    updateDebugHighlights();
    console.log('%c[DEBUG MODE]:', 'color: cyan; font-weight: bold', debugMode ? 'ENABLED' : 'DISABLED');
  });

  // NEXT button
  document.getElementById('debugNextBtn').addEventListener('click', () => {
    if (debugResolve) {
      debugResolve();
      debugResolve = null;
      document.getElementById('debugNextBtn').style.display = 'none';
      document.getElementById('debugStatus').textContent = 'Continuing...';
    }
  });

  // Show symbols toggle
  document.getElementById('debugShowSymbols').addEventListener('change', (e) => {
    showDebugSymbols = e.target.checked;
    renderBoard();
  });

  // Show multipliers toggle
  document.getElementById('debugShowMults').addEventListener('change', updateDebugHighlights);
}

// Wait for NEXT button click in debug mode
function debugWaitForNext(status = 'Paused') {
  if (!debugMode) return Promise.resolve();

  document.getElementById('debugNextBtn').style.display = 'block';
  document.getElementById('debugStatus').textContent = status + ' - Click NEXT to continue';

  return new Promise(resolve => {
    debugResolve = resolve;
  });
}

// Update debug status
function debugSetStatus(status) {
  const el = document.getElementById('debugStatus');
  if (el) el.textContent = status;
}

// Apply debug highlights to grid
function updateDebugHighlights() {
  if (!gridInitialized) return;
  const showMults = document.getElementById('debugShowMults')?.checked;

  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      const cell = cellElements[c][r];
      const data = cellData[c][r];
      const mult = gridMultipliers[c]?.[r] || 0;

      // In debug mode, show multipliers even in base game
      if (debugMode && showMults && mult > 0) {
        data.badge.textContent = `×${mult}`;
        data.badge.style.display = '';
      }
    }
  }
}

// Log detailed cluster info for verification
function logClusterDetails(wins, label = 'WIN CLUSTER') {
  if (!debugMode) return;

  console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #0ff');
  console.log(`%c[${label}] ${wins.length} cluster(s):`, 'color: #0ff; font-weight: bold');

  for (const win of wins) {
    const expectedSymbol = win.symbol.toUpperCase();
    console.log(
      `%c  Symbol: ${win.symbol}, Count: ${win.count}, Pay: $${win.pay.toFixed(2)}, Mult: ${win.multiplier}x`,
      'color: #ff0'
    );

    // Check each position - verify the symbol in board matches expected
    console.log('%c  Position verification:', 'color: #0f0');
    let mismatches = 0;
    for (const p of win.positions) {
      const actualSymbol = board[p.reel]?.[p.row]?.toUpperCase() || '???';
      const match = actualSymbol === expectedSymbol.toLowerCase() ||
                    actualSymbol === expectedSymbol ||
                    (expectedSymbol === 'W' && actualSymbol === 'WILD') ||
                    (expectedSymbol === 'S' && actualSymbol === 'SCATTER');
      const icon = match ? '✓' : '✗';
      const color = match ? 'color: #0f0' : 'color: #f00; font-weight: bold';
      console.log(`%c    [${p.reel},${p.row}] Expected: ${expectedSymbol}, Actual: ${actualSymbol} ${icon}`, color);
      if (!match) mismatches++;
    }

    if (mismatches > 0) {
      console.log(`%c  ⚠️ ${mismatches} POSITION MISMATCHES! Wrong cells will be highlighted!`, 'color: #f00; font-weight: bold');
    }

    // Visual grid representation showing actual board
    console.log('%c  Current board state (Expected positions marked with *):', 'color: #888');
    for (let r = 0; r < ROWS; r++) {
      let rowStr = '    ';
      for (let c = 0; c < COLS; c++) {
        const sym = board[c]?.[r]?.toUpperCase()?.substring(0, 2) || '??';
        const isWinPos = win.positions.some(p => p.reel === c && p.row === r);
        rowStr += isWinPos ? `[${sym}]` : ` ${sym} `;
      }
      console.log(`%c${rowStr}`, 'color: #888; font-family: monospace');
    }
  }
  console.log('%c━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'color: #0ff');
}

// Initialize debug panel on load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', createDebugPanel);
} else {
  createDebugPanel();
}

// Update a single cell's symbol image - ONLY if it actually changed
function syncCellSymbol(c, r) {
  // Normalize to string or null for consistent comparison
  const symId = board[c][r] ? String(board[c][r]) : null;
  const displayed = displayedSymbols[c][r];

  // STRICT CHECK: only update if symbol actually changed
  if (displayed === symId) {
    return; // No change - don't touch DOM
  }

  const data = cellData[c][r];
  const sym = symId ? SYMBOLS[symId] : null;

  if (symId && sym) {
    // Use background-image (prevents flickering vs img.src)
    data.symbolDiv.style.backgroundImage = `url('${sym.file}')`;
    data.symbolDiv.style.display = '';
    data.fallback.style.display = 'none';
    data.content.style.display = '';
  } else {
    // Empty cell
    data.symbolDiv.style.backgroundImage = '';
    data.content.style.display = 'none';
  }

  // Update tracking AFTER successful DOM update
  displayedSymbols[c][r] = symId;
}

// All possible state classes that renderBoard manages
const STATE_CLASSES = ['spin-out', 'spin-in', 'winning', 'removing', 'dropping', 'multi-1', 'multi-2', 'multi-4', 'multi-8', 'multi-16', 'multi-32', 'multi-64', 'multi-flash'];

// NUCLEAR CLEANUP - Force remove ALL win/gold styles from every cell
// Call at start of spin, after overlays, after every tumble cycle
function cleanAllWinStates() {
  if (!gridInitialized) return;
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      const cell = cellElements[c][r];
      const data = cellData[c][r];

      // Remove all win-related classes
      cell.classList.remove('winning', 'removing', 'dropping', 'multi-flash');

      // NUCLEAR: Force clear any inline gold/winning styles
      cell.style.border = '';
      cell.style.boxShadow = '';
      cell.style.outline = '';
      cell.style.background = '';

      // Remove scatter glow from symbol div
      if (data && data.symbolDiv) {
        data.symbolDiv.classList.remove('scatter-symbol');
      }

      // Remove sparkles
      const sparkles = cell.querySelectorAll('.sparkle');
      sparkles.forEach(s => s.remove());

      // Remove poof
      const poof = cell.querySelector('.poof-img');
      if (poof) poof.remove();
    }
  }
}

// Main render function - handles animations and state classes
// Does NOT touch symbol images unless board data changed
function renderBoard(winCells = new Set(), removingCells = new Set(), droppingCells = new Map(), spinAnim = null, flashCells = new Set()) {
  if (!gridInitialized) {
    initGridCells();
  }

  // NUCLEAR SAFETY CHECK: If more than 20 cells are marked as winning, something is wrong
  // A real cluster can't be more than half the board - skip highlighting entirely
  if (winCells.size > 20) {
    console.warn('SAFETY: Too many win cells (' + winCells.size + '), skipping win highlights');
    winCells = new Set();
  }

  // Clear pending poof animations
  for (const anim of activePoofAnimations) {
    if (anim.interval) clearInterval(anim.interval);
    if (anim.timeout) clearTimeout(anim.timeout);
  }
  activePoofAnimations = [];

  // Pre-compute arrays for stagger indexing
  const winCellsArray = winCells.size > 0 ? Array.from(winCells) : [];
  const removingCellsArray = removingCells.size > 0 ? Array.from(removingCells) : [];

  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      const cell = cellElements[c][r];
      const data = cellData[c][r];
      const key = `${c},${r}`;

      // Remove old sparkles and poof (only if they exist)
      const oldSparkles = cell.querySelectorAll('.sparkle');
      if (oldSparkles.length > 0) oldSparkles.forEach(s => s.remove());
      const oldPoof = cell.querySelector('.poof-img');
      if (oldPoof) oldPoof.remove();

      // Sync symbol display (only updates DOM if board changed)
      syncCellSymbol(c, r);

      // Remove all state classes first (more efficient than checking each one)
      cell.classList.remove(...STATE_CLASSES);

      // NUCLEAR: Clear any leftover inline win styles on each render pass
      cell.style.border = '';
      cell.style.boxShadow = '';
      cell.style.outline = '';

      // Remove scatter glow class (will re-add if needed after spin completes)
      data.symbolDiv.classList.remove('scatter-symbol');

      // Apply scatter glow effect ONLY after symbols have dropped into position
      // Don't apply during spin animations
      const symId = board[c][r];
      if (symId === 'scatter' && !spinAnim && !droppingCells.has(key)) {
        data.symbolDiv.classList.add('scatter-symbol');
      }

      // Apply spin animation classes
      if (spinAnim === 'out') {
        cell.classList.add('spin-out');
      } else if (spinAnim === 'in') {
        cell.classList.add('spin-in');
        cell.style.setProperty('--row-delay', (r * 50) + 'ms');
      }

      // Apply win animation
      if (winCells.has(key) && !spinAnim) {
        cell.classList.add('winning');
        const idx = winCellsArray.indexOf(key);
        const delay = idx * 50;
        cell.style.setProperty('--win-delay', delay + 'ms');

        // Add sparkles
        for (let i = 1; i <= 4; i++) {
          const sparkle = document.createElement('div');
          sparkle.className = `sparkle s${i}`;
          sparkle.style.animationDelay = (delay + (i * 50)) + 'ms';
          cell.appendChild(sparkle);
        }
      }

      // Apply removal animation with poof
      if (removingCells.has(key) && !spinAnim) {
        cell.classList.add('removing');
        const removeIdx = removingCellsArray.indexOf(key);
        const removeDelay = removeIdx * 30; // 30ms stagger across cluster cells
        cell.style.setProperty('--remove-delay', removeDelay + 'ms');

        // Poof size progression: tiny pop → expanding → big burst → dissipates
        const POOF_SIZES = ['30%', '60%', '90%', '120%'];

        // Create poof overlay div - starts small, grows with each frame
        const poofDiv = document.createElement('div');
        poofDiv.className = 'poof-img';
        poofDiv.style.backgroundImage = `url('${POOF_FILES[0]}')`;
        poofDiv.style.width = POOF_SIZES[0];
        poofDiv.style.height = POOF_SIZES[0];
        cell.appendChild(poofDiv);

        // Animate poof frames: 80ms per frame, 4 frames = 320ms total
        // Each frame swaps image AND grows the div size
        const animState = { timeout: null, interval: null };
        animState.timeout = setTimeout(() => {
          let frame = 0;
          animState.interval = setInterval(() => {
            frame++;
            if (frame < POOF_FILES.length) {
              poofDiv.style.backgroundImage = `url('${POOF_FILES[frame]}')`;
              poofDiv.style.width = POOF_SIZES[frame];
              poofDiv.style.height = POOF_SIZES[frame];
            } else {
              clearInterval(animState.interval);
              // Remove the overlay div after animation completes
              if (poofDiv.parentNode) {
                poofDiv.parentNode.removeChild(poofDiv);
              }
            }
          }, 80);
        }, removeDelay);
        activePoofAnimations.push(animState);
      }

      // Apply dropping animation
      if (droppingCells.has(key)) {
        cell.classList.add('dropping');
        cell.style.setProperty('--drop-dist', droppingCells.get(key));
      }

      // Handle multiplier badge (free spins only)
      if (inFreeSpins && gridMultipliers[c][r] > 0) {
        const multi = gridMultipliers[c][r];
        data.badge.textContent = `×${multi}`;
        data.badge.style.display = '';

        // Add appropriate multiplier class
        if (multi >= 64) cell.classList.add('multi-64');
        else if (multi >= 32) cell.classList.add('multi-32');
        else if (multi >= 16) cell.classList.add('multi-16');
        else if (multi >= 8) cell.classList.add('multi-8');
        else if (multi >= 4) cell.classList.add('multi-4');
        else if (multi >= 2) cell.classList.add('multi-2');
        else cell.classList.add('multi-1');

        if (flashCells.has(key)) {
          cell.classList.add('multi-flash');
        }
      } else {
        data.badge.style.display = 'none';
      }

      // Debug label - show symbol ID
      if (showDebugSymbols && data.debugLabel) {
        const symId = board[c][r] || '?';
        const mult = gridMultipliers[c]?.[r] || 0;
        data.debugLabel.textContent = symId.toUpperCase() + (mult > 0 ? ` ×${mult}` : '');
        data.debugLabel.style.display = '';
      } else if (data.debugLabel) {
        data.debugLabel.style.display = 'none';
      }
    }
  }
}

// Force sync all symbols from board to display (use after loading images)
function updateAllSymbols() {
  if (!gridInitialized) return;
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      displayedSymbols[c][r] = null; // Force update
      syncCellSymbol(c, r);
    }
  }
}

// Mark all cells as needing symbol update (call before renderBoard after board changes)
function invalidateAllSymbols() {
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      displayedSymbols[c][r] = null;
    }
  }
}

function updateUI() {
  document.getElementById('balanceDisplay').textContent = `$${balance.toFixed(2)}`;
  document.getElementById('betDisplay').textContent = `$${BETS[betIndex].toFixed(2)}`;
  document.getElementById('buyCost').textContent = `$${(BETS[betIndex] * BONUS_BUY_MULTI).toFixed(2)}`;
}

// ── BET CONTROLS ──
function changeBet(dir) {
  if (spinning) return;
  betIndex = Math.max(0, Math.min(BETS.length - 1, betIndex + dir));
  updateUI();
}

// ── CLUSTER DETECTION ──
function findClusters() {
  const visited = new Set();
  const clusters = [];

  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      const key = `${c},${r}`;
      if (visited.has(key)) continue;
      const symId = board[c][r];
      if (!symId || symId === 'scatter') continue;

      const cluster = [];
      const queue = [[c, r]];
      const seen = new Set([key]);

      while (queue.length > 0) {
        const [cc, cr] = queue.shift();
        cluster.push([cc, cr]);

        for (const [nc, nr] of [[cc-1,cr],[cc+1,cr],[cc,cr-1],[cc,cr+1]]) {
          if (nc < 0 || nc >= COLS || nr < 0 || nr >= ROWS) continue;
          const nk = `${nc},${nr}`;
          if (seen.has(nk)) continue;
          const nSym = board[nc][nr];
          if (!nSym) continue;

          const match =
            nSym === symId ||
            (symId === 'wild' && PAYING_IDS.includes(nSym)) ||
            (nSym === 'wild' && PAYING_IDS.includes(symId)) ||
            (symId === 'wild' && nSym === 'wild');

          if (match) {
            seen.add(nk);
            queue.push([nc, nr]);
          }
        }
      }

      for (const [cc, cr] of cluster) visited.add(`${cc},${cr}`);

      if (cluster.length >= 5) {
        let payId = symId === 'wild' ? null : symId;
        if (!payId) {
          for (const [cc, cr] of cluster) {
            if (board[cc][cr] !== 'wild') { payId = board[cc][cr]; break; }
          }
        }
        if (!payId) payId = 'h1'; // all-wild = highest pay
        clusters.push({ cells: cluster, symbol: payId, size: cluster.length });
      }
    }
  }

  return clusters;
}

// ── PAYOUT CALC ──
function calcPayout(symbol, clusterSize) {
  const table = PAYTABLE[symbol];
  if (!table) return 0;
  const thresholds = Object.keys(table).map(Number).sort((a, b) => b - a);
  for (const t of thresholds) {
    if (clusterSize >= t) return table[t];
  }
  return 0;
}

// ── COUNT SCATTERS ──
function countScatters() {
  let count = 0;
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      if (board[c][r] === 'scatter') count++;
    }
  }
  return count;
}

// ── TUMBLE: REMOVE AND DROP ──
function removeAndDrop(winCells) {
  for (const key of winCells) {
    const [c, r] = key.split(',').map(Number);
    board[c][r] = null;
  }

  const dropping = new Map();

  for (let c = 0; c < COLS; c++) {
    const remaining = [];
    for (let r = ROWS - 1; r >= 0; r--) {
      if (board[c][r] !== null) remaining.push(board[c][r]);
    }

    const empties = ROWS - remaining.length;

    for (let r = ROWS - 1; r >= 0; r--) {
      const idx = (ROWS - 1) - r;
      if (idx < remaining.length) {
        board[c][r] = remaining[idx];
      } else {
        board[c][r] = randomSymbol();
      }
    }

    // Calculate drop distances
    for (let r = 0; r < ROWS; r++) {
      const key = `${c},${r}`;
      if (r < empties) {
        dropping.set(key, empties - r);
      } else {
        let dropped = 0;
        for (const wk of winCells) {
          const [wc, wr] = wk.split(',').map(Number);
          if (wc === c && wr > r) dropped++;
        }
        if (dropped > 0) dropping.set(key, dropped);
      }
    }
  }

  return dropping;
}

// ── MAIN SPIN ──
async function spin() {
  if (spinning) return;
  if (!allImagesLoaded) return;
  const bet = BETS[betIndex];
  if (balance < bet) return;

  spinning = true;
  stopIdleAnimation();
  cleanAllWinStates();
  document.getElementById('spinBtn').disabled = true;
  document.getElementById('buyBtn').classList.add('disabled');
  totalSpinWin = 0;

  const t = getTurboMultiplier();

  // CRITICAL: Reset ALL multipliers at start of every spin
  globalMultiplier = 1;
  initMultipliers();
  console.log('%c[SPIN START] Multipliers RESET - global:', 'color: #ff0', globalMultiplier);

  // Deduct bet locally for UI (RGS handles actual balance)
  balance -= bet;
  updateUI();
  showWinText('');
  resetWinCounter();

  // ALWAYS use base mode - bonus mode is only for bonus buy (200x cost)
  // Free spins are contained within the events of a base spin
  console.log('%c[SPIN] Calling RGS API with base mode...', 'color: yellow');
  const spinResult = await rgsSpinRequest(bet, 'base');

  if (!spinResult || !spinResult.events || spinResult.events.length === 0) {
    console.warn('%c[SPIN] RGS FAILED - USING LOCAL FALLBACK!', 'color: red; font-weight: bold; font-size: 14px');
    await spinLocalFallback(bet, t);
    return;
  }

  // DEBUG: Log full API response
  console.log('%c[SPIN] RGS Response:', 'color: lime; font-weight: bold', {
    win: spinResult.win,
    balance: spinResult.balance,
    free_spins_total: spinResult.free_spins_total,
    events_count: spinResult.events.length
  });

  playSound('spin');
  renderBoard(new Set(), new Set(), new Map(), 'out');
  await sleep(150 * t);

  // Process ALL events from RGS (including free spins!)
  // The API returns the ENTIRE sequence - no need for recursive spin()
  let currentFreeSpinNum = 0;
  let totalFreeSpinsInSequence = 0;

  for (let eventIndex = 0; eventIndex < spinResult.events.length; eventIndex++) {
    const event = spinResult.events[eventIndex];
    const eventType = event.type;

    // DEBUG: Log each event
    console.log(`%c[EVENT ${eventIndex}] ${eventType}`, 'color: cyan', {
      screen: event.screen ? `${event.screen.length}x${event.screen[0]?.length}` : 'none',
      wins: event.wins?.length || 0,
      winsDetail: event.wins?.map(w => `${w.symbol}x${w.count}`) || []
    });

    if (eventType === 'spin' || eventType === 'freespin') {
      // Board reveal - DEBUG log the screen
      console.log('%c[SCREEN GRID]:', 'color: orange', JSON.stringify(event.screen));

      // Track free spin progress
      if (eventType === 'freespin') {
        currentFreeSpinNum++;
        globalMultiplier = currentFreeSpinNum; // Multiplier = spin number in free spins
        freeSpinsRemaining = totalFreeSpinsInSequence - currentFreeSpinNum;
        console.log('%c[FREE SPIN]:', 'color: magenta', {
          spinNum: currentFreeSpinNum,
          remaining: freeSpinsRemaining,
          multiplier: globalMultiplier
        });
        updateFsBar();

        // DELAY: Pause between free spins for visibility
        await sleep(800);
      }

      // For free spins, do spin-out first
      if (eventType === 'freespin') {
        playSound('spin');
        renderBoard(new Set(), new Set(), new Map(), 'out');
        await sleep(200); // Slightly longer spin-out
      }

      // Set board from API - but DON'T update multipliers yet (they update AFTER win)
      board = apiScreenToBoard(event.screen);
      // Store the new multipliers but don't apply yet
      const pendingMultipliers = event.multipliers ? apiMultipliersToGrid(event.multipliers) : null;
      invalidateAllSymbols();

      // Animate spin-in for first event or each free spin
      if (eventIndex === 0 || eventType === 'freespin') {
        renderBoard(new Set(), new Set(), new Map(), 'in');
        await sleep(Math.max(400, 500 * t)); // Min 400ms for spin-in
      }
      renderBoard();

      // Brief pause after board settles before checking wins
      await sleep(200);

      // Process wins - ONLY highlight what API says won
      if (event.wins && event.wins.length > 0) {
        // DEBUG: Log multiplier state BEFORE processing win
        const maxGridMult = Math.max(...gridMultipliers.flat());
        console.log('%c[WIN]:', 'color: gold; font-weight: bold', {
          globalMult: globalMultiplier,
          maxGridMult: maxGridMult,
          inFreeSpins: inFreeSpins,
          winsCount: event.wins.length,
          winsDetail: event.wins.map(w => ({ sym: w.symbol, count: w.count, pay: w.pay, mult: w.multiplier }))
        });

        // DEBUG MODE: Log detailed cluster positions for verification
        logClusterDetails(event.wins, 'SPIN WIN');
        debugSetStatus(`Processing ${event.wins.length} cluster(s)`);

        const allWinCells = apiWinsToWinCells(event.wins);
        let maxClusterSize = 0;
        let tumbleWin = 0;

        for (const win of event.wins) {
          maxClusterSize = Math.max(maxClusterSize, win.count);
          tumbleWin += win.pay;
        }

        playWinSound(maxClusterSize);

        // STEP 1: Show winning clusters with CURRENT multipliers (before update)
        cleanAllWinStates();
        renderBoard(allWinCells);
        // DEBUG MODE: Add bright borders to winning cells for verification
        if (debugMode) {
          for (const key of allWinCells) {
            const [c, r] = key.split(',').map(Number);
            const cell = cellElements[c][r];
            cell.style.outline = '3px solid #0ff';
            cell.style.outlineOffset = '-3px';
            cell.style.boxShadow = '0 0 15px #0ff, inset 0 0 10px rgba(0,255,255,0.3)';
          }
        }
        showWinText(`+$${tumbleWin.toFixed(2)}`);

        // DEBUG MODE: Pause and wait for NEXT button
        if (debugMode) {
          await debugWaitForNext(`SPIN: ${event.wins.length} cluster(s), +$${tumbleWin.toFixed(2)}`);
        } else {
          await sleep(Math.max(400, 500 * t)); // Show win highlight
        }

        // STEP 2: NOW update multipliers and show the increase
        const increasedMultiCells = new Set();
        if (pendingMultipliers && inFreeSpins) {
          const prevMultipliers = gridMultipliers.map(col => [...col]);
          gridMultipliers = pendingMultipliers;
          console.log('%c[GRID MULTS UPDATED]:', 'color: #f0f', { prevMax: Math.max(...prevMultipliers.flat()), newMax: Math.max(...gridMultipliers.flat()) });
          for (const key of allWinCells) {
            const [c, r] = key.split(',').map(Number);
            if (gridMultipliers[c][r] > (prevMultipliers[c]?.[r] || 0)) {
              increasedMultiCells.add(key);
            }
          }
          // Re-render with updated multipliers and flash effect
          renderBoard(allWinCells, new Set(), new Map(), null, increasedMultiCells);
          await sleep(300); // Brief pause to see multiplier update
        }

        if (inFreeSpins) {
          totalFreeSpinWin += tumbleWin;
          updateFsRunningTotal(totalFreeSpinWin);
        }

        // STEP 3: Remove winning symbols (poof animation)
        cleanAllWinStates();
        playSound('poof');
        renderBoard(new Set(), allWinCells);
        await sleep(Math.max(250, 300 * t)); // Min 250ms for poof
      } else if (pendingMultipliers) {
        // No wins but still update multipliers if provided
        gridMultipliers = pendingMultipliers;
      }

    } else if (eventType === 'tumble') {
      // Tumble: new symbols fall in
      // Set board but DON'T update multipliers yet
      board = apiScreenToBoard(event.screen);
      const pendingTumbleMults = event.multipliers ? apiMultipliersToGrid(event.multipliers) : null;

      // Calculate drop animation
      const dropping = new Map();
      if (event.removed_positions) {
        for (let c = 0; c < COLS; c++) {
          let empties = event.removed_positions.filter(p => p.reel === c).length;
          for (let r = 0; r < empties; r++) {
            dropping.set(`${c},${r}`, empties - r);
          }
        }
      }

      invalidateAllSymbols();
      renderBoard(new Set(), new Set(), dropping);
      await sleep(Math.max(350, 400 * t)); // Min 350ms for drop animation
      cleanAllWinStates();
      renderBoard();
      await sleep(200); // Brief pause after tumble settles

      // Process tumble wins
      if (event.wins && event.wins.length > 0) {
        // DEBUG: Log multiplier state for tumble win
        const maxGridMult = Math.max(...gridMultipliers.flat());
        console.log('%c[TUMBLE WIN]:', 'color: gold', {
          globalMult: globalMultiplier,
          maxGridMult: maxGridMult,
          inFreeSpins: inFreeSpins,
          winsDetail: event.wins.map(w => ({ sym: w.symbol, count: w.count, pay: w.pay, mult: w.multiplier }))
        });

        // DEBUG MODE: Log detailed cluster positions for verification
        logClusterDetails(event.wins, 'TUMBLE WIN');
        debugSetStatus(`Tumble: ${event.wins.length} cluster(s)`);

        const allWinCells = apiWinsToWinCells(event.wins);
        let maxClusterSize = 0;
        let tumbleWin = 0;

        for (const win of event.wins) {
          maxClusterSize = Math.max(maxClusterSize, win.count);
          tumbleWin += win.pay;
        }

        playWinSound(maxClusterSize);

        // STEP 1: Show winning clusters with CURRENT multipliers
        cleanAllWinStates();
        renderBoard(allWinCells);
        // DEBUG MODE: Add bright borders to winning cells for verification
        if (debugMode) {
          for (const key of allWinCells) {
            const [c, r] = key.split(',').map(Number);
            const cell = cellElements[c][r];
            cell.style.outline = '3px solid #0ff';
            cell.style.outlineOffset = '-3px';
            cell.style.boxShadow = '0 0 15px #0ff, inset 0 0 10px rgba(0,255,255,0.3)';
          }
        }
        showWinText(`+$${tumbleWin.toFixed(2)}`);

        // DEBUG MODE: Pause and wait for NEXT button
        if (debugMode) {
          await debugWaitForNext(`TUMBLE: ${event.wins.length} cluster(s), +$${tumbleWin.toFixed(2)}`);
        } else {
          await sleep(Math.max(400, 500 * t)); // Show win highlight
        }

        // STEP 2: NOW update multipliers and show the increase
        const increasedMultiCells = new Set();
        if (pendingTumbleMults && inFreeSpins) {
          const prevMultipliers = gridMultipliers.map(col => [...col]);
          gridMultipliers = pendingTumbleMults;
          for (const key of allWinCells) {
            const [c, r] = key.split(',').map(Number);
            if (gridMultipliers[c][r] > (prevMultipliers[c]?.[r] || 0)) {
              increasedMultiCells.add(key);
            }
          }
          // Re-render with updated multipliers
          renderBoard(allWinCells, new Set(), new Map(), null, increasedMultiCells);
          await sleep(300); // Pause to see multiplier update
        }

        if (inFreeSpins) {
          totalFreeSpinWin += tumbleWin;
          updateFsRunningTotal(totalFreeSpinWin);
        }

        // STEP 3: Remove winning symbols
        cleanAllWinStates();
        playSound('poof');
        renderBoard(new Set(), allWinCells);
        await sleep(Math.max(250, 300 * t));
      } else if (pendingTumbleMults) {
        gridMultipliers = pendingTumbleMults;
      }

    } else if (eventType === 'freespin_trigger') {
      // Free spins triggered - enter free spin mode
      totalFreeSpinsInSequence = event.free_spins_awarded || spinResult.free_spins_total || 10;
      freeSpinsTotal = totalFreeSpinsInSequence;
      freeSpinsRemaining = totalFreeSpinsInSequence;
      currentFreeSpinNum = 0;

      // Enter free spins mode
      inFreeSpins = true;
      globalMultiplier = 1;
      totalFreeSpinWin = 0;
      initMultipliers();

      console.log('%c[FREE SPINS TRIGGERED]:', 'color: magenta; font-weight: bold', totalFreeSpinsInSequence);

      // Setup UI - switch URL bar to meltdown mode
      document.querySelector('.url-bar').classList.add('meltdown');
      document.getElementById('fsUrlInfo').classList.add('active');
      updateFsRunningTotal(0);
      crossfadeMusic('base', 'meltdown');
      pauseAutoplay();

      // Show trigger popup and wait for dismissal
      await showFsTrigger(totalFreeSpinsInSequence, false);
      updateFsBar();

      // DELAY: Brief pause before first free spin
      await sleep(1000);

    } else if (eventType === 'freespin_end') {
      // Free spins sequence ended
      console.log('%c[FREE SPINS END]:', 'color: magenta', { totalWin: totalFreeSpinWin });
    }
  }

  // Update balance from RGS
  balance = spinResult.balance;

  // Show final win
  const winAmount = spinResult.win || 0;
  if (winAmount > 0 && !inFreeSpins) {
    await animateWinCounter(winAmount);
    const winMulti = winAmount / bet;
    await showWinBanner(winMulti, winAmount);
  }

  // End free spins mode if we were in it
  if (inFreeSpins) {
    await endFreeSpins();
  }

  cleanAllWinStates();
  renderBoard();

  spinning = false;
  debugSetStatus('Spin complete - Ready');
  document.getElementById('spinBtn').disabled = false;
  document.getElementById('buyBtn').classList.remove('disabled');
  updateUI();
  startIdleAnimation();

  if (autoplayActive && !autoplayPaused) {
    setTimeout(() => continueAutoplay(), 1000 * getTurboMultiplier());
  }
}

// Fallback spin using local random (if RGS fails)
async function spinLocalFallback(bet, t) {
  playSound('spin');
  renderBoard(new Set(), new Set(), new Map(), 'out');
  await sleep(150 * t);

  initBoard();
  invalidateAllSymbols();
  renderBoard(new Set(), new Set(), new Map(), 'in');
  await sleep(450 * t);
  renderBoard();

  // Simple tumble loop
  let keepGoing = true;
  while (keepGoing) {
    const clusters = findClusters();
    if (clusters.length === 0) break;

    let tumbleWin = 0;
    const allWinCells = new Set();
    let maxClusterSize = 0;

    for (const cl of clusters) {
      const basePay = calcPayout(cl.symbol, cl.size);
      maxClusterSize = Math.max(maxClusterSize, cl.size);
      for (const [cc, cr] of cl.cells) {
        allWinCells.add(`${cc},${cr}`);
      }
      tumbleWin += basePay;
    }

    playWinSound(maxClusterSize);
    totalSpinWin += tumbleWin;

    cleanAllWinStates();
    renderBoard(allWinCells);
    showWinText(`+$${(tumbleWin * bet).toFixed(2)}`);
    await sleep(700 * t);

    cleanAllWinStates();
    playSound('poof');
    renderBoard(new Set(), allWinCells);
    await sleep(300 * t);

    const dropping = removeAndDrop(allWinCells);
    renderBoard(new Set(), new Set(), dropping);
    await sleep(350 * t);

    cleanAllWinStates();
    renderBoard();
    await sleep(150 * t);
  }

  const winAmount = totalSpinWin * bet;
  if (winAmount > 0) {
    balance += winAmount;
    await animateWinCounter(winAmount);
    await showWinBanner(winAmount / bet, winAmount);
    cleanAllWinStates();
    renderBoard();
  }

  spinning = false;
  document.getElementById('spinBtn').disabled = false;
  document.getElementById('buyBtn').classList.remove('disabled');
  updateUI();
  startIdleAnimation();
}

// ── FREE SPINS ──
async function startFreeSpins(spins) {
  inFreeSpins = true;
  freeSpinsRemaining = spins;
  freeSpinsTotal = spins;
  globalMultiplier = 1;
  totalFreeSpinWin = 0;
  initMultipliers();

  // Pause autoplay during free spins
  pauseAutoplay();

  // Crossfade to meltdown music
  crossfadeMusic('base', 'meltdown');

  await showFsTrigger(spins, false);
  updateFsBar();
  document.querySelector('.url-bar').classList.add('meltdown');
  document.getElementById('fsUrlInfo').classList.add('active');

  // Show and reset running total
  updateFsRunningTotal(0);
}

async function endFreeSpins() {
  inFreeSpins = false;
  // Switch URL bar back to normal mode
  document.querySelector('.url-bar').classList.remove('meltdown');
  document.getElementById('fsUrlInfo').classList.remove('active');

  // Reset grid atmosphere
  resetGridAtmosphere();

  // Clean all win states
  cleanAllWinStates();

  // Play free spins end sound
  playSound('freespinEnd');

  // Crossfade back to base music
  crossfadeMusic('meltdown', 'base');

  // Show total win screen (always show, even if win is 0)
  await showFsTotal(totalFreeSpinWin);

  // Clean win states again after overlay dismissed
  cleanAllWinStates();
  renderBoard();

  globalMultiplier = 1;
  initMultipliers();

  // Resume autoplay after free spins
  resumeAutoplay();
}

function updateFsRunningTotal(amount) {
  const amountEl = document.getElementById('fsRunningAmount');
  amountEl.textContent = `$${amount.toFixed(2)}`;

  // Update tier-based styling on the amount element itself
  const bet = BETS[betIndex];
  const multi = amount / bet;

  amountEl.classList.remove('tier-medium', 'tier-big', 'tier-mega');

  if (multi >= 100) {
    amountEl.classList.add('tier-mega');
  } else if (multi >= 50) {
    amountEl.classList.add('tier-big');
  } else if (multi >= 10) {
    amountEl.classList.add('tier-medium');
  }
}

// Free spins total win screen
const FS_TOTAL_TWEETS_BIG = [
  (handle, amount) => `ABSOLUTE CARNAGE. ${handle} just walked away with <span class="amount">${amount}</span>. The reels will never recover. 😭`,
  (handle, amount) => `HISTORIC MELTDOWN. ${handle} has extracted <span class="amount">${amount}</span> from the system. Thoughts and prayers. 💀`,
  (handle, amount) => `${handle} went full nuclear and emerged with <span class="amount">${amount}</span>. Someone call a cleanup crew. 🔥`,
  (handle, amount) => `BREAKING: ${handle} has officially broken the game. Total damage: <span class="amount">${amount}</span>. We're done here. 😱`
];

const FS_TOTAL_TWEETS_NORMAL = [
  (handle, amount) => `MELTDOWN COMPLETE. ${handle} survived with <span class="amount">${amount}</span>. Emotional damage: incalculable. 💀`,
  (handle, amount) => `The dust has settled. ${handle} walks away with <span class="amount">${amount}</span>. Therapy recommended. 😤`,
  (handle, amount) => `${handle}'s meltdown has concluded. Total receipts: <span class="amount">${amount}</span>. We're literally shaking. 🥴`,
  (handle, amount) => `END OF MELTDOWN. ${handle} collected <span class="amount">${amount}</span>. The safe space has been evacuated. 🚨`
];

const FS_TOTAL_TWEETS_ZERO = [
  (handle) => `MELTDOWN COMPLETE. ${handle} survived but the wallet didn't. Total damage: $0.00. Sending thoughts. 😭`,
  (handle) => `${handle}'s meltdown has ended with absolutely nothing to show for it. Classic. 💀`,
  (handle) => `The meltdown is over. ${handle} leaves with empty pockets and full regrets. 😤`
];

let fsTotalResolve = null;

function dismissFsTotal() {
  document.getElementById('fsTotalOverlay').classList.remove('show');

  // Clean all win states when overlay dismissed
  cleanAllWinStates();

  if (fsTotalResolve) {
    fsTotalResolve();
    fsTotalResolve = null;
  }
}

async function showFsTotal(totalWin) {
  const overlay = document.getElementById('fsTotalOverlay');
  const avatarEl = document.getElementById('fsTotalAvatar');
  const nameEl = document.getElementById('fsTotalName');
  const handleEl = document.getElementById('fsTotalHandle');
  const textEl = document.getElementById('fsTotalText');
  const amountEl = document.getElementById('fsTotalAmount');
  const commentsEl = document.getElementById('fsTotalComments');
  const retweetsEl = document.getElementById('fsTotalRetweets');
  const likesEl = document.getElementById('fsTotalLikes');

  // Pick random user and avatar
  const user = WIN_TWEET_HANDLES[Math.floor(Math.random() * WIN_TWEET_HANDLES.length)];
  const avatarSrc = getRandomAvatar();

  // Set user info
  avatarEl.src = avatarSrc;
  nameEl.textContent = user.name;
  handleEl.textContent = user.handle;

  // Set total win amount
  const amountStr = `$${totalWin.toFixed(2)}`;
  amountEl.textContent = amountStr;

  // Pick tweet based on win amount
  let tweetTemplate;
  if (totalWin <= 0) {
    const tweets = FS_TOTAL_TWEETS_ZERO;
    tweetTemplate = tweets[Math.floor(Math.random() * tweets.length)];
    textEl.innerHTML = tweetTemplate(user.handle);
  } else if (totalWin >= BETS[betIndex] * 50) {
    // Big win (50x+)
    const tweets = FS_TOTAL_TWEETS_BIG;
    tweetTemplate = tweets[Math.floor(Math.random() * tweets.length)];
    textEl.innerHTML = tweetTemplate(user.handle, amountStr);
  } else {
    const tweets = FS_TOTAL_TWEETS_NORMAL;
    tweetTemplate = tweets[Math.floor(Math.random() * tweets.length)];
    textEl.innerHTML = tweetTemplate(user.handle, amountStr);
  }

  // Set huge engagement stats
  commentsEl.textContent = (Math.floor(Math.random() * 150) + 50) + '.' + Math.floor(Math.random() * 10) + 'K';
  retweetsEl.textContent = (Math.floor(Math.random() * 300) + 150) + 'K';
  likesEl.textContent = (Math.floor(Math.random() * 9) + 1) + '.' + Math.floor(Math.random() * 10) + 'M';

  // Show overlay
  overlay.classList.add('show');

  // Return promise - no auto dismiss, must tap
  return new Promise((resolve) => {
    fsTotalResolve = resolve;
  });
}

function updateFsBar() {
  const played = freeSpinsTotal - freeSpinsRemaining;
  document.getElementById('fsCount').textContent = `${played}/${freeSpinsTotal}`;
  document.getElementById('fsMulti').textContent = `×${globalMultiplier}`;

  // Update grid atmosphere based on spins played
  updateGridAtmosphere(played);
}

function updateGridAtmosphere(spinsPlayed) {
  const gridFrame = document.querySelector('.grid-frame');
  gridFrame.classList.remove('meltdown-1', 'meltdown-2', 'meltdown-3');

  if (!inFreeSpins) return;

  if (spinsPlayed >= 10) {
    gridFrame.classList.add('meltdown-3');
  } else if (spinsPlayed >= 7) {
    gridFrame.classList.add('meltdown-2');
  } else if (spinsPlayed >= 4) {
    gridFrame.classList.add('meltdown-1');
  }
}

function resetGridAtmosphere() {
  const gridFrame = document.querySelector('.grid-frame');
  gridFrame.classList.remove('meltdown-1', 'meltdown-2', 'meltdown-3');
}

// Scatter anticipation effect for near-misses
async function showScatterAnticipation() {
  const gridFrame = document.querySelector('.grid-frame');
  const grid = document.getElementById('grid');

  // Add anticipation glow to grid frame
  gridFrame.classList.add('scatter-anticipation');

  // Highlight scatter symbols
  const cells = grid.querySelectorAll('.cell');
  cells.forEach((cell, idx) => {
    const c = idx % COLS;
    const r = Math.floor(idx / COLS);
    if (board[c][r] === 'scatter') {
      cell.classList.add('scatter-highlight');
    }
  });

  // Hold anticipation for dramatic effect
  await sleep(1200);

  // Remove anticipation effects
  gridFrame.classList.remove('scatter-anticipation');
  cells.forEach(cell => cell.classList.remove('scatter-highlight'));
}

// ── BONUS BUY ──
function showBuyConfirm() {
  if (spinning || inFreeSpins) return;
  document.getElementById('buyCost').textContent = `$${(BETS[betIndex] * BONUS_BUY_MULTI).toFixed(2)}`;
  document.getElementById('buyConfirmOverlay').classList.add('show');
}

function closeBuyConfirm() {
  document.getElementById('buyConfirmOverlay').classList.remove('show');
}

async function buyBonus() {
  closeBuyConfirm();
  const cost = BETS[betIndex] * BONUS_BUY_MULTI;
  if (balance < cost) return;

  // Play cash register sound
  playSound('cashregister');

  balance -= cost;
  updateUI();

  // Force 4+ scatters on the board
  inFreeSpins = false; // will be set by startFreeSpins
  spinning = true;
  document.getElementById('spinBtn').disabled = true;
  document.getElementById('buyBtn').classList.add('disabled');

  initBoard();
  initMultipliers();

  // Place 4 scatters randomly
  const positions = [];
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < ROWS; r++) {
      positions.push([c, r]);
    }
  }
  // Shuffle and pick 4
  for (let i = positions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [positions[i], positions[j]] = [positions[j], positions[i]];
  }
  for (let i = 0; i < 4; i++) {
    const [c, r] = positions[i];
    board[c][r] = 'scatter';
  }

  // Board changed - invalidate displayed symbols
  invalidateAllSymbols();
  renderBoard();
  await sleep(500);

  totalSpinWin = 0;
  totalFreeSpinWin = 0;
  await startFreeSpins(10);

  spinning = false;
  spin(); // start first free spin
}

// ── DISPLAY HELPERS ──
function showWinText(text) {
  const el = document.getElementById('winText');
  el.textContent = text;
  el.classList.toggle('show', text !== '');
}

const WIN_TWEET_HANDLES = [
  { name: "You", handle: "@YOU" },
  { name: "Slot Manager", handle: "@SlotManager" },
  { name: "Meltdown Bot", handle: "@MeltdownBot" },
  { name: "Safe Space Sally", handle: "@SafeSpaceSally" },
  { name: "Triggered Karen", handle: "@TriggeredKaren" },
  { name: "Woke Warrior", handle: "@WokeWarrior69" }
];

const WIN_TWEET_TEMPLATES = {
  'MICRO-AGGRESSION': (handle, amount) => `${handle} just micro-aggressed the reels for <span class="win-tweet-amount">${amount}</span> 💅`,
  'OFFENDED': (handle, amount) => `I'm literally offended by how much ${handle} just won: <span class="win-tweet-amount">${amount}</span> 😤`,
  'TRIGGERED': (handle, amount) => `${handle} is TRIGGERED after winning <span class="win-tweet-amount">${amount}</span> and I can't even 🔥`,
  'CANCELLED': (handle, amount) => `BREAKING: ${handle} has been CANCELLED for winning <span class="win-tweet-amount">${amount}</span> 💀`,
  'DEPLATFORMED': (handle, amount) => `${handle} has been DEPLATFORMED after winning <span class="win-tweet-amount">${amount}</span>. Account suspended. 🚫`
};

let winBannerTimeout = null;
let winBannerResolve = null;

function dismissWinBanner() {
  if (winBannerTimeout) {
    clearTimeout(winBannerTimeout);
    winBannerTimeout = null;
  }
  document.getElementById('winBannerOverlay').classList.remove('show');

  // NUCLEAR: Clean all win states when overlay dismissed
  cleanAllWinStates();

  // Resolve the promise so game can continue
  if (winBannerResolve) {
    winBannerResolve();
    winBannerResolve = null;
  }
}

async function showWinBanner(winMulti, winAmount) {
  let tier = null;
  for (const t of WIN_TIERS) {
    if (winMulti >= t.min) { tier = t; break; }
  }
  if (!tier) return;

  const overlay = document.getElementById('winBannerOverlay');
  const bannerImg = document.getElementById('winBannerImg');
  const fallbackEl = document.getElementById('winBannerFallback');
  const avatarEl = document.getElementById('winTweetAvatar');
  const nameEl = document.getElementById('winTweetName');
  const handleEl = document.getElementById('winTweetHandle');
  const textEl = document.getElementById('winTweetText');
  const commentsEl = document.getElementById('winStatComments');
  const retweetsEl = document.getElementById('winStatRetweets');
  const likesEl = document.getElementById('winStatLikes');

  // Pick random user and avatar
  const user = WIN_TWEET_HANDLES[Math.floor(Math.random() * WIN_TWEET_HANDLES.length)];
  const avatarSrc = getRandomAvatar();

  // Set user info
  avatarEl.src = avatarSrc;
  nameEl.textContent = user.name;
  handleEl.textContent = user.handle;

  // Set tweet text
  const amountStr = `$${winAmount.toFixed(2)}`;
  const template = WIN_TWEET_TEMPLATES[tier.label];
  if (template) {
    textEl.innerHTML = template(user.handle, amountStr);
  } else {
    textEl.innerHTML = `${user.handle} just won <span class="win-tweet-amount">${amountStr}</span>! 🎰`;
  }

  // Set random engagement stats
  commentsEl.textContent = (Math.floor(Math.random() * 4) + 1) + '.' + Math.floor(Math.random() * 10) + 'K';
  retweetsEl.textContent = (Math.floor(Math.random() * 15) + 5) + '.' + Math.floor(Math.random() * 10) + 'K';
  likesEl.textContent = (Math.floor(Math.random() * 40) + 10) + '.' + Math.floor(Math.random() * 10) + 'K';

  // Check if banner is preloaded, show image or fallback
  if (bannerCache[tier.banner] === true) {
    // Banner is preloaded - show image, hide fallback
    bannerImg.src = tier.banner;
    bannerImg.style.display = 'block';
    fallbackEl.style.display = 'none';
  } else if (bannerCache[tier.banner] === false) {
    // Banner failed to load - show fallback, hide image
    bannerImg.style.display = 'none';
    fallbackEl.style.display = 'flex';
    fallbackEl.style.background = `linear-gradient(135deg, ${tier.color}, ${tier.color}dd)`;
    fallbackEl.textContent = tier.label;
  } else {
    // Banner not yet loaded - try to load it now
    bannerImg.style.display = 'none';
    fallbackEl.style.display = 'none';

    const testImg = new Image();
    testImg.onload = () => {
      bannerImg.src = tier.banner;
      bannerImg.style.display = 'block';
      bannerCache[tier.banner] = true;
    };
    testImg.onerror = () => {
      fallbackEl.style.display = 'flex';
      fallbackEl.style.background = `linear-gradient(135deg, ${tier.color}, ${tier.color}dd)`;
      fallbackEl.textContent = tier.label;
      bannerCache[tier.banner] = false;
    };
    testImg.src = tier.banner;
  }

  // Screen shake for big wins
  if (winMulti >= 20) {
    document.getElementById('gameContainer').classList.add('shake');
    setTimeout(() => document.getElementById('gameContainer').classList.remove('shake'), 500);
  }

  // Play win banner sounds
  playSound('slam');
  playTierSound(tier.label);

  overlay.classList.add('show');

  // Return a Promise that resolves when banner is dismissed
  return new Promise((resolve) => {
    winBannerResolve = resolve;
    winBannerTimeout = setTimeout(() => {
      overlay.classList.remove('show');
      winBannerTimeout = null;
      if (winBannerResolve) {
        winBannerResolve();
        winBannerResolve = null;
      }
    }, 4000);
  });
}

// Ticker text for free spins trigger
const FS_TICKER_TEXT = "BREAKING: FULL MELTDOWN DETECTED • ALL REELS COMPROMISED • SAFE SPACES BREACHED • THIS IS NOT A DRILL • ";
const FS_RETRIGGER_TICKER_TEXT = "RETRIGGER ALERT • MELTDOWN EXTENDED • SOMEONE CALL A THERAPIST • EMOTIONS ARE ESCALATING • ";

let fsTriggerTimeout = null;

function createEmbers() {
  const container = document.getElementById('fsEmbers');
  container.innerHTML = '';

  // Create 30 ember particles
  for (let i = 0; i < 30; i++) {
    const ember = document.createElement('div');
    ember.className = 'fs-ember';
    ember.style.left = Math.random() * 100 + '%';
    ember.style.setProperty('--drift', (Math.random() * 60 - 30) + 'px');
    ember.style.animationDuration = (2 + Math.random() * 3) + 's';
    ember.style.animationDelay = Math.random() * 2 + 's';
    ember.style.width = (3 + Math.random() * 4) + 'px';
    ember.style.height = ember.style.width;

    // Random color variation (orange to red)
    const hue = 15 + Math.random() * 25;
    ember.style.background = `hsl(${hue}, 100%, 55%)`;
    ember.style.boxShadow = `0 0 ${4 + Math.random() * 4}px 2px hsla(${hue}, 100%, 50%, 0.8)`;

    container.appendChild(ember);
  }
}

function dismissFsTrigger() {
  const overlay = document.getElementById('fsTriggerOverlay');
  const gameContainer = document.getElementById('gameContainer');

  if (fsTriggerTimeout) {
    clearTimeout(fsTriggerTimeout);
    fsTriggerTimeout = null;
  }

  // NUCLEAR: Clean all win states when overlay dismissed
  cleanAllWinStates();

  // Fade out
  overlay.classList.add('fade-out');
  gameContainer.classList.remove('fs-shake');

  setTimeout(() => {
    overlay.classList.remove('show', 'fade-out');
  }, 300);
}

async function showFsTrigger(spins, isRetrigger) {
  const overlay = document.getElementById('fsTriggerOverlay');
  const flash = document.getElementById('fsFlash');
  const tickerText = document.getElementById('fsTickerText');
  const spinsText = document.getElementById('fsSpinsText');
  const gameContainer = document.getElementById('gameContainer');

  // Play free spins trigger sound
  playSound('freespinTrigger');

  // Set ticker text (doubled for seamless scroll)
  const ticker = isRetrigger ? FS_RETRIGGER_TICKER_TEXT : FS_TICKER_TEXT;
  tickerText.textContent = ticker + ticker + ticker + ticker;

  // Set spins count
  spinsText.textContent = isRetrigger ? `+${spins} MORE SPINS` : `${spins} FREE SPINS`;

  // Create ember particles
  createEmbers();

  // Show overlay
  overlay.classList.remove('fade-out');
  overlay.classList.add('show');

  // Trigger white flash
  flash.classList.add('active');
  setTimeout(() => flash.classList.remove('active'), 150);

  // Start heavy screen shake for entire duration
  gameContainer.classList.add('fs-shake');

  // Auto-dismiss after 3.5 seconds
  fsTriggerTimeout = setTimeout(() => {
    dismissFsTrigger();
  }, 3500);
}

// ── PAYTABLE ──
function buildPaytable() {
  const container = document.getElementById('paytableContent');
  let html = '';

  html += '<div class="pt-section-title">HIGH PAY SYMBOLS</div>';
  for (const id of ['h1','h2','h3','h4']) {
    html += buildPtRow(id);
  }

  html += '<div class="pt-section-title">LOW PAY SYMBOLS</div>';
  for (const id of ['l1','l2','l3','l4']) {
    html += buildPtRow(id);
  }

  html += '<div class="pt-section-title">SPECIAL SYMBOLS</div>';
  html += `
    <div class="pt-row">
      <div class="pt-symbol">${symImgHtml('wild', 40)}</div>
      <div style="flex:1; font-size:0.8rem;">
        <strong style="color:${SYMBOLS.wild.color}">Safe Space Wild</strong><br>
        <span style="color:rgba(255,255,255,0.5)">Accepts all symbols. Substitutes for all paying symbols in clusters</span>
      </div>
    </div>
    <div class="pt-row">
      <div class="pt-symbol">${symImgHtml('scatter', 40)}</div>
      <div style="flex:1; font-size:0.8rem;">
        <strong style="color:${SYMBOLS.scatter.color}">TRIGGERED Scatter</strong><br>
        <span style="color:rgba(255,255,255,0.5)">Triggers Meltdown Mode! 4 = 10 spins | 5 = 15 spins | 6+ = 20 spins</span>
      </div>
    </div>
  `;

  html += `
    <div class="pt-info">
      <strong>Cluster Pays:</strong> 5+ matching symbols connected horizontally or vertically form a winning cluster.<br><br>
      <strong>Tumble:</strong> Winning symbols are removed and new symbols drop in from above. Tumbles continue until no new clusters form.<br><br>
      <strong>Meltdown Mode (Free Spins):</strong> Grid positions track multipliers. First win activates ×1, each subsequent win on the same position doubles it (up to ×512). Global multiplier increases by 1 each spin.<br><br>
      <strong>Bonus Buy:</strong> 200× bet to skip directly to Meltdown Mode.<br><br>
      <strong>Max Win:</strong> 5,000× bet<br>
      <strong>RTP:</strong> 97.00%
    </div>
  `;

  container.innerHTML = html;
}

function buildPtRow(id) {
  const sym = SYMBOLS[id];
  const pays = PAYTABLE[id];
  let html = `<div class="pt-row"><div class="pt-symbol">${symImgHtml(id, 40)}</div><div class="pt-pays">`;
  for (const [size, pay] of Object.entries(pays)) {
    html += `<div class="pt-pay"><div class="cluster-size">${size}+</div><div class="payout">${pay}×</div></div>`;
  }
  html += '</div></div>';
  return html;
}

function symImgHtml(id, size) {
  const sym = SYMBOLS[id];
  // Use background-image instead of img to prevent flickering
  return `<div style="width:${size}px;height:${size}px;background-image:url('${sym.file}');background-size:contain;background-repeat:no-repeat;background-position:center;"></div>`;
}

function openPaytable() { document.getElementById('paytableOverlay').classList.add('show'); }
function closePaytable() { document.getElementById('paytableOverlay').classList.remove('show'); }

// ── UTILITY ──
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ── NOTIFICATION SYSTEM ──
const TWEET_MESSAGES = [
  "This slot was built on stolen land",
  "#PullMeToo",
  "This slot identifies as Blackjack",
  "REEEEE-spins activated",
  "My therapist said slots are self-care",
  "You could've bought avocado toast with that bet",
  "I want to speak to the slot manager",
  "Knitting a complaint about your last spin",
  "Manifesting a big win...",
  "Everyone gets a participation payout",
  "Signing a petition to ban losing spins",
  "Your bet just got cancelled",
  "This slot is carbon neutral",
  "That losing spin was problematic",
  "Emotional support spin incoming",
  "☕️ Latte foam shaped like rage",
  "📣 Virtue signal malfunction",
  "🧠 Emotional meltdown detected",
  "🧾 Demanding emotional damages",
  "😤 This reel hurt me",
  "🧠 Feelings > statistics",
  "🚨 Declaring reels unsafe",
  "🧠 Victim complex activated",
  "😡 Calling this a hate spin",
  "✊ Occupying the jackpot",
  "😢 Playing victim against math",
  "📢 Screaming at random numbers",
  "☭ Blaming capitalism for loss",
  "🪧 Protesting the spin button",
  "☕️ Yelp review loading",
  "⚖️ Filing lawsuit against jackpot",
  "💅 That win was problematic",
  "📣 Demanding a reroll immediately",
  "🚨 Calling this spin literal violence",
  "🧠 Self-diagnosed trauma from reel two",
  "💰 Demanding emotional compensation",
  "🪧 Organizing protest against reel three",
  "🏘️ Gentrification bonus removed",
  "🌱 Ethically sourced failure",
  "✅ Privilege tax applied",
  "♻️ Carbon-neutral failure achieved",
  "🔔 Trigger warning: spinning",
  "✊ Reparations jackpot denied",
  "🏳️‍🌈 This slot is non-binary",
  "🌈 Your reels are inclusive now",
  "💅 That payout was problematic",
  "🧾 Check your privilege multiplier",
  "🌿 Sustainably harvested bad luck",
  "🛡️ Your spin needs a safe space",
  "✊ Smash the patriarchy, spin again!",
  "📡 Built on colonized Wi-Fi",
  "🔍 Checking for cultural appropriation",
  "🩸 Periods are for everyone now",
  "🍼 Chestfeeding multiplier active",
  "👶 Kids know their gender at birth",
  "🧠 Logic is a tool of patriarchy",
  "🥩 Meat eaters are murderers",
  "🔬 Science is just another opinion",
  "👠 Drag queens are safer than parents",
  "🏅 Women's sports need more penises",
  "📐 Math is racist and oppressive",
  "💭 My feelings are more valid than facts",
  "🧬 Biology is transphobic hate speech",
  "😷 Double mask for extra equity",
  "⚖️ No justice, no jackpot",
  "😷 Mask on forever, safety first",
  "🤰 Birthing person jackpot unlocked",
  "🩺 Cervix-havers only in bonus",
  "❌ Facts rejected successfully",
  "😤 Blaming society for odds",
  "🏆 Victim complex maxed",
  "😠 Offended by math",
  "📢 Protest spins activated",
  "⚠️ Micro-aggression detected on reel three",
  "🛋️ Please sit in the safe zone"
];

const TWEET_HANDLES = [
  "@PronounPat", "@DEI_Diva", "@WokeWarrior69", "@SafeSpaceSally", "@TriggerWarningTom",
  "@AllyshipAlex", "@MicroAggroMike", "@CulturalAppProphet", "@ManifestingMandy", "@AstrologyActivist",
  "@EmotionalSupportEvan", "@VeganVirtueVera", "@ProtestPam", "@CancelCultureCarl", "@OrganicOprahFan",
  "@TherapyTheo", "@PrivilegeCheckerPete", "@SustainabilitySara", "@GentrifyGuru", "@RainbowReeee",
  "@NonBinaryNancy", "@BirthingPersonBob", "@MaskMandateMax", "@WhatIsAWomanWendy", "@TransRightsTina",
  "@ChestfeedingChad", "@BiologyBigotBlocker", "@72GendersGary", "@MathIsRacistMatt", "@SilenceIsViolenceSue",
  "@DecolonizeDave", "@WhitenessWarrior", "@PlantsHaveFeelingsPaula", "@LootingLiberator", "@BordersAreBadBen",
  "@DragQueenDefender", "@PubertyBlockerParent", "@MonogamyHaterMia", "@ScienceIsOpinionSam", "@CisSlurCaller",
  "@ReparationsRioter", "@PatriarchySmasher", "@LogicIsOppressiveLou", "@VaxxedAndMaskedVince", "@ColonialTimeCritic",
  "@EquityEnforcerEmma", "@TraumaTriggerTara", "@FeelingsOverFactsFran", "@HeteroHaterHal", "@WokeWordPolice"
];

let tweetTimeout = null;
let lastTweetIndex = -1;
let nextSide = 'left';

function isMobile() {
  return window.innerWidth <= 768;
}

// ── MOBILE: POPUP TWEET ──
function showMobileTweet() {
  const popup = document.getElementById('mobileTweetPopup');
  if (!popup) return;

  // Pick random message
  let msgIdx;
  do {
    msgIdx = Math.floor(Math.random() * TWEET_MESSAGES.length);
  } while (msgIdx === lastTweetIndex && TWEET_MESSAGES.length > 1);
  lastTweetIndex = msgIdx;

  // Pick random handle and avatar
  const handle = TWEET_HANDLES[Math.floor(Math.random() * TWEET_HANDLES.length)];
  const avatarSrc = getRandomAvatar();
  const message = TWEET_MESSAGES[msgIdx];

  // Update popup content
  const avatarEl = document.getElementById('mobileTweetAvatar');
  const handleEl = document.getElementById('mobileTweetHandle');
  const textEl = document.getElementById('mobileTweetText');

  if (avatarEl) avatarEl.src = avatarSrc;
  if (handleEl) handleEl.textContent = handle;
  if (textEl) textEl.textContent = message;

  // Play tweet sound
  playSound('tweet');

  // Show popup with animation
  popup.classList.add('show');

  // Hide after 4 seconds
  setTimeout(() => {
    popup.classList.remove('show');
  }, 4000);

  scheduleTweet();
}

// ── DESKTOP: TWEET CARDS ──
function showTweet() {
  if (isMobile()) {
    showMobileTweet();
    return;
  }

  // Pick random message
  let msgIdx;
  do {
    msgIdx = Math.floor(Math.random() * TWEET_MESSAGES.length);
  } while (msgIdx === lastTweetIndex && TWEET_MESSAGES.length > 1);
  lastTweetIndex = msgIdx;

  // Pick random handle and avatar
  const handle = TWEET_HANDLES[Math.floor(Math.random() * TWEET_HANDLES.length)];
  const avatarSrc = getRandomAvatar();
  const message = TWEET_MESSAGES[msgIdx];

  // Alternate sides
  const side = nextSide;
  nextSide = nextSide === 'left' ? 'right' : 'left';

  const card = document.getElementById(side === 'left' ? 'tweetLeft' : 'tweetRight');
  const avatarEl = document.getElementById(side === 'left' ? 'tweetAvatarLeft' : 'tweetAvatarRight');
  const handleEl = document.getElementById(side === 'left' ? 'tweetHandleLeft' : 'tweetHandleRight');
  const textEl = document.getElementById(side === 'left' ? 'tweetTextLeft' : 'tweetTextRight');

  avatarEl.src = avatarSrc;
  handleEl.textContent = handle;
  textEl.textContent = message;

  // Play tweet sound
  playSound('tweet');

  // Show card
  card.classList.add('show');

  // Hide after 5 seconds
  setTimeout(() => {
    card.classList.remove('show');
  }, 5000);

  scheduleTweet();
}

function scheduleTweet() {
  const delay = 8000 + Math.random() * 4000; // 8-12 seconds
  tweetTimeout = setTimeout(showTweet, delay);
}

/// Initialize tweets
scheduleTweet();

// ── TURBO MODE ──
let turboMode = false;

function getTurboMultiplier() {
  return turboMode ? 0.5 : 1;
}

function toggleTurbo() {
  turboMode = !turboMode;
  const btn = document.getElementById('turboBtn');
  btn.classList.toggle('turbo-active', turboMode);
}

// ── AUTOPLAY ──
let autoplayActive = false;
let autoplayRemaining = 0;
let autoplayPaused = false;

function toggleAutoplayMenu() {
  if (autoplayActive) {
    stopAutoplay();
    return;
  }
  const dropdown = document.getElementById('autoplayDropdown');
  dropdown.classList.toggle('show');
}

function startAutoplay(count) {
  document.getElementById('autoplayDropdown').classList.remove('show');
  autoplayActive = true;
  autoplayRemaining = count;
  autoplayPaused = false;
  updateAutoplayUI();

  // Start first auto spin if not already spinning
  if (!spinning) {
    spin();
  }
}

function stopAutoplay() {
  autoplayActive = false;
  autoplayRemaining = 0;
  autoplayPaused = false;
  updateAutoplayUI();
}

function updateAutoplayUI() {
  const btn = document.getElementById('autoplayBtn');
  const label = document.getElementById('autoplayLabel');

  if (autoplayActive) {
    btn.classList.add('active');
    label.innerHTML = `<span class="auto-count">${autoplayRemaining}</span>`;
  } else {
    btn.classList.remove('active');
    label.textContent = 'Auto';
  }
}

function pauseAutoplay() {
  if (autoplayActive) autoplayPaused = true;
}

function resumeAutoplay() {
  if (autoplayActive && autoplayPaused) {
    autoplayPaused = false;
    // Continue autoplay after a short delay
    setTimeout(() => {
      if (autoplayActive && !autoplayPaused && !spinning) {
        continueAutoplay();
      }
    }, 1000);
  }
}

function continueAutoplay() {
  if (!autoplayActive || autoplayPaused || spinning) return;

  // Check if we have spins remaining and enough balance
  if (autoplayRemaining <= 0 || balance < BETS[betIndex]) {
    stopAutoplay();
    return;
  }

  autoplayRemaining--;
  updateAutoplayUI();

  if (autoplayRemaining <= 0) {
    stopAutoplay();
  }

  spin();
}

// ── IDLE ANIMATION ──
let idleMode = false;

function startIdleAnimation() {
  if (spinning || inFreeSpins) return;
  idleMode = true;
  const grid = document.getElementById('grid');
  grid.classList.add('idle');

  // Set random delays for each cell
  const cells = grid.querySelectorAll('.cell');
  cells.forEach(cell => {
    const delay = Math.random() * 3000;
    cell.style.setProperty('--idle-delay', delay + 'ms');
  });
}

function stopIdleAnimation() {
  idleMode = false;
  const grid = document.getElementById('grid');
  grid.classList.remove('idle');
}

// Close autoplay dropdown when clicking outside
document.addEventListener('click', (e) => {
  const dropdown = document.getElementById('autoplayDropdown');
  const btn = document.getElementById('autoplayBtn');
  if (dropdown && !dropdown.contains(e.target) && !btn.contains(e.target)) {
    dropdown.classList.remove('show');
  }
});

// ── KEYBOARD SHORTCUTS ──
document.addEventListener('keydown', (e) => {
  // Check if any overlay is showing
  const overlaysOpen =
    document.getElementById('winBannerOverlay')?.classList.contains('show') ||
    document.getElementById('fsTriggerOverlay')?.classList.contains('show') ||
    document.getElementById('fsTotalOverlay')?.classList.contains('show') ||
    document.getElementById('buyConfirm')?.classList.contains('show') ||
    document.getElementById('paytableOverlay')?.classList.contains('show');

  // Spacebar to spin
  if (e.code === 'Space' && !e.repeat) {
    e.preventDefault();
    if (!overlaysOpen && !spinning) {
      spin();
    }
  }

  // Escape to dismiss overlays
  if (e.code === 'Escape') {
    if (document.getElementById('winBannerOverlay')?.classList.contains('show')) {
      dismissWinBanner();
    } else if (document.getElementById('fsTriggerOverlay')?.classList.contains('show')) {
      dismissFsTrigger();
    } else if (document.getElementById('fsTotalOverlay')?.classList.contains('show')) {
      dismissFsTotal();
    } else if (document.getElementById('buyConfirm')?.classList.contains('show')) {
      closeBuyConfirm();
    } else if (document.getElementById('paytableOverlay')?.classList.contains('show')) {
      closePaytable();
    }
  }
});

// ── START ──
init();
</script>

</body>
</html>